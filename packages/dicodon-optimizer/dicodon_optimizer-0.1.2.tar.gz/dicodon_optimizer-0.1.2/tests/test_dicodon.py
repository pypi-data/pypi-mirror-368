import dicodon_optimizer


def test_parse_fasta():
    input = """>hello
aCTGCagcgc
agcg
agaccc
>2nd thing
agc"""
    out = dicodon_optimizer.parse_fasta_to_dict(input)
    assert out["hello"] == "actgcagcgcagcgagaccc"
    assert out["2nd thing"] == "agc"


def test_codon_count_from_sequences():
    seq = "AGCAGCAGT", "ACC"
    counts = dicodon_optimizer.codon_count_from_sequences(seq)
    assert counts["acc"] == 1
    assert counts["agc"] == 2
    assert counts["agt"] == 1


def test_dicodon_count_from_sequences():
    seq = "AGCAGCAGT", "ACC"
    counts, errors = dicodon_optimizer.dicodon_count_from_sequences(seq, True)
    assert counts[("agc", "agc")] == 1
    assert counts[("agc", "agt")] == 1
    assert len(counts) == 2
    assert len(errors) == 1


def test_optimization():
    aa = "ITN"
    dicodon_frequencies = {}


def test_dicodon_score_dict_from_sequences():
    seqs = [
        """ATGGAGGTCAGCAACGTTTACTGGGATCTCGCCGCCAAAATCGCCTCCTACAGTGATGTA
GACGAGGCACTGTCGCTCGTGCTTGTTCACGTTGCACATTCCTTGCCTATACCTACGCTA
GGCCCACAAGGTTCTGGTGCCAACGCTCGTTTATCAGCCGAATTTGGCCGTACCTATCAC
GGTACTGCGCCAGACCGCTTCCTCCAGTTAATCACTGAAGAGGATCAGAAGTACAGCAAG
GGTTATCAATATAGCTGCAATCTCCCTTACCACCGAGTGCACTTACCATCTTCTCAGTCA
AGCGGCACCGGCAAGTCGCGCATGGTATACGAATGTAGGCATCGAACTCCTCTTCTCTAT
GTCTGCATTGGACCAACTAGCGCCGAAGGACCGGCCAAGAAAGCTTATCCCCTTCCTGAC
CGTGGTGTACGTTCCTTTTTCGAAGAGGCTCAGAAGACCCACAAGGATAAGTGTAACCTT
CAGATTGCCTGTTTCCTTGGCGCTTGGTTCTCGGAGCTTGCTCAACGCCTCGCCAACTTG
CCCACTCAGCAGCAAAAACACGACTATCTGATGCAGCTCAACCATCTCCATCTAAAGGAT
GGTATCAATGCTGAACGCACCGACTTCTTCCAAACCGTTTCCGAGCGCGCTTCTGACACC
CTCAAGCGTGCCGACAGCAGCTTTGACGAAAAGTCGAAACATAATGAACTCTTCACCGCT
CACCTCAAATCGCCGCTTGCCGCCCTCGAACGAGAGATGAAGTGTATCATAGCTCACATG
CACCCGCCCCACGACCACGGCGAATCATCACCCAGACCTCCTGTCATTGTGGCCTTCGAC
GGGTGTGTCGAACTCAACGTCGGATACGACCCAAACATAAATCAGCTCAACAGCCTTCAC
CGCGCATGGAATTGGATCAGCATCGAGCAAGCCAGAACCAGGACCACGACGTTCTGGCTT
GTGTTGATAAGTACCAGCATCAGCGCGGCCATTCTTGTCACGCGCTCTGCTCCGAGTGGG
TCCTCCCGTGGCATAGACCGAGTGCCACAGCCCATTTTCATCGACTTTGGTTTTGACATG
CTGCTTTCAGAGCAACCCAGCCTTTCTTGCGCCTCGCAAGCTTCTGCAGATTCTCACATC
ATTTACTACGGACGAGCGCTGTGGAAGGCATGCAGTCCTGATGATCTCTGGCTGATGGCC
AAATTCAAGTTGACAGGTGGTGAAAACTTTCGAATCTACGAAACCGCCCACTGCTACAGT
GTCTTGGCGTCTCGTCTCGGGCTAACCCTTTCGCCGACTGAATCGCCAGGATCGGCACTC
TTCGAATGGCAGAAGCAATTCGCGGGCAGTGCAGTAAATCGCCACATGCGCATTGTCACA
CATGTTACCAGCGAGGGTGTCATGCACGTTGAATCTCCATCAGAGCCTGTGCTAGCCATC
GCTGCCTCCAATATCATGCTGGCTCCCTACCTCCAGACACGTCAGAAAGCGAGAGGCTAC
AAGTATGCAGACATTCTCAAGAGATTTCAGCAACGTTGCTTGCTCAACCCCGGGGTTCCC
TTGCGCAAAAGAATCGAACAACCCAACCCAAAGGAATCGTCGGACACCCAACACGTGGGC
GCCAGCATCTACGCCAAGCCCGTGCCTCTCGAAAGCGTTCTTGAGAACCTTGCCGAGCTC
GACGATGCCAATCTCGGTGCGCTGCGCCAACGCCTGGAAGACGTCTACGATGCCGGCTCG
CGCACCGAACGGCATGCAATTCCGTTCAGAGATCAGTTGCAGTCGGCTTCCGCTACGCTG
CCGATATGGATCAACTTTACGCATTTCGACGTGCTGCCCAAAGCGATCAACGAGATAACA
CCCGAATTTCTGTGGTACTGTTGGAAACGTGGAGTAGCCGTGCAAATGGTGCACGCGCAG
TATGGTATCGATGGCATCATCCCGGTTTTCGTAGGTCATCTCGACCGGCTCTTCGTTGAT
GGTTCATCCACTGATGCCTCTAACATCACCCATGAGCCCAGAGAGGCCGAAATGCACGCT
GCGCGCTACATGACCTATGTTGTCTGGGAGGCAAGAAGCCGAAAGGATACACAGAGCACC
ACGGTCCCTGCTAGTTCAGCGCCTGTCGTTGCTGGACCGGTGATCAAGAGCGCCTCGATG
GCACCGCCAAACGAGAAGCCACTGACCGAACAGGCTCTGCTGAGCGTGCTTCTCGACCTT
GGCACAAGCACCGGATTCAAACGTGCGCCAGACGGCTTACAACCGCAAGTGAAGCATATT
ACCGGTCAACAGTGTCCTCGGCTGTGTATTCAGGGTGTGCTCGATCCGCACACTTACCCC
TGTCTGGACCTTTTCGAGCTCCGCCCAACCTTGGTCGAGATTCTGTCGTCTAGCTCTGAT
CCCGCACCGAACCCTCTCAACAGCATCGAAAAGACTCTGTGGAATGAGCACAACCAGCCC
GTTTCTGATTCCATCTAG""".replace(
            "\n", ""
        )
    ]

    scores, errors = dicodon_optimizer.dicodon_score_dict_from_sequences(seqs, True)
    assert len(scores) == 716


def test_score():

    s = dicodon_optimizer.score("AGTAGTTTT", {("agt", "agt"): 1.0, ("agt", "ttt"): 0.3})
    assert s == [(('agt', 'agt'), 1.0), (('agt', 'ttt'), 0.3)]


def test_optimize_dicodon_usage():
    s = {
        ('att','acc'): 0.9,
        ('ata','aca'): 0.1,
        ('aca', 'ggc'): 1,
        #'ATT', ATC, ATA -> I
        #ACT, ACC, ACA, ACG _> T
        #GGT,GGC,GGA, GGG -> G
        }
    better = dicodon_optimizer.optimize_dicodon_usage("ITG", s)
    assert better[0] == 'ataacaggc' # must choose the 0.1 because there is no other way
    assert sum((x[1] for x in dicodon_optimizer.score(better[0], s))) == .1+1
    assert sum((x[1] for x in better[1])) == .1+1
    assert len(better[1]) == 2
    s = {
        ('att','acc'): 0.9,
        ('ata','aca'): 0.1,
        ('aca', 'ggc'): .5,
        ('acc', 'ggc'): .5,
        #'ATT', ATC, ATA -> I
        #ACT, ACC, ACA, ACG _> T
        #GGT,GGC,GGA, GGG -> G
        }
    better = dicodon_optimizer.optimize_dicodon_usage("ITG", s)
    assert better[0] == 'attaccggc' # must choose the 0.1 because there is no other way
    assert sum((x[1] for x in dicodon_optimizer.score(better[0], s))) == .9+.5
