const vscode = require("vscode");
const cp = require("child_process");
const path = require("path");
const fs = require("fs");

function activate(context) {
  const runPythonCommand = (commandName) => {
    const editor = vscode.window.activeTextEditor;

    if (!editor) {
      vscode.window.showErrorMessage("[pyxend] No active editor.");
      return;
    }

    const selection = editor.selection;
    const document = editor.document;
    const selectedText = document.getText(selection) || "";
    const fullText = document.getText() || "";
    const language = document.languageId || "";
    const filePath = document.uri.fsPath || "";
    const cursorPos = selection ? { line: selection.start.line, character: selection.start.character } : null;
    const cursorWord = document.getText(document.getWordRangeAtPosition(editor.selection.active)) || "";
    const lines = document.lineCount || 0;
    const fileSize = Buffer.byteLength(fullText, "utf-8");
    const workspaceFolders = vscode.workspace.workspaceFolders || [];
    const openedFiles = vscode.workspace.textDocuments.map(doc => doc.uri.fsPath);
    const isSaved = !document.isDirty;
    const workspace = workspaceFolders.length > 0 ? workspaceFolders[0].uri.fsPath : "";

    const contextPayload = {
      selected_text: selectedText,
      all_text: fullText,
      language,
      file_path: filePath,
      cursor_pos: cursorPos,
      cursor_word: cursorWord,
      lines,
      file_size: fileSize,
      opened_files: openedFiles,
      is_saved: isSaved,
      workspace
    };

    const scriptPath = path.join(__dirname, "main.py");
    const args = [scriptPath, commandName, JSON.stringify(contextPayload)];

    const py = cp.spawnSync("python", args, { encoding: "utf-8" });

    if (py.stderr) {
      vscode.window.showErrorMessage("[pyxend] Python stderr: " + py.stderr.trim());
      return;
    }

    let actions;
    try {
      actions = JSON.parse(py.stdout);
    } catch (e) {
      vscode.window.showErrorMessage("[pyxend] Invalid JSON from Python");
      return;
    }

    if (!Array.isArray(actions)) {
      vscode.window.showErrorMessage("[pyxend] " + (actions.error || "Unknown error"));
      return;
    }

    actions.forEach((action) => {
      const editor = vscode.window.activeTextEditor;
      const document = editor?.document;

      switch (action.action) {
        case "show_modal":
          const type = action.type || "info";
          const msg = action.message;
          if (type === "error") vscode.window.showErrorMessage(msg);
          else if (type === "warning") vscode.window.showWarningMessage(msg);
          else vscode.window.showInformationMessage(msg);
          break;

        case "replace_selected_text":
          vscode.window.showWarningMessage("[pyxend] Action 'replace_selected_text' is deprecated and will be removed in 1.0.0. Use 'replace_text' with preset 'selected' instead.");
          if (!editor || !selection) {
            vscode.window.showErrorMessage("[pyxend] Cannot replace text: no selection or editor.");
            return;
          }
          editor.edit(editBuilder => {
            editBuilder.replace(selection, action.text || "");
          });
          break;

        case "open_file":
          if (!action.path) {
            vscode.window.showErrorMessage("[pyxend] Cannot open file: no path provided.");
            return;
          }
          if (!fs.existsSync(action.path)) {
            vscode.window.showErrorMessage("[pyxend] File does not exist: " + action.path);
            return;
          }
          vscode.workspace.openTextDocument(action.path).then(doc => {
            vscode.window.showTextDocument(doc);
          });
          break;

        case "set_cursor_pos":
          if (!editor) {
            vscode.window.showErrorMessage("[pyxend] Cannot set cursor: no editor.");
            return;
          }
          if (typeof action.line !== 'number' || typeof action.character !== 'number') {
            vscode.window.showErrorMessage("[pyxend] Invalid cursor position.");
            return;
          }
          const position = new vscode.Position(action.line, action.character);
          editor.selection = new vscode.Selection(position, position);
          editor.revealRange(new vscode.Range(position, position));
          break;

        case "save_file":
          if (!document) {
            vscode.window.showErrorMessage("[pyxend] Cannot save: no document.");
            return;
          }
          document.save();
          break;

        case "run_terminal_command":
          if (!action.command) {
            vscode.window.showErrorMessage("[pyxend] No terminal command provided.");
            return;
          }
          const terminal = vscode.window.createTerminal(action.terminal_name || "pyxend terminal");
          terminal.show();
          terminal.sendText(action.command);
          break;
        case "overwrite_file":
          vscode.window.showWarningMessage("[pyxend] Action 'overwrite_file' is deprecated and will be removed in 1.0.0. Use 'replace_text' with preset 'all' instead.");
          if (!editor || !document) {
            vscode.window.showErrorMessage("[pyxend] Cannot overwrite file: editor or document missing.");
            return;
          }
          const entireRange = new vscode.Range(
            document.positionAt(0),
            document.positionAt(document.getText().length)
          );
          editor.edit(editBuilder => {
            editBuilder.replace(entireRange, action.text || "");
          });
          break;
        case "delete_selected_text":
          if (!editor || !selection) {
            vscode.window.showErrorMessage("[pyxend] Cannot delete: no selection.");
            return;
          }
          editor.edit(editBuilder => {
            editBuilder.delete(selection);
          });
          break;

        case "insert_text":
          if (!editor || !document) return;
          let insertPos;
          if (action.preset === "start") {
            insertPos = new vscode.Position(0, 0);
          } else if (action.preset === "end") {
            const lastLine = document.lineCount - 1;
            insertPos = new vscode.Position(lastLine, document.lineAt(lastLine).text.length);
          } else if (action.preset === "cursor") {
            insertPos = editor.selection.active;
          } else if (typeof action.line === "number" && typeof action.character === "number") {
            insertPos = new vscode.Position(action.line, action.character);
          } else {
            vscode.window.showErrorMessage("[pyxend] Invalid insert_text_at position.");
            return;
          }
          editor.edit(editBuilder => {
            editBuilder.insert(insertPos, action.text || "");
          });
          break;

        case "replace_text":
          if (!editor || !document) {
            vscode.window.showErrorMessage("[pyxend] Cannot replace text: missing editor or document.");
            return;
          }

          let replaceRange;

          if (action.preset === "all") {
            replaceRange = new vscode.Range(
              document.positionAt(0),
              document.positionAt(document.getText().length)
            );
          } else if (action.preset === "selected") {
            if (!selection || selection.isEmpty) {
              vscode.window.showErrorMessage("[pyxend] Cannot replace selected text: no selection.");
              return;
            }
            replaceRange = new vscode.Range(selection.start, selection.end);
          } else if (
            action.start &&
            action.end &&
            typeof action.start.line === "number" &&
            typeof action.start.character === "number" &&
            typeof action.end.line === "number" &&
            typeof action.end.character === "number"
          ) {
            replaceRange = new vscode.Range(
              new vscode.Position(action.start.line, action.start.character),
              new vscode.Position(action.end.line, action.end.character)
            );
          } else {
            vscode.window.showErrorMessage("[pyxend] Invalid range or preset for replace_text.");
            return;
          }

          editor.edit(editBuilder => {
            editBuilder.replace(replaceRange, action.text || "");
          });
          break;

        case "delete_file":
          if (!filePath || !fs.existsSync(filePath)) {
            vscode.window.showErrorMessage("[pyxend] Cannot delete file: not found.");
            return;
          }
          fs.unlinkSync(filePath);
          break;

        case "select_range":
          if (!editor || typeof action.start.line !== "number" || typeof action.start.character !== "number"
            || typeof action.end.line !== "number" || typeof action.end.character !== "number") {
            vscode.window.showErrorMessage("[pyxend] Invalid selection range.");
            return;
          }
          const start = new vscode.Position(action.start.line, action.start.character);
          const end = new vscode.Position(action.end.line, action.end.character);
          editor.selection = new vscode.Selection(start, end);
          editor.revealRange(new vscode.Range(start, end));
          break;

        case "open_terminal":
          vscode.window.createTerminal(action.name || "pyxend").show();
          break;

        case "run_terminal":
          {
            const name = action.name || "pyxend";
            let terminal = vscode.window.terminals.find(t => t.name === name);
            if (!terminal) terminal = vscode.window.createTerminal(name);
            terminal.show();
            terminal.sendText(action.command || "");
          }
          break;

        case "close_terminal":
          {
            const name = action.name || "pyxend";
            const terminal = vscode.window.terminals.find(t => t.name === name);
            if (terminal) terminal.dispose();
          }
          break;

        case "switch_to_file":
          if (!action.path || !fs.existsSync(action.path)) {
            vscode.window.showErrorMessage("[pyxend] Cannot switch: file not found.");
            return;
          }
          vscode.workspace.openTextDocument(action.path).then(doc => {
            vscode.window.showTextDocument(doc);
          });
          break;

        case "reload_editor":
          vscode.commands.executeCommand("workbench.action.reloadWindow");
          break;
        default:
          vscode.window.showWarningMessage("[pyxend] Unknown action: " + action.action);
      }
    });
  };

  context.subscriptions.push(
    {% for command in commands %}
    vscode.commands.registerCommand("{{ extension_name }}.{{ command }}", () => {
      runPythonCommand('{{ command }}');
    }),
    {% endfor %}
  );
}

function deactivate() {}

module.exports = { activate, deactivate };
