
经常会遇到因新需求的出现而要求增加数据表的字段。但直接修改表结构，可能会影响到现有代码的稳定性，以及数据的一致性。

针对这种情况，一般有两种解决办法：

- 预留字段
- 预留一个json的字段

但这两者都有一个问题：就是无法建立索引，这对需要搜索的新需求来说，是很不友好的。而且预留字段的方案还会出现语义方面的问题，如果有多个需求同时出现，还会产生歧义。

jxORM则提供了一种称之为**继承性扩展**的解决方案：

1、新需求需要增加字段时，通过继承现数据类从而创建一个新的数据类，在新的数据类中增加新的字段

2、jxORM自动根据数据类间的继承关系来完成数据库中的数据操作

## 数据类的继承

数据类的继承和普通类的继承是一样的：

    @ORM
    class User2(User):
        ID:DBDataType.Long = ColType.PrimaryKey
        State:DBDataType.Chars = 1
        Noused:DBDataType.Bool
    User2.create(db)

唯一的要求就是：**有继承关系的数据类都必须以ID为主键**。

<font color=red size=3>注：</font>在jxORM中，建议实体类都以ID为主键，这样可以方便的实现数据的扩展。同时jxORM还提供了GetByID来简化数据对象的获取

## 数据表的级联

jxORM在根据数据类的定义在数据库中创建数据表时，只会创建本类所定义的那些字段。如User2表：

    CREATE TABLE `User2` (
      `ID` bigint NOT NULL,
      `State` varchar(126) NOT NULL,
      `Noused` tinyint NOT NULL,
      PRIMARY KEY (`ID`),
      KEY `User2_index_1` (`State`)
    ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci

所以，jxORM会根据User2和User的继承关系，在读取User2时，自动级联User表，通过两表的ID相等这个条件实现联合查询，从而获得全部的数据：

    user = User2.GetByName(db, 'admin')
    #虽然User2没有Name字段，但是User2是继承自User的，所以通过User2.ID=User.ID
    #就可以实现同时从User、User2表中查询出数据拼接给user对象

在Insert、Update时，jxORM会根据各属性和数据类的关系，将各属性数据分别插入或更新到对应的数据表中。

也就是说，在读取带继承的数据类时，是一个自动关联了所有父表的联合查询。而在插入或更新时，则是各表单独的插入或更新。

由于jxORM中所有的数据库操作都是在事务中执行的，所以这种各表单独的插入或更新，依然可以确保数据的一致性。

## jxORM继承性扩展数据的优势

1、不影响现有代码

在继承性扩展中，使用某个数据类来访问数据库，只会关联其父类，而不会关联子类。所以新增的数据字段不会出现在现有代码的查询结果中。

同样，对本类的数据操作也只会发生在自己和父类所对应的数据表中，不会涉及到新的数据字段。

2、**新需求间实现了逻辑隔离**

不同的需求可能需要扩展各自的字段，通过各自继承出本需求专用的数据类，这些需求就实现了数据隔离。

即，因为数据查询是通过父类和子类ID相等来实现多表联合查询的，由于这种ID相等只会出现在各自的插入操作中，而ID是主键，所以不同的业务需求是不可能出现将其它需求的父类数据查出来的。

3、新增字段可以建立自己的索引，当然也有自己的业务语义

这可以充分优化复杂业务的查询速度。也自然会减少多种需求同时存在时的歧义问题。

4、可以持续性跟踪需求变化

jxORM的继承性扩展可以一直继承下去，即，从父类继承出来的子类可以被其它类继续继承，没有层级的限制。
