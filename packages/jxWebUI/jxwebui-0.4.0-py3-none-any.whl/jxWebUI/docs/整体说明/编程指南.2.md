jxWebUI编程的核心是capa。创建capa前需先import：

	from jxWebUI import jxWebCapa

然后就可以创建一个capa：

	capa = jxWebCapa('demo.hello_world')

capa可以理解为一个模块，围绕某个功能，如用户管理，来组织页面和代码。capa是一个桥，用来衔接webUI与python代码，为开发者提供一个简单易用的webUI操作环境。

capa主要包括两部分功能：一是web界面、web事件响应函数等的定义，这部分主要是通过web等修饰符来实现；二是提供web界面的输入输出语句，这主要是capa实例中的getInput、setOutput等对象函数来实现。

用户每打开一个相应的页面，jxWebUI就创建定义该页面的capa的一个实例来处理用户的输入输出，并完成事件函数的调用。

## 修饰器

capa有六个修饰器来定义自己所管理的页面、代码等。

#### web

web修饰器用来定义本capa所管理的页面。其所修饰的函数被带入一个page对象，开发者就可以给这个page通过编程添加各种web组件了。

	@capa.web  
	def list_user(page):  
	    t = page.table().width(900)
	    r = t.row()
	    r.text().width(200).text('hello_world')

这段代码，就定义了一个名为hello_world的页面：

![hello_world](http://115.29.52.95:10018/images/hello_world.png)

每个页面打开时，浏览器都会创建一个tab来容纳这个page。而一个tab可以容纳多个page，但其中只能有一个page是主page用来显示数据、操作按钮等，其它page都只能是对话框，辅助主page工作。

一个capa可以定义多个page，包括多个主page【根据需要显示到不同的tab中工作】，以形成连续的工作流和完善的管理工作。

我们把capa理解为功能模块就可以了，只不过这个功能模块带有本模块的所有UI。

换句话说，我们就按正常的业务逻辑来组织python代码就可以了，只不过在每个模块中增加一个webui.py这样的py代码文件来管理本模块的所有webUI。

<font color=red size=3>注：</font>jxWebUI目前在权限管理使用的是静态权限映射，所以需要开发者自行管理capa并在权限变更时自行重置权限
#### cmd

cmd与disp修饰符用来定义本capa所管理的webUI代码。jxWebUI中的代码都是事件驱动的，主要包括两种：

- disp，页面初始化事件，在页面打开时被调用，该事件响应函数就是disp修饰符所修饰的函数
- cmd，用户点击事件，在用户点击按钮时被调用，该事件响应函数是cmd修饰符所修饰的函数

其它还包括数据输入事件、定时器事件等。

disp事件和cmd事件的事件名，就是各修饰符所修饰的函数名。

所有的事件函数，函数签名都是：

	event_name(capa_instance, db_connection, ctx) -> None

其参数包括：

1、capa_instance：触发本事件的capa的实例，可以看做同一个tab所对应的capa实例

同一个page可以同时显示到两个tab中，比如查询销售订单，同样的订单页面，但根据订单的不同，显示的信息是不一样的。由于相同的page，web组件的名字都是相同的，所以需要不同的capa_instance来管理这些相同定义的web组件。

也就是说，capa可以看做一个类，而capa_instance就是用户打开页面时创建的具体来完成用户操作的对象

2、db_connection：数据库连接

在调用事件函数时，capa_instance会创建一个数据库连接，并启用数据库事务，该事件函数在执行期间在此数据库连接上执行的所有的数据库操作，都会作为一个事务整体提交。如果事件函数异常，则该事务自动回滚。

所以，在事件函数中的所有数据库操作具有原子性。

<font color=red size=3>注1：</font>jxWebUI为集中处理webUI，所以自身是不依赖、引用任何数据库的，只提供了一个数据库连接获取操作接口。只要按该接口的要求送入数据库连接即可。具体信息请参考数据库相关说明

<font color=red size=3>注2：</font>为保持最小化启动需要，未连接数据库时，jxWebUI忽视所有数据库操作，所以不会影响不涉及数据库操作的函数调用

3、ctx：上下文

上下文是事件函数执行时的当前环境。目前只提供了当前登录用户的信息。

<font color=red size=3>注：</font>jxWebUI为集中处理webUI，同样不对用户的认证等进行任何处理，只要求外部送入一个用户查询接口，在登录时根据用户名、密码获取到一个用户对象。该用户对象是一个鸭子类型，提供三个对象函数即可，分别是

- name() -> str，用户名
- abbr() -> str，可能出现重名，所以还需要一个简称来区分重名的用户，jxWebUI会使用abbr来进行权限的查询
- roles() -> list，该用户所有映射的角色名数组

不设置用户查询接口，则任何人都可以随意登录；设置了用户查询接口，返回None则拒绝用户的登录请求。

#### disp

disp修饰符用来定义对应web页面的初始化事件函数。

该函数将在同名页面打开时被调用，以完成该页面打开后的数据装订工作。

#### page

page修饰器同样是用来定义本capa所管理的页面。jxWebUI最初的版本中，定义页面都是用文本进行定义的，放到用page修饰的函数的doc中。如上述的hello_world页面，用文本描述为：

	@capa.page  
	def hello_world(ci, db, ctx):  
	    '''
	        table table_hello_world width=900:
	            row
	                text text_hello_world text='hello_world',width=200
	        ;
	    '''
	    pass

<font color=red size=3>注：</font>本质上，jxWebUI的页面都是用文本进行定义的。web修饰符只不过用了程序员更熟悉的编程方式来编写界面定义，然后jxWebUI将开发者编写的代码执行后生成等价于page修饰符所使用的文本定义

#### close

close修饰器用来声明一个事件函数，该函数在页面关闭时被调用。
	
	@capa.close
	def on_close(ci, db, ctx):
        ...

close修饰符固定占用了on_close函数名，所以不能定义再以on_close命名其它的事件函数。

#### sql

sql修饰器用来定义一个数据查询语句，用于数据表【条件查询、分页显示】的自动化处理。
	
	@capa.sql
	def sqlTest(ci, db, ctx):
	    '''
	        select Name as devName, Type as devType, ID as devID from Device ;
	    '''
	    pass

目前，jxWebUI只支持标准SQL查询语句的的select、from、where、order by子句，同时必须以分号结束。

一个sql修饰符只能定义一个查询语句，该查询语句称为**数据源**。名字就是sql修饰器所修饰的函数的函数名。

jxWebUI内置了一个数据表**条件查询分页显示**的工作流，通过在定义一个数据表的disp入口中设置dataSource参数，jxWebUI会自动将sql修饰的数据查询语句进行配置来完成查询条件的设置和查询结果的分页显示。

sql的具体使用请查阅数据库连接与操作、数据表的相关说明。

## 对象函数

capa有两个对象函数：

#### shortCutTree_add_item

shortCutTree_add_item函数用来添加一个快捷栏目录。

	shortCutTree_add_item(self, folder, label, demand, authority='common', **attrs)
	folder：快捷栏一级目录名
	label：快捷栏二级目录名
	demand：要显示的page名
	authority：该目录的授予对象名，默认公共权限【任何人都可使用】
	attrs：在显示page时送入的参数表
	
	如：
	capa.shortCutTree_add_item('测试', '测试1', 'test_web')
	会在左侧的快捷栏中出现一个二级目录：测试->测试1

![test_web](http://115.29.52.95:10018/images/test_web_2.png)

#### btn_list_add

btn_list_add函数用来给一个主page添加工具条。

	btn_list_add(self, page, motion, demand, authority='common', **attrs)
	page：目标页面
	motion：disp【显示页面】、cmd【触发一个事件函数】
	demand：要显示的page名
	authority：该目录的授予对象名，默认公共权限【任何人都可使用】
	attrs：参数表

	如：
	capa.btn_list_add('test_web2', 'disp', 'dialog_test', dispInDialog=True, text='对话框', confirm='确认开启用户跟踪？')
	会在test_web2页面显示时添加一个【对话框】的工具条，用户点击该工具条，则会弹出dialog_test对话框
	
![test_web](http://115.29.52.95:10018/images/bc_3.png)

## capaInstance对象函数

capaInstance主要完成用户自己编写的事件处理函数中和webUI的IO。其提供了：

#### getInput

getInput函数用来读取用户在输入控件中的输入数据。

	getInput(self, data_name) -> any
	data_name：就是在page定义web组件时，给输入控件设置的bind属性。输入控件【文本输入框、下拉选择框、日期选择框等】在用户输入后，会以其bind属性为名将用户的输入送到对应的CapaInstance。事件处理函数中就可以调用getInput获取到用户的输入了

#### getInput_base64

jxWebUI有几个web控件是使用base64编码来传递数据的，这样的控件在获取数据时使用的getInput_base64函数。

	getInput_base64(self, data_name) -> any
	data_name：就是在page定义web组件时，给输入控件设置的bind属性。输入控件【文本输入框、下拉选择框、日期选择框等】在用户输入后，会以其bind属性为名将用户的输入送到对应的CapaInstance。事件处理函数中就可以调用getInput获取到用户的输入了

使用base64传递数据的web控件有：textArea、codeEditor。
#### web_info

web_info函数用来在浏览器中弹出一个消息提示框。

	web_info(self, title, msg)
	title：消息提示框的标题
	msg：消息提示框的消息
	如：
	capa_instance.web_info('提示', '对话框提示信息')
	执行后会在浏览器中弹窗显示：


![hello_world](http://115.29.52.95:10018/images/bc_1.png)

#### setIOutput

setOutput函数用来将数据输出给web界面中的相应的web组件。

	setOutput(self, data_name, value)
	data_name：同getInput
	value：要输出的数据

#### setOutput_base64

jxWebUI有几个web控件是使用base64编码来传递数据的，这样的控件在输出数据时使用的setOutput_base64函数，当然，自行编码后使用setOutput也没问题。

	setOutput_base64(self, data_name, value)

使用base64传递数据的web控件有：textArea、codeEditor。

#### setIAttr

setAttr函数用来给web界面中相应的web组件设置属性。

	setIAttr(self, wo_name, attr, value, base64=False)
	wo_name：控件名，和getInput、setOutput使用的数据名不同，setAttr使用的是控件名
	attr：要设置的属性名称，如enable【使能】、width【宽度】等
	value：要设置的属性值
	base64：是否需要base64编码，默认False，仅当value为字符串时有效

<font color=red size=3>注1：</font>wo_name是每个web组件在定义时都**必须指定的唯一名**【同一个capa】，如果出现重名，在同一个tab中显示的时候，会出现各种混乱，如控件消失、错误引用等等。由于每个组件都要写组件名还不能重复，所以在设计复杂页面时很麻烦，编程式web界面定义中开发者可以忽略组件名，则jxWebUI会自动给其取一个唯一名，但由于这个名字谁也不知道，而且页面变动后也可能发生变化，所以如果开发者需要操作所定义的web组件，则需要显式给出wo_name

<font color=red size=3>注2：</font>数据名只有在web组件定义时指定了bind属性时才会有，没有bind的就没有，也就不会有输入，即getInput函数读不到

<font color=red size=3>注3：</font>attr是jxWebUI定义的属性，需查阅相应web组件的说明，如果设置了该组件未声明的属性，不会有任何效果。编程式web界面定义中如果设置了未声明的属性，则会掷出异常

#### set_output_datatable

set_output_datatable函数用来向数据表组件输出整表数据。

	set_output_datatable(self, table_name, data_arr)
	table_name：数据表的wo_name
	data_arr：要输出的行列数据：
	[
		#row 0
		{
			col_0_name: col_0_value,
			col_1_name: col_1_value,
			col_2_name: col_2_value,
			...
			col_n_name: col_n_value,
		},
		#row 1
		{
			col_0_name: col_0_value,
			col_1_name: col_1_value,
			col_2_name: col_2_value,
			...
			col_n_name: col_n_value,
		},
		...
	]

数据表的数据有特殊的格式，为简化程序员的使用，用set_output_datatable进行了简化。

#### clear_datatable

clear_datatable函数用来清除数据表组件的当前数据。

	clear_datatable(self, table_name)
	table_name：数据表的wo_name

set_output_datatable的数据相当于是append到现有数据中的，而当需要反复向某数据表输出数据时，就有两种：

1、将新增数据，放入一个数据，然后set_output_datatable新增数据的数组

2、将新增数据直接添加进表数据，然后清空数据表，然后set_output_datatable整组表数据

为支持后一种操作，jxWebUI提供了clear_datatable函数，该函数会清空数据表的当前数据。

#### set_output_chart

set_output_chart函数用来向图表发送数据

	set_output_chart(self, chart_name, labels:list, *values_list)
	labels：折线图的横坐标数据
	values_list：折线图每个横坐标各点的值
	如：
	ls = []
	#两组数据
    v1 = []
    v2 = []
    for d in range(100):
        ls.append(d)
        v1.append(random.randint(10, 100))
        v2.append(random.randint(10, 100))

    capa_instance.set_output_chart('data_chart', ls, v1, v2)
    显示的效果为：


![hello_world](http://115.29.52.95:10018/images/bc_2.png)


本质上，capa_instance提供的IO函数就三个：弹窗、输入、输出【setIAttr】。setOutput、set_output_datatable、set_output_chart都是setIAttr的针对性简写。

## 变量-数据对象属性映射

0.2.3版本中增加了三个功能：

1、增加capa的Init事件，在capa初始化时会调用该事件：

	@capa.cmd
	def Init(capa, db):
	    #capa的初始化事件
        #可以在这里执行变量-数据对象属性映射的添加工作

2、增加变量-数据对象属性映射，大幅度简单数据对象的输入输出工作

业务系统中，增伤改查的操作非常多，而增加、修改等工作首先需要显示数据对象中的值，然后修改后保存。这就需要大量的【从数据对象读取、然后显示到web界面】以及【从web界面读取、然后设置到数据对象】的工作。

随着业务的复杂化，这类工作极其繁多，而且还需要非常细心，加重了程序员的工作量。

针对这个问题，jxWebUI提供了【变量-数据对象属性映射】能力，以简化程序员的工作。

3、增加了capa.data以提供整个capa的全局性数据。这包括两个操作：

第一步，可以在capa的Init事件中，设置全局数据：

	@capa.cmd
	def Init(capa, db):
	    capa.set('变量名', 变量值)

第二步，可以在页面事件响应函数中，操作全局数据：

	@capa.cmd
	def test_web(ci, db, ctx):
	    dv = ci.get_capa_data('变量名')
	    dv = ci.set_capa_data('变量名', 变量值)
    

### 使用变量-数据对象属性映射

变量-数据对象属性映射其实就是定义好web变量和数据对象属性的映射关系，然后自动化完成web显示/输入与数据对象属性的读取/写入工作。

所以其主要包括三个部分：

1、映射，通过执行add_mapping函数来添加映射关系：

    add_mapping(self, bind_name, attr, data_name=None, base64=False, table_data=False)
    #bind_name：在定义web界面的输入输出控件时bind的变量名
    #attr：数据类的属性名，也是数据表中的列名，参见jxORM中的相关说明
    #data_name：如果数据是保存在数据对象的json类型的属性中时，需给出相应的key
    #base64：web界面的输入输出控件需采用base64编码
    #table_data：web界面的输入输出控件是数据表

在capa的Init事件中，添加映射关系：

	@capa.cmd
	def Init(capa, db):
	    capa.add_mapping(...)
	    capa.add_mapping(...)
	    capa.add_mapping(...)

2、从数据对象读取数据并输出到web界面：

    disp_bind_data(self, orm_obj, bind_name)
    #orm_obj：获取到的数据对象
    #bind_name：在定义web界面的输入输出控件时bind的变量名

在page的disp事件中，获取到数据对象后，将需要的数据显示到web界面：

	@capa.disp
	def test_web(ci, db, ctx):
        id = ci.getInput('xxx_id')
        #如何获取数据对象，请参考jxORM的编程指南
        orm_obj = 某数据类.GetByID(db, id)
        #从orm_obj的相应属性中读取数据，并显示到绑定了user_name的web组件中
	    ci.disp_bind_data(orm_obj, 'user_name')
	    ci.disp_bind_data(orm_obj, 'user_state')
        ...

如果不需要一个组件一个组件的细微控制，还可以一次性显示所有的数据对象属性：

	@capa.disp
	def test_web(ci, db, ctx):
        id = ci.getInput('xxx_id')
        #如何获取数据对象，请参考jxORM的编程指南
        orm_obj = 某数据类.GetByID(db, id)
        ci.disp_bind_data_all(orm_obj)

3、从web界面的输入控件中读取数据，写入到数据对象中：

    read_bind_data(self, orm_obj, bind_name)
    #orm_obj：获取到的数据对象
    #bind_name：在定义web界面的输入输出控件时bind的变量名

在page某确认这样的按钮点击事件中，从web界面的输入控件中读取数据，写入到数据对象中：

	@capa.cmd
	def test_web(ci, db, ctx):
        id = ci.getInput('xxx_id')
        #如何获取数据对象，请参考jxORM的编程指南
        orm_obj = 某数据类.GetByID(db, id)
        #从绑定了user_name的web组件中读取数据并写入到orm_obj的相应属性中
	    ci.read_bind_data(orm_obj, 'user_name')
	    ci.read_bind_data(orm_obj, 'user_state')
        ...
        #保存修改后的数据对象
        orm_obj.update(db)

如果不需要一个组件一个组件的细微控制，还可以一次性写入所有的数据对象属性：

	@capa.cmd
	def test_web(ci, db, ctx):
        id = ci.getInput('xxx_id')
        #如何获取数据对象，请参考jxORM的编程指南
        orm_obj = 某数据类.GetByID(db, id)
        ci.read_bind_data_all(db, orm_obj)

<font color=red size=3>注：</font>disp_bind_data_all和read_bind_data_all会对在capa.Init事件中添加的所有映射关系进行读取/写入操作，但如果数据对象中没有相应的属性，则会忽略该属性的读取与写入，不会有其它动作

## 打开页面

定义好的页面该如何打开呢？

jxWebUI将打开页面的操作称为**入口**。jxWebUI中有四种入口：

1、快捷栏目录

jxWebUI只有一个html文件:tms.html，显示的所有内容都是在其中动态创建的。这个html主要分为了两大块：左侧的快捷栏，中间的主显示区。

快捷栏采用二级目录的方式进行组织，在用户登录成功后根据用户权限一次性的生成。

主显示区为一个tabs组件，可以同时容纳5个tab，用户通过web、page修饰符定义的界面都显示到tab中。

当用户打开的界面超过5个后，按最久未访问顺序进行卸载。

通过web、page修饰符定义的主页面，可通过capa.shortCutTree_add_item添加到快捷栏中。

用户登录后，会按照用户的abbr、roles中指定的所有role、还有公共功能组合成该用户的快捷栏，以此实现了用户权限管理。

2、用户按钮

在web、page中定义的按钮。这样的按钮在page显示时随web界面的显示而显示。用户点击该按钮，根据定义可以执行：创建一个新的page显示到新的tab中，在本tab中弹窗显示一个对话框page，执行一个cmd事件。

3、数据表中的用户按钮

在数据表的列中定义的工具条。这样的工具条会随着送入的数据每一行都出现。其功能和用户按钮是一样的，但因为每行数据不同，所以需要准确定位是哪一行的按钮被点击了。

4、工具栏中的工具条

在每个tab的最上端有一个工具栏。用来放置本page所管理的所有工具条。

工具条的功能和用户按钮一样。区别在于：用户按钮是定义在page中的，随page的出现一起出现；而工具条则是独立于page的定义，可以进行更细致的权限控制。

如查看用户，只有admin、hr等可以修改用户信息，甚至，不同部门的用户修改的还是不同部分的信息。

## 结语

所以，j使用xWebUI的编程非常简单：

1、定义web界面

2、用IO函数直接访问web控件
  
### 查看jxWebUI编程手册
  
请在python解释器中执行：  
  
    >>> from jxWebUI import startJxWebUIManualServer
	>>> startJxWebUIManualServer(port=10068, web_def=True)
	
然后在浏览器中打开： http://127.0.0.1:10068/tms.html# 随便输入用户名、密码登录后，就可以查看到编程手册的目录：  
  
![编程手册](http://115.29.52.95:10018/images/sc_1.png)  
  
【整体说明】菜单下是jxWebUI编程的总体概念和API说明等，【web组件说明】菜单下则详细介绍了已开放的web组件的说明和属性等。点击这二菜单下二级章节会以markdown的形式提供相应的说明：  
  
![编程手册](http://115.29.52.95:10018/images/sc_2.png)  
  
【web组件定义】菜单下则提供了一个jxWebUI自举的web组件定义和展示功能：  
  
![编程手册](http://115.29.52.95:10018/images/sc_3.png)  

填写了相应的属性后，点击【生成】按钮就是自动完成相应控件的定义；生成后再点击【查看效果】按钮则可以在弹出的对话框中查看到效果。

<font color=red size=3>注：</font>请注意仔细理解各控件width属性的说明

![编程手册](http://115.29.52.95:10018/images/sc_4.png)