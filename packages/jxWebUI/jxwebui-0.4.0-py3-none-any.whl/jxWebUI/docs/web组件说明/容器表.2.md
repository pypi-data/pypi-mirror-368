jxWebUI使用表格来进行各控件的行列对齐，这种单纯为了容纳其它web组件来进行行列对齐的表称为容器表。

## 定义

容器表的定义格式为：

	t = page.table(表名).属性1(属性1值).属性2(属性2值)...

<font color=red size=3>注：</font>表名在不需要操作表时可省略，容器表一般均可省略表名

容器表当然添加行，然后在行中添加各列的组件，各行的组件按添加次序进行列对齐。如：

	t = page.table().width(900).title('查询条件')
	r = t.row()
	r.text().width(200).text('设备类型')
	r.input().width(200).bind('devType')
	r = t.row()
	r.text().width(200).text('设备名')
	r.input().width(200).bind('devName')
	r = t.row()
	r.button().width(200).text('查询').motion('cmd').demand('reSearch')

定义的就是下图中的查询条件表，有三行，第一行是一个设备类型的文本和一个输入框，第二行是一个设备名的文本和一个输入框，第三行是一个查询按钮。

![test_web](http://115.29.52.95:10018/images/dt_1.png)


## 属性

### title
类型：string
缺省值：

表的标题，位于表头的左侧。

### header
类型：bool
缺省值：true

是否显示表头。表头包括：标题【左侧】、添加新行的按钮【右侧】。

<font color=red size=3>注：</font>如果你是通过startJxWebUIManualServer方式在查看jxWebUI自带的编程手册，那么你现在正在看的页面就是没有表头的显示效果。

### width
类型：int
缺省值：

表的宽度。表宽是绝对宽度，单位像素。

### alone
类型：bool
缺省值：false

每一行是否独立。

我们反复说了，容器表是用来行列对齐的。但有的表会非常复杂，某一个控件要求的宽度可能会非常宽，不能和其它控件进行列对齐。

但这种情况下如果拆分成两个表的话，又可能会破坏界面表达的逻辑性。

针对这种情况，jxWebUI提供了alone属性。定义了alone=true的容器表，每一行都是独立的，只根据本行所有控件的width数值进行布局。这样就可以灵活的定义各个控件的宽度了。

<font color=red size=3>注1：</font>当定义了alone=true后，如果某两行中各控件的宽度定义都是一致的，那么这两行看上去的效果还是对齐的

<font color=red size=3>注2：</font>当定义了alone=true后，如果某一行中只定义了一个控件，拿这个控件就会占据整行

下图就是同样的控件布局，未设置alone和设置了alone=true的显示效果对比：

![hello_world](http://115.29.52.95:10018/images/rqb_1.png)

# 示例
    
    #编程方式在capa中定义一个名为test_web的page
    @capa.web
    def test_web(page):
        #在page中添加一个容器表，宽900像素，标题是查询条件
        t = page.table().width(900).title('查询条件')
        #在表中添加第一行
        r = t.row()
        #在表的第一行先添加一个提示词：设备类型
        r.text().text('设备类型').width(200)
        #在表的第一行再添加一个输入框，在输入框中所输入将映射给变量devType
        #然后就可以在事件函数中用ci.getInput('devType')获取到用户在该输入框中的输入了
        r.input().bind('devType').width(200)
        #在表中添加第二行
        r = t.row()
        #第二行是一个提示词和一个绑定到变量devName的输入框
        r.text().text('设备名').width(200)
        r.input().bind('devName').width(200)
        #在表中添加第三行
        r = t.row()
        #第三行是一个按钮，点击该按钮将触发reSearch命令事件，该事件被jxWebUI接管，用于条件查询
        r.button().text('查询').width(100).motion('cmd').demand('reSearch')

    #如果定义了disp修饰的同名函数，则在显示page时，会调用本函数来执行页面初始化工作
    @capa.disp
    def test_web(ci, db, ctx):
        #在logs/jxWebUI.log中显示一行日志信息
        jxWebLogger.info(f'testUI_tms::test_web')
        #在浏览器中弹出一个弹窗消息
        ci.web_info('提示', '提示信息')
        #在绑定了变量名的输入输出控件中显示一个输出信息
        ci.setOutput('devName', '预置的设备名')


容器表当然添加行，然后在行中添加各列的组件，各行的组件按添加次序进行列对齐。如：

	t = page.table().width(900).title('查询条件')
	r = t.row()
	r.text().width(200).text('设备类型')
	r.input().width(200).bind('devType')
	r = t.row()
	r.text().width(200).text('设备名')
	r.input().width(200).bind('devName')
	r = t.row()
	r.button().width(200).text('查询').motion('cmd').demand('reSearch')

定义的就是下图中的查询条件表，有三行，第一行是一个设备类型的文本和一个输入框，第二行是一个设备名的文本和一个输入框，第三行是一个查询按钮。

![test_web](http://115.29.52.95:10018/images/dt_1.png)


## 属性

### title
类型：string
缺省值：

表的标题，位于表头的左侧。

### header
类型：bool
缺省值：true

是否显示表头。表头包括：标题【左侧】、添加新行的按钮【右侧】。

<font color=red size=3>注：</font>如果你是通过startJxWebUIManualServer方式在查看jxWebUI自带的编程手册，那么你现在正在看的页面就是没有表头的显示效果。

### width
类型：int
缺省值：

表的宽度。表宽是绝对宽度，单位像素。

### alone
类型：bool
缺省值：false

每一行是否独立。

我们反复说了，容器表是用来行列对齐的。但有的表会非常复杂，某一个控件要求的宽度可能会非常宽，不能和其它控件进行列对齐。

但这种情况下如果拆分成两个表的话，又可能会破坏界面表达的逻辑性。

针对这种情况，jxWebUI提供了alone属性。定义了alone=true的容器表，每一行都是独立的，只根据本行所有控件的width数值进行布局。这样就可以灵活的定义各个控件的宽度了。

<font color=red size=3>注1：</font>当定义了alone=true后，如果某两行中各控件的宽度定义都是一致的，那么这两行看上去的效果还是对齐的

<font color=red size=3>注2：</font>当定义了alone=true后，如果某一行中只定义了一个控件，拿这个控件就会占据整行

下图就是同样的控件布局，未设置alone和设置了alone=true的显示效果对比：

![hello_world](http://115.29.52.95:10018/images/rqb_1.png)

# 示例
    
    #编程方式在capa中定义一个名为test_web的page
    @capa.web
    def test_web(page):
        #在page中添加一个容器表，宽900像素，标题是查询条件
        t = page.table().width(900).title('查询条件')
        #在表中添加第一行
        r = t.row()
        #在表的第一行先添加一个提示词：设备类型
        r.text().text('设备类型').width(200)
        #在表的第一行再添加一个输入框，在输入框中所输入将映射给变量devType
        #然后就可以在事件函数中用ci.getInput('devType')获取到用户在该输入框中的输入了
        r.input().bind('devType').width(200)
        #在表中添加第二行
        r = t.row()
        #第二行是一个提示词和一个绑定到变量devName的输入框
        r.text().text('设备名').width(200)
        r.input().bind('devName').width(200)
        #在表中添加第三行
        r = t.row()
        #第三行是一个按钮，点击该按钮将触发reSearch命令事件，该事件被jxWebUI接管，用于条件查询
        r.button().text('查询').width(100).motion('cmd').demand('reSearch')

    #如果定义了disp修饰的同名函数，则在显示page时，会调用本函数来执行页面初始化工作
    @capa.disp
    def test_web(ci, db, ctx):
        #在logs/jxWebUI.log中显示一行日志信息
        jxWebLogger.info(f'testUI_tms::test_web')
        #在浏览器中弹出一个弹窗消息
        ci.web_info('提示', '提示信息')
        #在绑定了变量名的输入输出控件中显示一个输出信息
        ci.setOutput('devName', '预置的设备名')

