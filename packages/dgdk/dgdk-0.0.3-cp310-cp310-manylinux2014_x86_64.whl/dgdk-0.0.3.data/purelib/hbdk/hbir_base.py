# This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info < (2, 7, 0):
    raise RuntimeError("Python 2.7 or later required")

# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _hbir_base
else:
    import _hbir_base

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "thisown":
            self.this.own(value)
        elif name == "this":
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class SwigPyIterator(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")

    def __init__(self, *args, **kwargs):
        raise AttributeError("No constructor defined - class is abstract")
    __repr__ = _swig_repr
    __swig_destroy__ = _hbir_base.delete_SwigPyIterator

    def value(self):
        return _hbir_base.SwigPyIterator_value(self)

    def incr(self, n=1):
        return _hbir_base.SwigPyIterator_incr(self, n)

    def decr(self, n=1):
        return _hbir_base.SwigPyIterator_decr(self, n)

    def distance(self, x):
        return _hbir_base.SwigPyIterator_distance(self, x)

    def equal(self, x):
        return _hbir_base.SwigPyIterator_equal(self, x)

    def copy(self):
        return _hbir_base.SwigPyIterator_copy(self)

    def next(self):
        return _hbir_base.SwigPyIterator_next(self)

    def __next__(self):
        return _hbir_base.SwigPyIterator___next__(self)

    def previous(self):
        return _hbir_base.SwigPyIterator_previous(self)

    def advance(self, n):
        return _hbir_base.SwigPyIterator_advance(self, n)

    def __eq__(self, x):
        return _hbir_base.SwigPyIterator___eq__(self, x)

    def __ne__(self, x):
        return _hbir_base.SwigPyIterator___ne__(self, x)

    def __iadd__(self, n):
        return _hbir_base.SwigPyIterator___iadd__(self, n)

    def __isub__(self, n):
        return _hbir_base.SwigPyIterator___isub__(self, n)

    def __add__(self, n):
        return _hbir_base.SwigPyIterator___add__(self, n)

    def __sub__(self, *args):
        return _hbir_base.SwigPyIterator___sub__(self, *args)
    def __iter__(self):
        return self

# Register SwigPyIterator in _hbir_base:
_hbir_base.SwigPyIterator_swigregister(SwigPyIterator)

class StringVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.StringVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.StringVector___nonzero__(self)

    def __bool__(self):
        return _hbir_base.StringVector___bool__(self)

    def __len__(self):
        return _hbir_base.StringVector___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.StringVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.StringVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.StringVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.StringVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.StringVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.StringVector___setitem__(self, *args)

    def pop(self):
        return _hbir_base.StringVector_pop(self)

    def append(self, x):
        return _hbir_base.StringVector_append(self, x)

    def empty(self):
        return _hbir_base.StringVector_empty(self)

    def size(self):
        return _hbir_base.StringVector_size(self)

    def swap(self, v):
        return _hbir_base.StringVector_swap(self, v)

    def begin(self):
        return _hbir_base.StringVector_begin(self)

    def end(self):
        return _hbir_base.StringVector_end(self)

    def rbegin(self):
        return _hbir_base.StringVector_rbegin(self)

    def rend(self):
        return _hbir_base.StringVector_rend(self)

    def clear(self):
        return _hbir_base.StringVector_clear(self)

    def get_allocator(self):
        return _hbir_base.StringVector_get_allocator(self)

    def pop_back(self):
        return _hbir_base.StringVector_pop_back(self)

    def erase(self, *args):
        return _hbir_base.StringVector_erase(self, *args)

    def __init__(self, *args):
        _hbir_base.StringVector_swiginit(self, _hbir_base.new_StringVector(*args))

    def push_back(self, x):
        return _hbir_base.StringVector_push_back(self, x)

    def front(self):
        return _hbir_base.StringVector_front(self)

    def back(self):
        return _hbir_base.StringVector_back(self)

    def assign(self, n, x):
        return _hbir_base.StringVector_assign(self, n, x)

    def resize(self, *args):
        return _hbir_base.StringVector_resize(self, *args)

    def insert(self, *args):
        return _hbir_base.StringVector_insert(self, *args)

    def reserve(self, n):
        return _hbir_base.StringVector_reserve(self, n)

    def capacity(self):
        return _hbir_base.StringVector_capacity(self)
    __swig_destroy__ = _hbir_base.delete_StringVector

# Register StringVector in _hbir_base:
_hbir_base.StringVector_swigregister(StringVector)

class FloatVector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.FloatVector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.FloatVector___nonzero__(self)

    def __bool__(self):
        return _hbir_base.FloatVector___bool__(self)

    def __len__(self):
        return _hbir_base.FloatVector___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.FloatVector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.FloatVector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.FloatVector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.FloatVector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.FloatVector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.FloatVector___setitem__(self, *args)

    def pop(self):
        return _hbir_base.FloatVector_pop(self)

    def append(self, x):
        return _hbir_base.FloatVector_append(self, x)

    def empty(self):
        return _hbir_base.FloatVector_empty(self)

    def size(self):
        return _hbir_base.FloatVector_size(self)

    def swap(self, v):
        return _hbir_base.FloatVector_swap(self, v)

    def begin(self):
        return _hbir_base.FloatVector_begin(self)

    def end(self):
        return _hbir_base.FloatVector_end(self)

    def rbegin(self):
        return _hbir_base.FloatVector_rbegin(self)

    def rend(self):
        return _hbir_base.FloatVector_rend(self)

    def clear(self):
        return _hbir_base.FloatVector_clear(self)

    def get_allocator(self):
        return _hbir_base.FloatVector_get_allocator(self)

    def pop_back(self):
        return _hbir_base.FloatVector_pop_back(self)

    def erase(self, *args):
        return _hbir_base.FloatVector_erase(self, *args)

    def __init__(self, *args):
        _hbir_base.FloatVector_swiginit(self, _hbir_base.new_FloatVector(*args))

    def push_back(self, x):
        return _hbir_base.FloatVector_push_back(self, x)

    def front(self):
        return _hbir_base.FloatVector_front(self)

    def back(self):
        return _hbir_base.FloatVector_back(self)

    def assign(self, n, x):
        return _hbir_base.FloatVector_assign(self, n, x)

    def resize(self, *args):
        return _hbir_base.FloatVector_resize(self, *args)

    def insert(self, *args):
        return _hbir_base.FloatVector_insert(self, *args)

    def reserve(self, n):
        return _hbir_base.FloatVector_reserve(self, n)

    def capacity(self):
        return _hbir_base.FloatVector_capacity(self)
    __swig_destroy__ = _hbir_base.delete_FloatVector

# Register FloatVector in _hbir_base:
_hbir_base.FloatVector_swigregister(FloatVector)

class Int32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.Int32Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.Int32Vector___nonzero__(self)

    def __bool__(self):
        return _hbir_base.Int32Vector___bool__(self)

    def __len__(self):
        return _hbir_base.Int32Vector___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.Int32Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.Int32Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.Int32Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.Int32Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.Int32Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.Int32Vector___setitem__(self, *args)

    def pop(self):
        return _hbir_base.Int32Vector_pop(self)

    def append(self, x):
        return _hbir_base.Int32Vector_append(self, x)

    def empty(self):
        return _hbir_base.Int32Vector_empty(self)

    def size(self):
        return _hbir_base.Int32Vector_size(self)

    def swap(self, v):
        return _hbir_base.Int32Vector_swap(self, v)

    def begin(self):
        return _hbir_base.Int32Vector_begin(self)

    def end(self):
        return _hbir_base.Int32Vector_end(self)

    def rbegin(self):
        return _hbir_base.Int32Vector_rbegin(self)

    def rend(self):
        return _hbir_base.Int32Vector_rend(self)

    def clear(self):
        return _hbir_base.Int32Vector_clear(self)

    def get_allocator(self):
        return _hbir_base.Int32Vector_get_allocator(self)

    def pop_back(self):
        return _hbir_base.Int32Vector_pop_back(self)

    def erase(self, *args):
        return _hbir_base.Int32Vector_erase(self, *args)

    def __init__(self, *args):
        _hbir_base.Int32Vector_swiginit(self, _hbir_base.new_Int32Vector(*args))

    def push_back(self, x):
        return _hbir_base.Int32Vector_push_back(self, x)

    def front(self):
        return _hbir_base.Int32Vector_front(self)

    def back(self):
        return _hbir_base.Int32Vector_back(self)

    def assign(self, n, x):
        return _hbir_base.Int32Vector_assign(self, n, x)

    def resize(self, *args):
        return _hbir_base.Int32Vector_resize(self, *args)

    def insert(self, *args):
        return _hbir_base.Int32Vector_insert(self, *args)

    def reserve(self, n):
        return _hbir_base.Int32Vector_reserve(self, n)

    def capacity(self):
        return _hbir_base.Int32Vector_capacity(self)
    __swig_destroy__ = _hbir_base.delete_Int32Vector

# Register Int32Vector in _hbir_base:
_hbir_base.Int32Vector_swigregister(Int32Vector)

class UInt32Vector(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.UInt32Vector_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.UInt32Vector___nonzero__(self)

    def __bool__(self):
        return _hbir_base.UInt32Vector___bool__(self)

    def __len__(self):
        return _hbir_base.UInt32Vector___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.UInt32Vector___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.UInt32Vector___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.UInt32Vector___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.UInt32Vector___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.UInt32Vector___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.UInt32Vector___setitem__(self, *args)

    def pop(self):
        return _hbir_base.UInt32Vector_pop(self)

    def append(self, x):
        return _hbir_base.UInt32Vector_append(self, x)

    def empty(self):
        return _hbir_base.UInt32Vector_empty(self)

    def size(self):
        return _hbir_base.UInt32Vector_size(self)

    def swap(self, v):
        return _hbir_base.UInt32Vector_swap(self, v)

    def begin(self):
        return _hbir_base.UInt32Vector_begin(self)

    def end(self):
        return _hbir_base.UInt32Vector_end(self)

    def rbegin(self):
        return _hbir_base.UInt32Vector_rbegin(self)

    def rend(self):
        return _hbir_base.UInt32Vector_rend(self)

    def clear(self):
        return _hbir_base.UInt32Vector_clear(self)

    def get_allocator(self):
        return _hbir_base.UInt32Vector_get_allocator(self)

    def pop_back(self):
        return _hbir_base.UInt32Vector_pop_back(self)

    def erase(self, *args):
        return _hbir_base.UInt32Vector_erase(self, *args)

    def __init__(self, *args):
        _hbir_base.UInt32Vector_swiginit(self, _hbir_base.new_UInt32Vector(*args))

    def push_back(self, x):
        return _hbir_base.UInt32Vector_push_back(self, x)

    def front(self):
        return _hbir_base.UInt32Vector_front(self)

    def back(self):
        return _hbir_base.UInt32Vector_back(self)

    def assign(self, n, x):
        return _hbir_base.UInt32Vector_assign(self, n, x)

    def resize(self, *args):
        return _hbir_base.UInt32Vector_resize(self, *args)

    def insert(self, *args):
        return _hbir_base.UInt32Vector_insert(self, *args)

    def reserve(self, n):
        return _hbir_base.UInt32Vector_reserve(self, n)

    def capacity(self):
        return _hbir_base.UInt32Vector_capacity(self)
    __swig_destroy__ = _hbir_base.delete_UInt32Vector

# Register UInt32Vector in _hbir_base:
_hbir_base.UInt32Vector_swigregister(UInt32Vector)

class Int16Array64(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.Int16Array64_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.Int16Array64___nonzero__(self)

    def __bool__(self):
        return _hbir_base.Int16Array64___bool__(self)

    def __len__(self):
        return _hbir_base.Int16Array64___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.Int16Array64___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.Int16Array64___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.Int16Array64___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.Int16Array64___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.Int16Array64___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.Int16Array64___setitem__(self, *args)

    def __init__(self, *args):
        _hbir_base.Int16Array64_swiginit(self, _hbir_base.new_Int16Array64(*args))

    def empty(self):
        return _hbir_base.Int16Array64_empty(self)

    def size(self):
        return _hbir_base.Int16Array64_size(self)

    def swap(self, v):
        return _hbir_base.Int16Array64_swap(self, v)

    def begin(self):
        return _hbir_base.Int16Array64_begin(self)

    def end(self):
        return _hbir_base.Int16Array64_end(self)

    def rbegin(self):
        return _hbir_base.Int16Array64_rbegin(self)

    def rend(self):
        return _hbir_base.Int16Array64_rend(self)

    def front(self):
        return _hbir_base.Int16Array64_front(self)

    def back(self):
        return _hbir_base.Int16Array64_back(self)

    def fill(self, u):
        return _hbir_base.Int16Array64_fill(self, u)
    __swig_destroy__ = _hbir_base.delete_Int16Array64

# Register Int16Array64 in _hbir_base:
_hbir_base.Int16Array64_swigregister(Int16Array64)

class Int32Array256(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.Int32Array256_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.Int32Array256___nonzero__(self)

    def __bool__(self):
        return _hbir_base.Int32Array256___bool__(self)

    def __len__(self):
        return _hbir_base.Int32Array256___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.Int32Array256___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.Int32Array256___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.Int32Array256___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.Int32Array256___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.Int32Array256___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.Int32Array256___setitem__(self, *args)

    def __init__(self, *args):
        _hbir_base.Int32Array256_swiginit(self, _hbir_base.new_Int32Array256(*args))

    def empty(self):
        return _hbir_base.Int32Array256_empty(self)

    def size(self):
        return _hbir_base.Int32Array256_size(self)

    def swap(self, v):
        return _hbir_base.Int32Array256_swap(self, v)

    def begin(self):
        return _hbir_base.Int32Array256_begin(self)

    def end(self):
        return _hbir_base.Int32Array256_end(self)

    def rbegin(self):
        return _hbir_base.Int32Array256_rbegin(self)

    def rend(self):
        return _hbir_base.Int32Array256_rend(self)

    def front(self):
        return _hbir_base.Int32Array256_front(self)

    def back(self):
        return _hbir_base.Int32Array256_back(self)

    def fill(self, u):
        return _hbir_base.Int32Array256_fill(self, u)
    __swig_destroy__ = _hbir_base.delete_Int32Array256

# Register Int32Array256 in _hbir_base:
_hbir_base.Int32Array256_swigregister(Int32Array256)

class Lut2TableValue(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.Lut2TableValue_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.Lut2TableValue___nonzero__(self)

    def __bool__(self):
        return _hbir_base.Lut2TableValue___bool__(self)

    def __len__(self):
        return _hbir_base.Lut2TableValue___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.Lut2TableValue___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.Lut2TableValue___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.Lut2TableValue___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.Lut2TableValue___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.Lut2TableValue___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.Lut2TableValue___setitem__(self, *args)

    def __init__(self, *args):
        _hbir_base.Lut2TableValue_swiginit(self, _hbir_base.new_Lut2TableValue(*args))

    def empty(self):
        return _hbir_base.Lut2TableValue_empty(self)

    def size(self):
        return _hbir_base.Lut2TableValue_size(self)

    def swap(self, v):
        return _hbir_base.Lut2TableValue_swap(self, v)

    def begin(self):
        return _hbir_base.Lut2TableValue_begin(self)

    def end(self):
        return _hbir_base.Lut2TableValue_end(self)

    def rbegin(self):
        return _hbir_base.Lut2TableValue_rbegin(self)

    def rend(self):
        return _hbir_base.Lut2TableValue_rend(self)

    def front(self):
        return _hbir_base.Lut2TableValue_front(self)

    def back(self):
        return _hbir_base.Lut2TableValue_back(self)

    def fill(self, u):
        return _hbir_base.Lut2TableValue_fill(self, u)
    __swig_destroy__ = _hbir_base.delete_Lut2TableValue

# Register Lut2TableValue in _hbir_base:
_hbir_base.Lut2TableValue_swigregister(Lut2TableValue)

class Lut2TableRange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.Lut2TableRange_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.Lut2TableRange___nonzero__(self)

    def __bool__(self):
        return _hbir_base.Lut2TableRange___bool__(self)

    def __len__(self):
        return _hbir_base.Lut2TableRange___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.Lut2TableRange___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.Lut2TableRange___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.Lut2TableRange___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.Lut2TableRange___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.Lut2TableRange___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.Lut2TableRange___setitem__(self, *args)

    def __init__(self, *args):
        _hbir_base.Lut2TableRange_swiginit(self, _hbir_base.new_Lut2TableRange(*args))

    def empty(self):
        return _hbir_base.Lut2TableRange_empty(self)

    def size(self):
        return _hbir_base.Lut2TableRange_size(self)

    def swap(self, v):
        return _hbir_base.Lut2TableRange_swap(self, v)

    def begin(self):
        return _hbir_base.Lut2TableRange_begin(self)

    def end(self):
        return _hbir_base.Lut2TableRange_end(self)

    def rbegin(self):
        return _hbir_base.Lut2TableRange_rbegin(self)

    def rend(self):
        return _hbir_base.Lut2TableRange_rend(self)

    def front(self):
        return _hbir_base.Lut2TableRange_front(self)

    def back(self):
        return _hbir_base.Lut2TableRange_back(self)

    def fill(self, u):
        return _hbir_base.Lut2TableRange_fill(self, u)
    __swig_destroy__ = _hbir_base.delete_Lut2TableRange

# Register Lut2TableRange in _hbir_base:
_hbir_base.Lut2TableRange_swigregister(Lut2TableRange)

class LutTableRange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def iterator(self):
        return _hbir_base.LutTableRange_iterator(self)
    def __iter__(self):
        return self.iterator()

    def __nonzero__(self):
        return _hbir_base.LutTableRange___nonzero__(self)

    def __bool__(self):
        return _hbir_base.LutTableRange___bool__(self)

    def __len__(self):
        return _hbir_base.LutTableRange___len__(self)

    def __getslice__(self, i, j):
        return _hbir_base.LutTableRange___getslice__(self, i, j)

    def __setslice__(self, *args):
        return _hbir_base.LutTableRange___setslice__(self, *args)

    def __delslice__(self, i, j):
        return _hbir_base.LutTableRange___delslice__(self, i, j)

    def __delitem__(self, *args):
        return _hbir_base.LutTableRange___delitem__(self, *args)

    def __getitem__(self, *args):
        return _hbir_base.LutTableRange___getitem__(self, *args)

    def __setitem__(self, *args):
        return _hbir_base.LutTableRange___setitem__(self, *args)

    def __init__(self, *args):
        _hbir_base.LutTableRange_swiginit(self, _hbir_base.new_LutTableRange(*args))

    def empty(self):
        return _hbir_base.LutTableRange_empty(self)

    def size(self):
        return _hbir_base.LutTableRange_size(self)

    def swap(self, v):
        return _hbir_base.LutTableRange_swap(self, v)

    def begin(self):
        return _hbir_base.LutTableRange_begin(self)

    def end(self):
        return _hbir_base.LutTableRange_end(self)

    def rbegin(self):
        return _hbir_base.LutTableRange_rbegin(self)

    def rend(self):
        return _hbir_base.LutTableRange_rend(self)

    def front(self):
        return _hbir_base.LutTableRange_front(self)

    def back(self):
        return _hbir_base.LutTableRange_back(self)

    def fill(self, u):
        return _hbir_base.LutTableRange_fill(self, u)
    __swig_destroy__ = _hbir_base.delete_LutTableRange

# Register LutTableRange in _hbir_base:
_hbir_base.LutTableRange_swigregister(LutTableRange)

class Tensor(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, tensor_name):
        _hbir_base.Tensor_swiginit(self, _hbir_base.new_Tensor(tensor_name))
    data = property(_hbir_base.Tensor_data_get, _hbir_base.Tensor_data_set)
    float_data = property(_hbir_base.Tensor_float_data_get, _hbir_base.Tensor_float_data_set)
    shift = property(_hbir_base.Tensor_shift_get, _hbir_base.Tensor_shift_set)
    shape = property(_hbir_base.Tensor_shape_get, _hbir_base.Tensor_shape_set)
    scale = property(_hbir_base.Tensor_scale_get, _hbir_base.Tensor_scale_set)
    dtype = property(_hbir_base.Tensor_dtype_get, _hbir_base.Tensor_dtype_set)
    name = property(_hbir_base.Tensor_name_get, _hbir_base.Tensor_name_set)
    is_literal = property(_hbir_base.Tensor_is_literal_get, _hbir_base.Tensor_is_literal_set)

    def sync_to_hbir(self):
        return _hbir_base.Tensor_sync_to_hbir(self)
    __swig_destroy__ = _hbir_base.delete_Tensor

# Register Tensor in _hbir_base:
_hbir_base.Tensor_swigregister(Tensor)

class Layer(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, layer_name):
        _hbir_base.Layer_swiginit(self, _hbir_base.new_Layer(layer_name))
    name = property(_hbir_base.Layer_name_get, _hbir_base.Layer_name_set)
    type = property(_hbir_base.Layer_type_get, _hbir_base.Layer_type_set)
    inputs = property(_hbir_base.Layer_inputs_get, _hbir_base.Layer_inputs_set)
    outputs = property(_hbir_base.Layer_outputs_get, _hbir_base.Layer_outputs_set)

    def sync_to_hbir(self):
        return _hbir_base.Layer_sync_to_hbir(self)
    __swig_destroy__ = _hbir_base.delete_Layer

# Register Layer in _hbir_base:
_hbir_base.Layer_swigregister(Layer)

class Model(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr

    def __init__(self, *args):
        _hbir_base.Model_swiginit(self, _hbir_base.new_Model(*args))

    def DeserializeFromFile(self, file_name):
        return _hbir_base.Model_DeserializeFromFile(self, file_name)

    def SerializeToFile(self, file_name, unregister=True):
        return _hbir_base.Model_SerializeToFile(self, file_name, unregister)

    def RestoreGraphToPython(self, python_file_name):
        return _hbir_base.Model_RestoreGraphToPython(self, python_file_name)

    def InitParam(self, march, fill_mode):
        return _hbir_base.Model_InitParam(self, march, fill_mode)

    def SparsifyConv(self):
        return _hbir_base.Model_SparsifyConv(self)

    @staticmethod
    def Tensor(tensor_name):
        return _hbir_base.Model_Tensor(tensor_name)

    @staticmethod
    def Layer(layer_name):
        return _hbir_base.Model_Layer(layer_name)

    def AddInputOutputOrderLayer(self, layer_name, input_tensor_name_list, output_tensor_name_list):
        return _hbir_base.Model_AddInputOutputOrderLayer(self, layer_name, input_tensor_name_list, output_tensor_name_list)

    def GetModelOutputTensorNames(self):
        return _hbir_base.Model_GetModelOutputTensorNames(self)
    layer_names = property(_hbir_base.Model_layer_names_get, _hbir_base.Model_layer_names_set)
    input_tensor_names = property(_hbir_base.Model_input_tensor_names_get, _hbir_base.Model_input_tensor_names_set)
    output_tensor_names = property(_hbir_base.Model_output_tensor_names_get, _hbir_base.Model_output_tensor_names_set)
    literal_tensor_names = property(_hbir_base.Model_literal_tensor_names_get, _hbir_base.Model_literal_tensor_names_set)
    intermediate_tensor_names = property(_hbir_base.Model_intermediate_tensor_names_get, _hbir_base.Model_intermediate_tensor_names_set)
    __swig_destroy__ = _hbir_base.delete_Model

# Register Model in _hbir_base:
_hbir_base.Model_swigregister(Model)

def Model_Tensor(tensor_name):
    return _hbir_base.Model_Tensor(tensor_name)

def Model_Layer(layer_name):
    return _hbir_base.Model_Layer(layer_name)


def SetSQuantiScope(v=True):
    return _hbir_base.SetSQuantiScope(v)

def CleanUpContext():
    return _hbir_base.CleanUpContext()

def CreateTensor(tensor_name, shape, element_type, data, shift, scale):
    return _hbir_base.CreateTensor(tensor_name, shape, element_type, data, shift, scale)

def CreateTensorf(tensor_name, shape, element_type, data, shift, scale):
    return _hbir_base.CreateTensorf(tensor_name, shape, element_type, data, shift, scale)

def GetTensorShape(tensor_name):
    return _hbir_base.GetTensorShape(tensor_name)

def GetTensorDtype(tensor_name):
    return _hbir_base.GetTensorDtype(tensor_name)

def GetTensorScale(tensor_name):
    return _hbir_base.GetTensorScale(tensor_name)

def GetTensorShift(tensor_name):
    return _hbir_base.GetTensorShift(tensor_name)

def IsModelInput(tensor_name):
    return _hbir_base.IsModelInput(tensor_name)

def IsLiteralTensor(tensor_name):
    return _hbir_base.IsLiteralTensor(tensor_name)

def SetTensorDataf(tensor_name, data):
    return _hbir_base.SetTensorDataf(tensor_name, data)

def SetTensorData(tensor_name, data):
    return _hbir_base.SetTensorData(tensor_name, data)

def SetTensorDtype(tensor_name, element_type):
    return _hbir_base.SetTensorDtype(tensor_name, element_type)

def SetTensorShape(tensor_name, shape):
    return _hbir_base.SetTensorShape(tensor_name, shape)

def SetTensorScale(tensor_name, scale):
    return _hbir_base.SetTensorScale(tensor_name, scale)

def SetTensorShift(tensor_name, shift):
    return _hbir_base.SetTensorShift(tensor_name, shift)

def CreateConvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, dilation, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_type, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding):
    return _hbir_base.CreateConvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, dilation, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_type, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding)

def CreateDeconvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, output_padding, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_type, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding):
    return _hbir_base.CreateDeconvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, output_padding, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_type, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding)

def CreateSConvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, dilation, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding, accu_right_shift, bias_left_shift, output_scale, output_right_shift, sumin_scale, sumin_left_shift):
    return _hbir_base.CreateSConvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, dilation, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding, accu_right_shift, bias_left_shift, output_scale, output_right_shift, sumin_scale, sumin_left_shift)

def CreateConv3dLayer(input_tensor_name, layer_name, kernel, stride, padding, dilation, num_filter, num_group, use_bias, use_relu, sumin_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, output_tensor_name, output_type, enable_rounding, bias_left_shift, output_scale, accu_right_shift, sumin_scale, sumin_left_shift, output_right_shift):
    return _hbir_base.CreateConv3dLayer(input_tensor_name, layer_name, kernel, stride, padding, dilation, num_filter, num_group, use_bias, use_relu, sumin_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, output_tensor_name, output_type, enable_rounding, bias_left_shift, output_scale, accu_right_shift, sumin_scale, sumin_left_shift, output_right_shift)

def CreateSDeconvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, output_padding, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding, accu_right_shift, bias_left_shift, output_scale, output_right_shift, sumin_scale, sumin_left_shift):
    return _hbir_base.CreateSDeconvolutionLayer(input_tensor_name, layer_name, num_filter, kernel, stride, padding, output_padding, num_group, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding, accu_right_shift, bias_left_shift, output_scale, output_right_shift, sumin_scale, sumin_left_shift)

def CreateMaxPoolingLayer(input_tensor_name, layer_name, kernel, stride, padding, ceil_mode, output_type, output_tensor_name, maxpool_pad_boundary=False, heatmap_mode=False):
    return _hbir_base.CreateMaxPoolingLayer(input_tensor_name, layer_name, kernel, stride, padding, ceil_mode, output_type, output_tensor_name, maxpool_pad_boundary, heatmap_mode)

def CreateAvgPoolingLayer(input_tensor_name, layer_name, kernel, stride, padding, ceil_mode, enable_rounding, output_type, output_tensor_name):
    return _hbir_base.CreateAvgPoolingLayer(input_tensor_name, layer_name, kernel, stride, padding, ceil_mode, enable_rounding, output_type, output_tensor_name)

def CreateSAvgPoolingLayer(input_tensor_name, layer_name, kernel, stride, padding, ceil_mode, enable_rounding, output_type, output_tensor_name, accu_right_shift, output_scale, output_right_shift):
    return _hbir_base.CreateSAvgPoolingLayer(input_tensor_name, layer_name, kernel, stride, padding, ceil_mode, enable_rounding, output_type, output_tensor_name, accu_right_shift, output_scale, output_right_shift)

def CreateGlobalMaxPoolingLayer(input_tensor_name, layer_name, output_type, output_tensor_name):
    return _hbir_base.CreateGlobalMaxPoolingLayer(input_tensor_name, layer_name, output_type, output_tensor_name)

def CreateGlobalAvgPoolingLayer(*args):
    return _hbir_base.CreateGlobalAvgPoolingLayer(*args)

def CreateSplitLayer(input_tensor_name, layer_name, dim, split_num, splits, output_type, output_tensor_name):
    return _hbir_base.CreateSplitLayer(input_tensor_name, layer_name, dim, split_num, splits, output_type, output_tensor_name)

def CreateConcatLayer(input_tensor_name, layer_name, dim, output_type, output_tensor_name):
    return _hbir_base.CreateConcatLayer(input_tensor_name, layer_name, dim, output_type, output_tensor_name)

def CreateRoiResizeLayer(input_tensor_name, layer_name, roi, target_hw, scale_factor, precision, interp_mode, pad_mode, align_mode, legacy_interp_mode, output_type, output_tensor_name):
    return _hbir_base.CreateRoiResizeLayer(input_tensor_name, layer_name, roi, target_hw, scale_factor, precision, interp_mode, pad_mode, align_mode, legacy_interp_mode, output_type, output_tensor_name)

def CreateChannelSumLayer(input_tensor_name, layer_name, output_type, output_tensor_name):
    return _hbir_base.CreateChannelSumLayer(input_tensor_name, layer_name, output_type, output_tensor_name)

def CreateSSumLayer(input_tensor_name, layer_name, output_type, output_tensor_name, dim, accu_right_shift, output_scale, output_right_shift):
    return _hbir_base.CreateSSumLayer(input_tensor_name, layer_name, output_type, output_tensor_name, dim, accu_right_shift, output_scale, output_right_shift)

def CreateRleLayer(input_tensor_name, layer_name, output_type, output_tensor_name):
    return _hbir_base.CreateRleLayer(input_tensor_name, layer_name, output_type, output_tensor_name)

def CreateRoiAlignLayer(input_tensor_names, layer_name, bbox_tensor_name, roi_output_shape, feature_stride_h_list, feature_stride_w_list, base_image_scale, middle_layer_id, ignore_score_value, num_pooling, max_num_pooling, pool_method, padding_mode, area_index, clip_box, box_augmentation, box_augmentation_params, use_box_scale, box_scale_params, legacy_roi, is_fpn_roiresize, light_inter_linear, aligned, step_shift, correct_roi, output_type, output_tensor_name):
    return _hbir_base.CreateRoiAlignLayer(input_tensor_names, layer_name, bbox_tensor_name, roi_output_shape, feature_stride_h_list, feature_stride_w_list, base_image_scale, middle_layer_id, ignore_score_value, num_pooling, max_num_pooling, pool_method, padding_mode, area_index, clip_box, box_augmentation, box_augmentation_params, use_box_scale, box_scale_params, legacy_roi, is_fpn_roiresize, light_inter_linear, aligned, step_shift, correct_roi, output_type, output_tensor_name)

def CreateScaleReluLayer(input_tensor_name, layer_name, scales, shifts, output_type, output_tensor_name):
    return _hbir_base.CreateScaleReluLayer(input_tensor_name, layer_name, scales, shifts, output_type, output_tensor_name)

def CreateLeakyReluLayer(input_tensor_name, layer_name, negative_slop, output_type, output_tensor_name):
    return _hbir_base.CreateLeakyReluLayer(input_tensor_name, layer_name, negative_slop, output_type, output_tensor_name)

def CreatePReluLayer(input_tensor_name, layer_name, output_type, output_tensor_name, weight_tensor_name, positive_scale, positive_right_shift, accu_right_shift, negative_scale, negative_right_shift):
    return _hbir_base.CreatePReluLayer(input_tensor_name, layer_name, output_type, output_tensor_name, weight_tensor_name, positive_scale, positive_right_shift, accu_right_shift, negative_scale, negative_right_shift)

def CreateSLinear(input_tensor_name, layer_name, num_filter, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding, accu_right_shift, bias_left_shift, output_scale, output_right_shift, sumin_scale, sumin_left_shift):
    return _hbir_base.CreateSLinear(input_tensor_name, layer_name, num_filter, use_bias, use_relu, sumin_tensor_name, output_type, output_tensor_name, weight_tensor_name, weight_data, bias_tensor_name, bias_data, enable_rounding, accu_right_shift, bias_left_shift, output_scale, output_right_shift, sumin_scale, sumin_left_shift)

def CreateLinearPolynomialLayer(input_tensor_name, layer_name, precision, output_channel_num, per_channel_mode):
    return _hbir_base.CreateLinearPolynomialLayer(input_tensor_name, layer_name, precision, output_channel_num, per_channel_mode)

def CreateNearestUpsampleLayer(input_tensor_name, layer_name, factor, output_type, output_tensor_name):
    return _hbir_base.CreateNearestUpsampleLayer(input_tensor_name, layer_name, factor, output_type, output_tensor_name)

def CreateReluLayer(input_tensor_name, layer_name, output_type, output_tensor_name):
    return _hbir_base.CreateReluLayer(input_tensor_name, layer_name, output_type, output_tensor_name)

def CreateOpticalPyramidLayer(input_tensor_name, layer_name, pyramid_level, scalar_outputs, grad_outputs, padding_pixel, border_mode, scalar_element_type, gradient_element_type, input_mode_str):
    return _hbir_base.CreateOpticalPyramidLayer(input_tensor_name, layer_name, pyramid_level, scalar_outputs, grad_outputs, padding_pixel, border_mode, scalar_element_type, gradient_element_type, input_mode_str)

def CreatePadLayer(input_tensor_name, layer_name, mode, constant_value, pad_before, pad_after, output_type, output_tensor_name):
    return _hbir_base.CreatePadLayer(input_tensor_name, layer_name, mode, constant_value, pad_before, pad_after, output_type, output_tensor_name)

def CreateSliceLayer(input_tensor_name, layer_name, begin, end, step, output_type, output_tensor_name):
    return _hbir_base.CreateSliceLayer(input_tensor_name, layer_name, begin, end, step, output_type, output_tensor_name)

def CreateCorrelationLayer(input1_tensor_name, input2_tensor_name, layer_name, kernel_size, max_displacement, stride1, stride2, pad_size, is_multiply, output_type, output_tensor_name):
    return _hbir_base.CreateCorrelationLayer(input1_tensor_name, input2_tensor_name, layer_name, kernel_size, max_displacement, stride1, stride2, pad_size, is_multiply, output_type, output_tensor_name)

def CreateSCorrelationLayer(input1_tensor_name, input2_tensor_name, layer_name, kernel_size, max_displacement, stride1, stride2, pad_size, is_multiply, output_type, output_tensor_name, inter_right_shift, accu_right_shift, output_scale, output_right_shift):
    return _hbir_base.CreateSCorrelationLayer(input1_tensor_name, input2_tensor_name, layer_name, kernel_size, max_displacement, stride1, stride2, pad_size, is_multiply, output_type, output_tensor_name, inter_right_shift, accu_right_shift, output_scale, output_right_shift)

def CreateElementwiseMul(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name):
    return _hbir_base.CreateElementwiseMul(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name)

def CreateSElementwiseMul(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name, output_scale, accu_right_shift, output_right_shift):
    return _hbir_base.CreateSElementwiseMul(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name, output_scale, accu_right_shift, output_right_shift)

def CreateElementwiseAdd(*args):
    return _hbir_base.CreateElementwiseAdd(*args)

def CreateElementwiseSub(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name):
    return _hbir_base.CreateElementwiseSub(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name)

def CreateElementwiseDiv(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name):
    return _hbir_base.CreateElementwiseDiv(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name)

def CreateSElementwiseAdd(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name, output_scale, accu_right_shift, output_right_shift, input_left_shift, sumin_scale, sumin_left_shift):
    return _hbir_base.CreateSElementwiseAdd(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name, output_scale, accu_right_shift, output_right_shift, input_left_shift, sumin_scale, sumin_left_shift)

def CreateSElementwiseAddX2a(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name, output_scale, accu_right_shift, output_right_shift, input_scale, sumin_scale, sumin_left_shift):
    return _hbir_base.CreateSElementwiseAddX2a(input1_tensor_name, input2_tensor_name, layer_name, enable_rounding, output_type, output_tensor_name, output_scale, accu_right_shift, output_right_shift, input_scale, sumin_scale, sumin_left_shift)

def CreateStepwiseFitLayer(input_tensor_name, layer_name, boundary_table, output_table, output_type, output_tensor_name):
    return _hbir_base.CreateStepwiseFitLayer(input_tensor_name, layer_name, boundary_table, output_table, output_type, output_tensor_name)
class SLutAttrRange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    k = property(_hbir_base.SLutAttrRange_k_get, _hbir_base.SLutAttrRange_k_set)
    b = property(_hbir_base.SLutAttrRange_b_get, _hbir_base.SLutAttrRange_b_set)
    lsh = property(_hbir_base.SLutAttrRange_lsh_get, _hbir_base.SLutAttrRange_lsh_set)
    rsh = property(_hbir_base.SLutAttrRange_rsh_get, _hbir_base.SLutAttrRange_rsh_set)
    min = property(_hbir_base.SLutAttrRange_min_get, _hbir_base.SLutAttrRange_min_set)
    max = property(_hbir_base.SLutAttrRange_max_get, _hbir_base.SLutAttrRange_max_set)
    neg_max = property(_hbir_base.SLutAttrRange_neg_max_get, _hbir_base.SLutAttrRange_neg_max_set)
    neg_min = property(_hbir_base.SLutAttrRange_neg_min_get, _hbir_base.SLutAttrRange_neg_min_set)
    neg_k = property(_hbir_base.SLutAttrRange_neg_k_get, _hbir_base.SLutAttrRange_neg_k_set)

    def __init__(self):
        _hbir_base.SLutAttrRange_swiginit(self, _hbir_base.new_SLutAttrRange())
    __swig_destroy__ = _hbir_base.delete_SLutAttrRange

# Register SLutAttrRange in _hbir_base:
_hbir_base.SLutAttrRange_swigregister(SLutAttrRange)

class SLutAttr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    table_zone_ranges = property(_hbir_base.SLutAttr_table_zone_ranges_get, _hbir_base.SLutAttr_table_zone_ranges_set)
    symmetry_k = property(_hbir_base.SLutAttr_symmetry_k_get, _hbir_base.SLutAttr_symmetry_k_set)
    symmetry_b = property(_hbir_base.SLutAttr_symmetry_b_get, _hbir_base.SLutAttr_symmetry_b_set)
    sparse_table = property(_hbir_base.SLutAttr_sparse_table_get, _hbir_base.SLutAttr_sparse_table_set)
    dense_table = property(_hbir_base.SLutAttr_dense_table_get, _hbir_base.SLutAttr_dense_table_set)
    enable_symmetry = property(_hbir_base.SLutAttr_enable_symmetry_get, _hbir_base.SLutAttr_enable_symmetry_set)
    enable_rounding = property(_hbir_base.SLutAttr_enable_rounding_get, _hbir_base.SLutAttr_enable_rounding_set)

    def __init__(self):
        _hbir_base.SLutAttr_swiginit(self, _hbir_base.new_SLutAttr())
    __swig_destroy__ = _hbir_base.delete_SLutAttr

# Register SLutAttr in _hbir_base:
_hbir_base.SLutAttr_swigregister(SLutAttr)


def CreateSLutLayer(input_tensor_name, layer_name, output_tensor_name, output_type, attr):
    return _hbir_base.CreateSLutLayer(input_tensor_name, layer_name, output_tensor_name, output_type, attr)

def CreateSElementwiseDiv(input1_tensor_name, input2_tensor_name, table_tensor_name, layer_name, output_type, output_tensor_name, enable_rounding, table_param_is_str, output_scale, accu_right_shift, output_right_shift):
    return _hbir_base.CreateSElementwiseDiv(input1_tensor_name, input2_tensor_name, table_tensor_name, layer_name, output_type, output_tensor_name, enable_rounding, table_param_is_str, output_scale, accu_right_shift, output_right_shift)

def CreateConvertBetweenInt8AndUint8Layer(input_layer_name, layer_name, output_type, output_tensor_name):
    return _hbir_base.CreateConvertBetweenInt8AndUint8Layer(input_layer_name, layer_name, output_type, output_tensor_name)

def CreateDilateLayer(input_layer_name, layer_name, kernel, element_type, output_type, output_tensor_name):
    return _hbir_base.CreateDilateLayer(input_layer_name, layer_name, kernel, element_type, output_type, output_tensor_name)

def CreateReshapeLayer(input_tensor_name, layer_name, mode, output_shape, output_type, output_tensor_name, upscale_factor):
    return _hbir_base.CreateReshapeLayer(input_tensor_name, layer_name, mode, output_shape, output_type, output_tensor_name, upscale_factor)
round_mode_t_UNSET = _hbir_base.round_mode_t_UNSET
round_mode_t_FLOOR = _hbir_base.round_mode_t_FLOOR
round_mode_t_ROUND = _hbir_base.round_mode_t_ROUND
round_mode_t_CEIL = _hbir_base.round_mode_t_CEIL
symmetry_mode_t_NONE = _hbir_base.symmetry_mode_t_NONE
symmetry_mode_t_Y_SYMMETRIC = _hbir_base.symmetry_mode_t_Y_SYMMETRIC
symmetry_mode_t_ORIGIN_SYMMETRIC = _hbir_base.symmetry_mode_t_ORIGIN_SYMMETRIC
class Lut2AttrRange(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    b = property(_hbir_base.Lut2AttrRange_b_get, _hbir_base.Lut2AttrRange_b_set)
    k = property(_hbir_base.Lut2AttrRange_k_get, _hbir_base.Lut2AttrRange_k_set)
    sum_rsh = property(_hbir_base.Lut2AttrRange_sum_rsh_get, _hbir_base.Lut2AttrRange_sum_rsh_set)
    add_lsh = property(_hbir_base.Lut2AttrRange_add_lsh_get, _hbir_base.Lut2AttrRange_add_lsh_set)
    max = property(_hbir_base.Lut2AttrRange_max_get, _hbir_base.Lut2AttrRange_max_set)

    def __init__(self):
        _hbir_base.Lut2AttrRange_swiginit(self, _hbir_base.new_Lut2AttrRange())
    __swig_destroy__ = _hbir_base.delete_Lut2AttrRange

# Register Lut2AttrRange in _hbir_base:
_hbir_base.Lut2AttrRange_swigregister(Lut2AttrRange)

class Lut2Attr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_of_table_zones = _hbir_base.Lut2Attr_num_of_table_zones
    num_table_entries = _hbir_base.Lut2Attr_num_table_entries
    tables = property(_hbir_base.Lut2Attr_tables_get, _hbir_base.Lut2Attr_tables_set)
    left_line_range = property(_hbir_base.Lut2Attr_left_line_range_get, _hbir_base.Lut2Attr_left_line_range_set)
    table_zone_ranges = property(_hbir_base.Lut2Attr_table_zone_ranges_get, _hbir_base.Lut2Attr_table_zone_ranges_set)
    right_line_range = property(_hbir_base.Lut2Attr_right_line_range_get, _hbir_base.Lut2Attr_right_line_range_set)
    symmetry_mode = property(_hbir_base.Lut2Attr_symmetry_mode_get, _hbir_base.Lut2Attr_symmetry_mode_set)
    round_mode = property(_hbir_base.Lut2Attr_round_mode_get, _hbir_base.Lut2Attr_round_mode_set)
    enable_saturate = property(_hbir_base.Lut2Attr_enable_saturate_get, _hbir_base.Lut2Attr_enable_saturate_set)

    def __init__(self):
        _hbir_base.Lut2Attr_swiginit(self, _hbir_base.new_Lut2Attr())
    __swig_destroy__ = _hbir_base.delete_Lut2Attr

# Register Lut2Attr in _hbir_base:
_hbir_base.Lut2Attr_swigregister(Lut2Attr)

class LutFastAttr(object):
    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc="The membership flag")
    __repr__ = _swig_repr
    num_table_entries = _hbir_base.LutFastAttr_num_table_entries
    Shift_THREE = _hbir_base.LutFastAttr_Shift_THREE
    Shift_SEVEN = _hbir_base.LutFastAttr_Shift_SEVEN
    Shift_ELEVEN = _hbir_base.LutFastAttr_Shift_ELEVEN
    Shift_FIFTEEN = _hbir_base.LutFastAttr_Shift_FIFTEEN
    boundary_left = property(_hbir_base.LutFastAttr_boundary_left_get, _hbir_base.LutFastAttr_boundary_left_set)
    boundary_right = property(_hbir_base.LutFastAttr_boundary_right_get, _hbir_base.LutFastAttr_boundary_right_set)
    left_ploy_k = property(_hbir_base.LutFastAttr_left_ploy_k_get, _hbir_base.LutFastAttr_left_ploy_k_set)
    left_ploy_b = property(_hbir_base.LutFastAttr_left_ploy_b_get, _hbir_base.LutFastAttr_left_ploy_b_set)
    left_ploy_shift = property(_hbir_base.LutFastAttr_left_ploy_shift_get, _hbir_base.LutFastAttr_left_ploy_shift_set)
    mapping_k = property(_hbir_base.LutFastAttr_mapping_k_get, _hbir_base.LutFastAttr_mapping_k_set)
    mapping_b = property(_hbir_base.LutFastAttr_mapping_b_get, _hbir_base.LutFastAttr_mapping_b_set)
    mapping_shift = property(_hbir_base.LutFastAttr_mapping_shift_get, _hbir_base.LutFastAttr_mapping_shift_set)
    params_list = property(_hbir_base.LutFastAttr_params_list_get, _hbir_base.LutFastAttr_params_list_set)
    right_ploy_k = property(_hbir_base.LutFastAttr_right_ploy_k_get, _hbir_base.LutFastAttr_right_ploy_k_set)
    right_ploy_b = property(_hbir_base.LutFastAttr_right_ploy_b_get, _hbir_base.LutFastAttr_right_ploy_b_set)
    right_ploy_shift = property(_hbir_base.LutFastAttr_right_ploy_shift_get, _hbir_base.LutFastAttr_right_ploy_shift_set)

    def __init__(self):
        _hbir_base.LutFastAttr_swiginit(self, _hbir_base.new_LutFastAttr())
    __swig_destroy__ = _hbir_base.delete_LutFastAttr

# Register LutFastAttr in _hbir_base:
_hbir_base.LutFastAttr_swigregister(LutFastAttr)


def CreateLut2(inputs_tensor_name, layer_name, output_tensor_name, attr, output_type):
    return _hbir_base.CreateLut2(inputs_tensor_name, layer_name, output_tensor_name, attr, output_type)

def CreateLutFast(inputs_tensor_name, layer_name, output_tensor_name, attr, output_type):
    return _hbir_base.CreateLutFast(inputs_tensor_name, layer_name, output_tensor_name, attr, output_type)

def CreateElementwiseMin(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseMin(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseMax(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseMax(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseBitAnd(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseBitAnd(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseBitOr(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseBitOr(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseBitXor(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseBitXor(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseEqual(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseEqual(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseNotEqual(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseNotEqual(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseGreater(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseGreater(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseLessOrEqual(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseLessOrEqual(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseGreaterOrEqual(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseGreaterOrEqual(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseLess(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseLess(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseLogicalShift(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseLogicalShift(inputs_tensor_name, layer_name, output_tensor_name)

def CreateElementwiseArithShift(inputs_tensor_name, layer_name, output_tensor_name):
    return _hbir_base.CreateElementwiseArithShift(inputs_tensor_name, layer_name, output_tensor_name)

def CreateChannelShuffle(input_tensor_name, layer_name, shuffle_index, output_tensor_name):
    return _hbir_base.CreateChannelShuffle(input_tensor_name, layer_name, shuffle_index, output_tensor_name)

def CreateRescale(input_tensor_name, layer_name, output_scale, output_right_shift, output_type, output_tensor_name, enable_rounding=True):
    return _hbir_base.CreateRescale(input_tensor_name, layer_name, output_scale, output_right_shift, output_type, output_tensor_name, enable_rounding)

def CreateSpaceToBatchLayer(input_tensor_name, layer_name, factor_vec, output_type, output_tensor_name):
    return _hbir_base.CreateSpaceToBatchLayer(input_tensor_name, layer_name, factor_vec, output_type, output_tensor_name)

def CreateBatchToSpaceLayer(input_tensor_name, layer_name, factor_vec, output_type, output_tensor_name):
    return _hbir_base.CreateBatchToSpaceLayer(input_tensor_name, layer_name, factor_vec, output_type, output_tensor_name)

def CreateFilterLayer(input_tensor_name, layer_name, anchor_num, threshold, max_box_num, start_channel, end_channel, post_process, output_tensor_name):
    return _hbir_base.CreateFilterLayer(input_tensor_name, layer_name, anchor_num, threshold, max_box_num, start_channel, end_channel, post_process, output_tensor_name)

def CreateSoftmax(input_tensor_name, layer_name, preserve_shape, max_value_only, exp_table, exp_shift, middle_right_shift, output_type, output_tensor_name, enable_rounding, output_scale, accu_right_shift, output_right_shift):
    return _hbir_base.CreateSoftmax(input_tensor_name, layer_name, preserve_shape, max_value_only, exp_table, exp_shift, middle_right_shift, output_type, output_tensor_name, enable_rounding, output_scale, accu_right_shift, output_right_shift)

def CreateSoftmaxWithTable(input_tensor_name, exp_table_tensor_name, reciprocal_table_tensor_name, layer_name, preserve_shape, max_value_only, exp_table, exp_shift, middle_right_shift, output_type, output_tensor_name, enable_rounding, table_param_is_str, output_scale, accu_right_shift, output_right_shift):
    return _hbir_base.CreateSoftmaxWithTable(input_tensor_name, exp_table_tensor_name, reciprocal_table_tensor_name, layer_name, preserve_shape, max_value_only, exp_table, exp_shift, middle_right_shift, output_type, output_tensor_name, enable_rounding, table_param_is_str, output_scale, accu_right_shift, output_right_shift)

def CreateSoftmaxX2X2A(input_tensor_name, output_tensor_name, layer_name, exp_table, max_value_only):
    return _hbir_base.CreateSoftmaxX2X2A(input_tensor_name, output_tensor_name, layer_name, exp_table, max_value_only)

def CreateLayerNorm(input_tensor_name, table_tensor_name, layer_name, gamma, beta, gamma_shift, beta_shift, output_type, enable_rounding, table_param_is_str, output_scale, accu_right_shift, output_right_shift, output_tensor_name):
    return _hbir_base.CreateLayerNorm(input_tensor_name, table_tensor_name, layer_name, gamma, beta, gamma_shift, beta_shift, output_type, enable_rounding, table_param_is_str, output_scale, accu_right_shift, output_right_shift, output_tensor_name)

def CreateChannelMax(input_tensor_name, layer_name, keep_score, keep_index, run_length_encoding, class_offset, group_number, output_tensor_name):
    return _hbir_base.CreateChannelMax(input_tensor_name, layer_name, keep_score, keep_index, run_length_encoding, class_offset, group_number, output_tensor_name)

def CreateGemmLayer(input_tensor_name, layer_name, alpha, beta, is_transa, is_transb, is_literala, is_literalb, output_shape, output_type, output_tensor_name):
    return _hbir_base.CreateGemmLayer(input_tensor_name, layer_name, alpha, beta, is_transa, is_transb, is_literala, is_literalb, output_shape, output_type, output_tensor_name)

def CreateSGemmLayer(input_tensor_name, layer_name, alpha, beta, is_transa, is_transb, is_literala, is_literalb, output_shape, output_type, output_scale, accu_right_shift, output_right_shift, enable_rounding, output_tensor_name):
    return _hbir_base.CreateSGemmLayer(input_tensor_name, layer_name, alpha, beta, is_transa, is_transb, is_literala, is_literalb, output_shape, output_type, output_scale, accu_right_shift, output_right_shift, enable_rounding, output_tensor_name)

def CreateWarpingLayer(input_tensor_names, layer_name, stride, mapping_offset, kernel, warping_mode, is_mapping_y_then_x, is_input_uint8, is_output_uint8, padding_value, padding_value_uv, enable_rounding, interpolation_mode, pad_mode, output_tensor_name):
    return _hbir_base.CreateWarpingLayer(input_tensor_names, layer_name, stride, mapping_offset, kernel, warping_mode, is_mapping_y_then_x, is_input_uint8, is_output_uint8, padding_value, padding_value_uv, enable_rounding, interpolation_mode, pad_mode, output_tensor_name)

def CreateMeanLayer(input_tensor_name, layer_name, dim, output_type, output_tensor_name):
    return _hbir_base.CreateMeanLayer(input_tensor_name, layer_name, dim, output_type, output_tensor_name)

def CreateSMeanLayer(input_tensor_name, layer_name, dim, output_type, output_tensor_name, accu_right_shift, output_scale, output_right_shift):
    return _hbir_base.CreateSMeanLayer(input_tensor_name, layer_name, dim, output_type, output_tensor_name, accu_right_shift, output_scale, output_right_shift)

def CreateTileLayer(input_tensor_name, layer_name, dim, multiples, output_tensor_name):
    return _hbir_base.CreateTileLayer(input_tensor_name, layer_name, dim, multiples, output_tensor_name)

def CreateReduceMaxLayer(input_tensor_name, layer_name, axis, return_index, output_tensor_name):
    return _hbir_base.CreateReduceMaxLayer(input_tensor_name, layer_name, axis, return_index, output_tensor_name)

def CreateReduceMinLayer(input_tensor_name, layer_name, axis, return_index, output_tensor_name):
    return _hbir_base.CreateReduceMinLayer(input_tensor_name, layer_name, axis, return_index, output_tensor_name)

def CreateViewLayer(input_tensor_name, layer_name, expected_shape, output_tensor_name):
    return _hbir_base.CreateViewLayer(input_tensor_name, layer_name, expected_shape, output_tensor_name)

def CreateTransposeLayer(input_tensor_name, layer_name, perm, output_tensor_name):
    return _hbir_base.CreateTransposeLayer(input_tensor_name, layer_name, perm, output_tensor_name)

def CreateCropLayer(input_tensor_name, layer_name, rect, output_tensor_name):
    return _hbir_base.CreateCropLayer(input_tensor_name, layer_name, rect, output_tensor_name)

def CreateDetectionPostProcessLayer(input_tensor_names, layer_name, anchor_name, exp_table_name, im_info_name, anchor_data, exp_table_data, num_anchors, num_classes, input_shifts, block_sizes_h, block_sizes_w, class_offsets, anchor_start_addr, strides_h, strides_w, use_clippings, image_size_fixed, stable_sort, image_h, image_w, exp_shift, box_filter_threshold, seed, nms_threshold, nms_margin, nms_output_bbox_num, output_tensor_name):
    return _hbir_base.CreateDetectionPostProcessLayer(input_tensor_names, layer_name, anchor_name, exp_table_name, im_info_name, anchor_data, exp_table_data, num_anchors, num_classes, input_shifts, block_sizes_h, block_sizes_w, class_offsets, anchor_start_addr, strides_h, strides_w, use_clippings, image_size_fixed, stable_sort, image_h, image_w, exp_shift, box_filter_threshold, seed, nms_threshold, nms_margin, nms_output_bbox_num, output_tensor_name)

def CreateRcnnPostPorcessLayer(layer_name, bbox_tensor_name, bbox_score_tn, bbox_deltas_tn, im_info_tn, original_img_h, original_img_w, nms_threshold, class_number, nms_top_n, score_threshold, bbox_delta_mean, bbox_delta_std, image_size_fixed, output0_name, output1_name):
    return _hbir_base.CreateRcnnPostPorcessLayer(layer_name, bbox_tensor_name, bbox_score_tn, bbox_deltas_tn, im_info_tn, original_img_h, original_img_w, nms_threshold, class_number, nms_top_n, score_threshold, bbox_delta_mean, bbox_delta_std, image_size_fixed, output0_name, output1_name)

def CreateGatherElementsLayer(input_tensor_name0, input_tensor_name1, layer_name, axis, output_tensor_name):
    return _hbir_base.CreateGatherElementsLayer(input_tensor_name0, input_tensor_name1, layer_name, axis, output_tensor_name)

def CreateScatterLayer(input1_tensor_name, input2_tensor_name, out_shape, layer_name, output_tensor_name):
    return _hbir_base.CreateScatterLayer(input1_tensor_name, input2_tensor_name, out_shape, layer_name, output_tensor_name)

def CreateRollLayer(input_tensor_name, shifts, dims, layer_name, output_tensor_name):
    return _hbir_base.CreateRollLayer(input_tensor_name, shifts, dims, layer_name, output_tensor_name)

def CreateGatherLayer(*args):
    return _hbir_base.CreateGatherLayer(*args)

def CreateOnnxGatherLayer(*args):
    return _hbir_base.CreateOnnxGatherLayer(*args)

def CreateTopKElementsLayer(input_tensor_name, layer_name, k, dim, largest, sorted, index, index_element_type, output_tensor_name):
    return _hbir_base.CreateTopKElementsLayer(input_tensor_name, layer_name, k, dim, largest, sorted, index, index_element_type, output_tensor_name)

def CreateClampLayer(input_tensor_name, min_tensor_name, max_tensor_name, layer_name, min, max, output_type, output_tensor_name):
    return _hbir_base.CreateClampLayer(input_tensor_name, min_tensor_name, max_tensor_name, layer_name, min, max, output_type, output_tensor_name)

def CreateElementwiseAbs(input_tensor_name, layer_name, saturated_output, output_tensor_name):
    return _hbir_base.CreateElementwiseAbs(input_tensor_name, layer_name, saturated_output, output_tensor_name)

def SetAnnotation(tensor_name, annotation):
    return _hbir_base.SetAnnotation(tensor_name, annotation)


