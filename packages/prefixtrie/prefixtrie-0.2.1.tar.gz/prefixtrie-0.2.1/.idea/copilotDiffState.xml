<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.pre-commit-config.yaml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.pre-commit-config.yaml" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CHANGELOG.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CHANGELOG.md" />
              <option name="updatedContent" value="# Changelog&#10;### Features&#10;- Efficient exact and approximate string matching&#10;- Configurable maximum substitutions&#10;- Optional indel (insertion/deletion) support&#10;- Optimized for read-only use cases&#10;- Aggressive caching for performance&#10;- C++ backend for speed&#10;&#10;[Unreleased]: https://github.com/austinv11/PrefixTrie/compare/v0.1.0...HEAD&#10;[0.1.0]: https://github.com/austinv11/PrefixTrie/releases/tag/v0.1.0" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/CONTRIBUTING.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/CONTRIBUTING.md" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug_exact.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug_exact.py" />
              <option name="updatedContent" value="import pyximport&#10;pyximport.install()&#10;from prefixtrie._impl import cPrefixTrie&#10;&#10;# Test the exact flag issue&#10;print(&quot;=== Testing exact flag behavior ===&quot;)&#10;&#10;entries = [&quot;hello&quot;, &quot;help&quot;, &quot;helicopter&quot;]&#10;trie = cPrefixTrie(entries, allow_indels=True)&#10;&#10;# Test the failing case&#10;result, exact = trie.search(&quot;helllo&quot;, correction_budget=1)&#10;print(f&quot;'helllo' -&gt; '{result}', exact={exact} (should be exact=False)&quot;)&#10;&#10;# Test some other cases for comparison&#10;result, exact = trie.search(&quot;hello&quot;, correction_budget=1)&#10;print(f&quot;'hello' -&gt; '{result}', exact={exact} (should be exact=True)&quot;)&#10;&#10;result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)&#10;print(f&quot;'hallo' -&gt; '{result}', exact={exact} (should be exact=False)&quot;)&#10;&#10;# Test without budget (should only find exact matches)&#10;result, exact = trie.search(&quot;helllo&quot;, correction_budget=0)&#10;print(f&quot;'helllo' (budget=0) -&gt; '{result}', exact={exact} (should be None)&quot;)&#10;&#10;# Test if it's actually the same string&#10;print(f&quot;\nString comparison: 'helllo' == 'hello': {'helllo' == 'hello'}&quot;)&#10;print(f&quot;Lengths: 'helllo'={len('helllo')}, 'hello'={len('hello')}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug_insertion.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug_insertion.py" />
              <option name="updatedContent" value="import pyximport&#10;pyximport.install()&#10;from prefixtrie._impl import cPrefixTrie&#10;&#10;# Test the specific insertion issue&#10;print(&quot;=== Testing insertion logic ===&quot;)&#10;&#10;# Simple case: &quot;hel&quot; should find &quot;help&quot; with 1 insertion&#10;trie = cPrefixTrie([&quot;help&quot;], allow_indels=True)&#10;result, exact = trie.search(&quot;hel&quot;, correction_budget=1)&#10;print(f&quot;'hel' -&gt; 'help': {result} (should be 'help')&quot;)&#10;&#10;# Even simpler case: &quot;he&quot; should find &quot;help&quot; with 2 insertions&#10;result, exact = trie.search(&quot;he&quot;, correction_budget=2)&#10;print(f&quot;'he' -&gt; 'help': {result} (should be 'help')&quot;)&#10;&#10;# Test at trie boundary: &quot;h&quot; should find &quot;help&quot; with 3 insertions&#10;result, exact = trie.search(&quot;h&quot;, correction_budget=3)&#10;print(f&quot;'h' -&gt; 'help': {result} (should be 'help')&quot;)&#10;&#10;# Test empty string should find &quot;help&quot; with 4 insertions&#10;result, exact = trie.search(&quot;&quot;, correction_budget=4)&#10;print(f&quot;'' -&gt; 'help': {result} (should be 'help')&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/debug_test.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/debug_test.py" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="import pyximport&#10;pyximport.install()&#10;from prefixtrie._impl import cPrefixTrie&#10;&#10;# Debug the failing test case&#10;print(&quot;=== Debugging insertion/deletion behavior ===&quot;)&#10;&#10;entries = [&quot;hello&quot;, &quot;help&quot;, &quot;helicopter&quot;]&#10;trie = cPrefixTrie(entries, allow_indels=True)&#10;&#10;# Test the failing case&#10;query = &quot;helo&quot;&#10;result, exact = trie.search(query, correction_budget=1)&#10;print(f&quot;Query: '{query}' -&gt; Result: '{result}', Exact: {exact}&quot;)&#10;print(f&quot;Expected: 'hello' (insertion of 'l')&quot;)&#10;print(f&quot;Actual result needs: {len(query)} -&gt; {len(result)} chars&quot;)&#10;&#10;# Let's test what happens with different queries&#10;test_cases = [&#10;    (&quot;helo&quot;, 1),    # missing 'l' - should be &quot;hello&quot;&#10;    (&quot;hel&quot;, 1),     # missing 'p' - should be &quot;help&quot;&#10;    (&quot;helllo&quot;, 1),  # extra 'l' - should be &quot;hello&quot;&#10;    (&quot;helpx&quot;, 1),   # extra 'x' - should be &quot;help&quot;&#10;]&#10;&#10;print(&quot;\n=== Testing various edit scenarios ===&quot;)&#10;for query, budget in test_cases:&#10;    result, exact = trie.search(query, correction_budget=budget)&#10;    print(f&quot;'{query}' (budget={budget}) -&gt; '{result}' (exact={exact})&quot;)&#10;&#10;# Test with each entry individually to see algorithm preference&#10;print(&quot;\n=== Testing with individual entries ===&quot;)&#10;for entry in entries:&#10;    single_trie = cPrefixTrie([entry], allow_indels=True)&#10;    result, exact = single_trie.search(&quot;helo&quot;, correction_budget=1)&#10;    print(f&quot;Single entry '{entry}': 'helo' -&gt; '{result}' (exact={exact})&quot;)&#10;&#10;# Test edit distances manually&#10;print(&quot;\n=== Manual edit distance analysis ===&quot;)&#10;print(&quot;'helo' -&gt; 'hello': 1 insertion (insert 'l' at position 2)&quot;)&#10;print(&quot;'helo' -&gt; 'help': 1 substitution ('o' -&gt; 'p') + 1 deletion (remove 'o')&quot;)&#10;print(&quot;Wait, that's wrong. Let me recalculate:&quot;)&#10;print(&quot;'helo' -&gt; 'help': actually needs 2 edits (substitute 'o'-&gt;'p', then what?)&quot;)&#10;print()&#10;print(&quot;Let's check character by character:&quot;)&#10;print(&quot;helo -&gt; hello: h=h, e=e, l=l, o-&gt;l (substitute), +o (insert) = 2 edits&quot;)&#10;print(&quot;helo -&gt; help:  h=h, e=e, l=l, o-&gt;p (substitute) = 1 edit&quot;)&#10;print()&#10;print(&quot;Actually, I think 'help' IS the correct answer for 'helo' with 1 edit!&quot;)&#10;&#10;# Debug another failing case&#10;print(&quot;\n=== Debugging 'hell' case ===&quot;)&#10;query = &quot;hell&quot;&#10;result, exact = trie.search(query, correction_budget=1)&#10;print(f&quot;Query: '{query}' -&gt; Result: '{result}', Exact: {exact}&quot;)&#10;&#10;print(&quot;\nEdit distance analysis:&quot;)&#10;print(&quot;'hell' -&gt; 'hello': insert 'o' at end = 1 edit&quot;)&#10;print(&quot;'hell' -&gt; 'help': substitute 'l'-&gt;'p' at position 3 = 1 edit&quot;)&#10;print(&quot;Both require exactly 1 edit, so either could be valid!&quot;)&#10;&#10;# Debug the &quot;hel&quot; case&#10;print(&quot;\n=== Debugging 'hel' case ===&quot;)&#10;query = &quot;hel&quot;&#10;result, exact = trie.search(query, correction_budget=1)&#10;print(f&quot;Query: '{query}' -&gt; Result: '{result}', Exact: {exact}&quot;)&#10;&#10;print(&quot;\nEdit distance analysis:&quot;)&#10;print(&quot;'hel' -&gt; 'hello': insert 'l' at pos 3, insert 'o' at pos 4 = 2 edits&quot;)&#10;print(&quot;'hel' -&gt; 'help': insert 'p' at pos 3 = 1 edit&quot;)&#10;print(&quot;'hel' -&gt; 'helicopter': insert many chars = many edits&quot;)&#10;&#10;# Test with individual entries&#10;print(&quot;\n=== Testing 'hel' with individual entries ===&quot;)&#10;for entry in entries:&#10;    single_trie = cPrefixTrie([entry], allow_indels=True)&#10;    result, exact = single_trie.search(&quot;hel&quot;, correction_budget=1)&#10;    print(f&quot;Single entry '{entry}': 'hel' -&gt; '{result}' (exact={exact})&quot;)&#10;&#10;# Test what happens with budget 2&#10;result, exact = trie.search(&quot;hel&quot;, correction_budget=2)&#10;print(f&quot;\nWith budget 2: 'hel' -&gt; '{result}' (exact={exact})&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/setup.cfg">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/setup.cfg" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/test/test.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/test/test.py" />
              <option name="originalContent" value="import pytest&#10;import pyximport&#10;pyximport.install()&#10;from prefixtrie import PrefixTrie&#10;&#10;&#10;class TestPrefixTrieBasic:&#10;    &quot;&quot;&quot;Test basic functionality of PrefixTrie&quot;&quot;&quot;&#10;&#10;    def test_empty_trie(self):&#10;        &quot;&quot;&quot;Test creating an empty trie&quot;&quot;&quot;&#10;        trie = PrefixTrie([])&#10;        result, exact = trie.search(&quot;test&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;        # Searching for an empty string in an empty trie should not report an&#10;        # exact match.&#10;        result, exact = trie.search(&quot;&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_single_entry(self):&#10;        &quot;&quot;&quot;Test trie with single entry&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;hello&quot;])&#10;&#10;        # Exact match&#10;        result, exact = trie.search(&quot;hello&quot;)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is True&#10;&#10;        # No match&#10;        result, exact = trie.search(&quot;world&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_multiple_entries(self):&#10;        &quot;&quot;&quot;Test trie with multiple entries&quot;&quot;&quot;&#10;        entries = [&quot;cat&quot;, &quot;car&quot;, &quot;card&quot;, &quot;care&quot;, &quot;careful&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;    def test_trailing_and_missing_characters(self):&#10;        &quot;&quot;&quot;Ensure extra or missing characters are handled with indels&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Extra character at the end should count as a deletion&#10;        result, exact = trie.search(&quot;hello!&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        # Missing character should be handled as an insertion&#10;        result, exact = trie.search(&quot;hell&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;    def test_prefix_matching(self):&#10;        &quot;&quot;&quot;Test prefix-based matching&quot;&quot;&quot;&#10;        entries = [&quot;test&quot;, &quot;testing&quot;, &quot;tester&quot;, &quot;tea&quot;, &quot;team&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        # Test exact matches for complete entries&#10;        result, exact = trie.search(&quot;test&quot;)&#10;        assert result == &quot;test&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;tea&quot;)&#10;        assert result == &quot;tea&quot;&#10;        assert exact is True&#10;&#10;        # Test that partial prefixes don't match without fuzzy search&#10;        result, exact = trie.search(&quot;te&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;&#10;class TestPrefixTrieEdgeCases:&#10;    &quot;&quot;&quot;Test edge cases and special characters&quot;&quot;&quot;&#10;&#10;    def test_empty_string_entry(self):&#10;        &quot;&quot;&quot;Test with empty string in entries&quot;&quot;&quot;&#10;        # Empty strings may not be supported by this trie implementation&#10;        trie = PrefixTrie([&quot;hello&quot;, &quot;world&quot;])&#10;&#10;        result, exact = trie.search(&quot;&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_single_character_entries(self):&#10;        &quot;&quot;&quot;Test with single character entries&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])&#10;&#10;        result, exact = trie.search(&quot;a&quot;)&#10;        assert result == &quot;a&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;d&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_duplicate_entries(self):&#10;        &quot;&quot;&quot;Test with duplicate entries&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;hello&quot;, &quot;hello&quot;, &quot;world&quot;])&#10;&#10;        result, exact = trie.search(&quot;hello&quot;)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is True&#10;&#10;    def test_special_characters(self):&#10;        &quot;&quot;&quot;Test with special characters&quot;&quot;&quot;&#10;        entries = [&quot;hello!&quot;, &quot;test@123&quot;, &quot;a-b-c&quot;, &quot;x_y_z&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;    def test_case_sensitivity(self):&#10;        &quot;&quot;&quot;Test case sensitivity&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;Hello&quot;, &quot;hello&quot;, &quot;HELLO&quot;])&#10;&#10;        result, exact = trie.search(&quot;Hello&quot;)&#10;        assert result == &quot;Hello&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;hello&quot;)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;HELLO&quot;)&#10;        assert result == &quot;HELLO&quot;&#10;        assert exact is True&#10;&#10;    def test_budget_increase_recomputes(self):&#10;        trie = PrefixTrie([&quot;hello&quot;], allow_indels=True)&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=0)&#10;        assert result is None and exact is False&#10;&#10;        # With more corrections available, the match should now succeed&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot; and exact is False&#10;&#10;class TestPrefixTrieFuzzyMatching:&#10;    &quot;&quot;&quot;Test fuzzy matching capabilities&quot;&quot;&quot;&#10;&#10;    def test_basic_fuzzy_matching(self):&#10;        &quot;&quot;&quot;Test basic fuzzy matching with corrections&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=False)&#10;&#10;        # Test with 1 correction budget - single character substitution&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)  # e-&gt;a substitution&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;worle&quot;, correction_budget=1)  # d-&gt;e substitution&#10;        assert result == &quot;world&quot;&#10;        assert exact is False&#10;&#10;    def test_fuzzy_matching_with_indels(self):&#10;        &quot;&quot;&quot;Test fuzzy matching with insertions and deletions&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;, &quot;world&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test simple substitution that should work&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        # Test that we can find matches with small edits&#10;        result, exact = trie.search(&quot;worlx&quot;, correction_budget=1)&#10;        assert result == &quot;world&quot;&#10;        assert exact is False&#10;&#10;    def test_correction_budget_limits(self):&#10;        &quot;&quot;&quot;Test that correction budget is respected&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Should find with budget of 2&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=2)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        # Should not find with budget of 0&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=0)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_multiple_corrections(self):&#10;        &quot;&quot;&quot;Test queries requiring multiple corrections&quot;&quot;&quot;&#10;        entries = [&quot;testing&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Two substitutions&#10;        result, exact = trie.search(&quot;taxting&quot;, correction_budget=2)&#10;        assert result == &quot;testing&quot;&#10;        assert exact is False&#10;&#10;        # Should not find with insufficient budget&#10;        result, exact = trie.search(&quot;taxting&quot;, correction_budget=1)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;&#10;class TestPrefixTriePerformance:&#10;    &quot;&quot;&quot;Test performance-related scenarios&quot;&quot;&quot;&#10;&#10;    def test_large_alphabet(self):&#10;        &quot;&quot;&quot;Test with entries using large character set&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;abcdefghijklmnopqrstuvwxyz&quot;,&#10;            &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,&#10;            &quot;0123456789&quot;,&#10;            &quot;!@#$%^&amp;*()_+-=&quot;&#10;        ]&#10;        trie = PrefixTrie(entries)&#10;&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;    def test_long_strings(self):&#10;        &quot;&quot;&quot;Test with very long strings&quot;&quot;&quot;&#10;        long_string = &quot;a&quot; * 1000&#10;        entries = [long_string, long_string + &quot;b&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        result, exact = trie.search(long_string)&#10;        assert result == long_string&#10;        assert exact is True&#10;&#10;    def test_many_entries(self):&#10;        &quot;&quot;&quot;Test with many entries&quot;&quot;&quot;&#10;        entries = [f&quot;entry_{i:04d}&quot; for i in range(1000)]&#10;        trie = PrefixTrie(entries)&#10;&#10;        # Test a few random entries&#10;        test_entries = [entries[0], entries[500], entries[999]]&#10;        for entry in test_entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;&#10;class TestPrefixTrieDNASequences:&#10;    &quot;&quot;&quot;Test with DNA-like sequences (similar to the original test)&quot;&quot;&quot;&#10;&#10;    def test_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with DNA sequences&quot;&quot;&quot;&#10;        sequences = [&quot;ACGT&quot;, &quot;TCGA&quot;, &quot;AAAA&quot;, &quot;TTTT&quot;, &quot;CCCC&quot;, &quot;GGGG&quot;]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_dna_fuzzy_matching(self):&#10;        &quot;&quot;&quot;Test fuzzy matching with DNA sequences&quot;&quot;&quot;&#10;        sequences = [&quot;ACGT&quot;, &quot;TCGA&quot;]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Single base substitution&#10;        result, exact = trie.search(&quot;ACCT&quot;, correction_budget=1)&#10;        assert result == &quot;ACGT&quot;&#10;        assert exact is False&#10;&#10;        # Test with a clear mismatch that requires correction&#10;        result, exact = trie.search(&quot;ACXX&quot;, correction_budget=2)&#10;        assert result == &quot;ACGT&quot;&#10;        assert exact is False&#10;&#10;        # Test that fuzzy matching works with sufficient budget&#10;        result, exact = trie.search(&quot;TCXX&quot;, correction_budget=2)&#10;        assert result == &quot;TCGA&quot;&#10;        assert exact is False&#10;&#10;    def test_similar_sequences(self):&#10;        &quot;&quot;&quot;Test with very similar sequences&quot;&quot;&quot;&#10;        sequences = [&quot;ATCG&quot;, &quot;ATCGA&quot;, &quot;ATCGAA&quot;, &quot;ATCGAAA&quot;]&#10;        trie = PrefixTrie(sequences)&#10;&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_medium_length_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with medium-length DNA sequences (20-50 bases)&quot;&quot;&quot;&#10;        sequences = [&#10;            &quot;ATCGATCGATCGATCGATCG&quot;,  # 20 bases&#10;            &quot;GCTAGCTAGCTAGCTAGCTAGCTA&quot;,  # 23 bases&#10;            &quot;AAATTTCCCGGGAAATTTCCCGGGAAATTT&quot;,  # 29 bases&#10;            &quot;TCGATCGATCGATCGATCGATCGATCGATCG&quot;,  # 30 bases&#10;            &quot;AGCTTAGCTTAGCTTAGCTTAGCTTAGCTTAGCTTA&quot;,  # 35 bases&#10;            &quot;CGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA&quot;,  # 39 bases&#10;            &quot;TTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAA&quot;,  # 43 bases&#10;            &quot;GCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCG&quot;  # 45 bases&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching with single substitution&#10;        result, exact = trie.search(&quot;ATCGATCGATCGATCGATCX&quot;, correction_budget=1)&#10;        assert result == &quot;ATCGATCGATCGATCGATCG&quot;&#10;        assert exact is False&#10;&#10;    def test_long_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with long DNA sequences (100+ bases)&quot;&quot;&quot;&#10;        sequences = [&#10;            # 100 base sequence&#10;            &quot;ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG&quot;,&#10;            # 120 base sequence&#10;            &quot;GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA&quot;,&#10;            # 150 base sequence with more variety&#10;            &quot;AAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGG&quot;,&#10;            # 200 base sequence&#10;            &quot;TCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG&quot;&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_realistic_gene_sequences(self):&#10;        &quot;&quot;&quot;Test with realistic gene-like sequences&quot;&quot;&quot;&#10;        # Simulated gene sequences with typical biological patterns&#10;        sequences = [&#10;            # Start codon (ATG) followed by coding sequence&#10;            &quot;ATGAAACGTCTAGCTAGCTAGCTAGCTAG&quot;,&#10;            # Promoter-like sequence&#10;            &quot;TATAAAAGGCCGCTCGAGCTCGAGCTCGA&quot;,&#10;            # Enhancer-like sequence&#10;            &quot;GCGCGCGCATATATATGCGCGCGCATATA&quot;,&#10;            # Terminator-like sequence&#10;            &quot;TTTTTTTTAAAAAAAAGGGGGGGGCCCCCCCC&quot;,&#10;            # Splice site-like sequences&#10;            &quot;GTAAGTATCGATCGATCGATCGCAG&quot;,&#10;            &quot;CTCGATCGATCGATCGATCGATCAG&quot;,&#10;            # Ribosome binding site&#10;            &quot;AGGAGGTTGACATGAAACGTCTAG&quot;,&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test mutation simulation (single nucleotide polymorphism)&#10;        result, exact = trie.search(&quot;ATGAAACGTCTAGCTAGCTAGCTAGCTAX&quot;, correction_budget=1)&#10;        assert result == &quot;ATGAAACGTCTAGCTAGCTAGCTAGCTAG&quot;&#10;        assert exact is False&#10;&#10;    def test_repetitive_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with highly repetitive DNA sequences&quot;&quot;&quot;&#10;        sequences = [&#10;            # Tandem repeats&#10;            &quot;CACACACACACACACACACACACACA&quot;,  # CA repeat&#10;            &quot;GTGTGTGTGTGTGTGTGTGTGTGTGT&quot;,  # GT repeat&#10;            &quot;ATATATATATATATATATATATATAT&quot;,  # AT repeat&#10;            &quot;CGCGCGCGCGCGCGCGCGCGCGCGCG&quot;,  # CG repeat&#10;            # Short tandem repeats (STRs)&#10;            &quot;AAGAAGAAGAAGAAGAAGAAGAAGAAG&quot;,  # AAG repeat&#10;            &quot;CTTCTTCTTCTTCTTCTTCTTCTTCTT&quot;,  # CTT repeat&#10;            # Palindromic sequences&#10;            &quot;GAATTCGAATTCGAATTCGAATTC&quot;,&#10;            &quot;GCTAGCGCTAGCGCTAGCGCTAGC&quot;,&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test with a shorter repetitive sequence for fuzzy matching&#10;        short_sequences = [&quot;CACA&quot;, &quot;GTGT&quot;, &quot;ATAT&quot;]&#10;        short_trie = PrefixTrie(short_sequences, allow_indels=True)&#10;&#10;        result, exact = short_trie.search(&quot;CACX&quot;, correction_budget=1)&#10;        assert result == &quot;CACA&quot;&#10;        assert exact is False&#10;&#10;    def test_mixed_length_dna_database(self):&#10;        &quot;&quot;&quot;Test with a mixed database of various length sequences&quot;&quot;&quot;&#10;        sequences = [&#10;            # Short sequences&#10;            &quot;ATCG&quot;, &quot;GCTA&quot;, &quot;TTAA&quot;, &quot;CCGG&quot;,&#10;            # Medium sequences&#10;            &quot;ATCGATCGATCGATCG&quot;, &quot;GCTAGCTAGCTAGCTA&quot;, &quot;TTAATTAATTAATTAA&quot;,&#10;            # Long sequences&#10;            &quot;ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG&quot;,&#10;            &quot;GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA&quot;,&#10;            # Very long sequence (500+ bases)&#10;            &quot;A&quot; * 100 + &quot;T&quot; * 100 + &quot;C&quot; * 100 + &quot;G&quot; * 100 + &quot;ATCG&quot; * 25,&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches for all lengths&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching across different lengths&#10;        result, exact = trie.search(&quot;ATCX&quot;, correction_budget=1)&#10;        assert result == &quot;ATCG&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;ATCGATCGATCGATCX&quot;, correction_budget=1)&#10;        assert result == &quot;ATCGATCGATCGATCG&quot;&#10;        assert exact is False&#10;&#10;    def test_dna_with_ambiguous_bases(self):&#10;        &quot;&quot;&quot;Test with sequences containing ambiguous DNA bases&quot;&quot;&quot;&#10;        sequences = [&#10;            &quot;ATCGNNNGATCG&quot;,  # N represents any base&#10;            &quot;RYSWKMBDHVRYSWKM&quot;,  # IUPAC ambiguous codes&#10;            &quot;ATCGWSATCGWS&quot;,  # W=A/T, S=G/C&#10;            &quot;MRYGATKBHDVM&quot;,  # Mixed ambiguous bases&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_codon_sequences(self):&#10;        &quot;&quot;&quot;Test with codon-based sequences (triplets)&quot;&quot;&quot;&#10;        # Common codons and their variations&#10;        sequences = [&#10;            &quot;ATGAAATTTCCCGGG&quot;,  # Start codon + amino acids&#10;            &quot;TTTTTCTTATTGCTG&quot;,  # Phenylalanine + Leucine codons&#10;            &quot;AAAAAGGATGACGAT&quot;,  # Lysine + Aspartic acid codons&#10;            &quot;TAATAGTAA&quot;,  # Stop codons&#10;            &quot;GGGGGAGGTGGA&quot;,  # Glycine codons&#10;            &quot;CCACCGCCACCCCCT&quot;,  # Proline codons&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test single codon mutations&#10;        result, exact = trie.search(&quot;ATGAAATTTCCCGGT&quot;, correction_budget=1)  # G-&gt;T in last codon&#10;        assert result == &quot;ATGAAATTTCCCGGG&quot;&#10;        assert exact is False&#10;&#10;    def test_extremely_long_sequences(self):&#10;        &quot;&quot;&quot;Test with extremely long DNA sequences (1000+ bases)&quot;&quot;&quot;&#10;        # Generate very long sequences&#10;        sequences = [&#10;            &quot;ATCG&quot; * 250,  # 1000 bases&#10;            &quot;GCTA&quot; * 300,  # 1200 bases&#10;            &quot;A&quot; * 500 + &quot;T&quot; * 500,  # 1000 bases, two halves&#10;            (&quot;ATCGATCGATCG&quot; * 100)[:1500],  # 1500 bases&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching with very long sequences&#10;        query = &quot;ATCG&quot; * 249 + &quot;ATCX&quot;  # 999 bases + ATCX&#10;        result, exact = trie.search(query, correction_budget=1)&#10;        assert result == &quot;ATCG&quot; * 250&#10;        assert exact is False&#10;&#10;    def test_dna_performance_benchmark(self):&#10;        &quot;&quot;&quot;Performance test with many DNA sequences&quot;&quot;&quot;&#10;        # Generate a large set of unique sequences&#10;        sequences = []&#10;        bases = &quot;ATCG&quot;&#10;&#10;        # 100 sequences of length 50 each&#10;        for i in range(100):&#10;            seq = &quot;&quot;&#10;            for j in range(50):&#10;                seq += bases[(i * 50 + j) % 4]&#10;            sequences.append(seq)&#10;&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test a subset for correctness&#10;        test_sequences = sequences[::10]  # Every 10th sequence&#10;        for seq in test_sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;&#10;class TestPrefixTrieErrorHandling:&#10;    &quot;&quot;&quot;Test error handling and edge cases&quot;&quot;&quot;&#10;&#10;    def test_invalid_correction_budget(self):&#10;        &quot;&quot;&quot;Test with negative correction budget&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;hello&quot;])&#10;&#10;        # Negative budget should be treated as 0&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=-1)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;class TestPrefixTrieAdvancedEdgeCases:&#10;    &quot;&quot;&quot;Test advanced edge cases and algorithm-specific scenarios&quot;&quot;&quot;&#10;&#10;    def test_insertion_and_deletion_operations(self):&#10;        &quot;&quot;&quot;Test specific insertion and deletion operations in fuzzy matching&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;, &quot;help&quot;, &quot;helicopter&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test insertions - query is shorter than target&#10;        result, exact = trie.search(&quot;hell&quot;, correction_budget=1)  # could be &quot;hello&quot; or &quot;help&quot; (both 1 edit)&#10;        assert result in [&quot;hello&quot;, &quot;help&quot;]  # Both are valid with 1 edit&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;hel&quot;, correction_budget=1)  # missing 'p' to make &quot;help&quot;&#10;        assert result == &quot;help&quot;&#10;        assert exact is False&#10;&#10;        # Test deletions - query is longer than target&#10;        result, exact = trie.search(&quot;helllo&quot;, correction_budget=1)  # extra 'l'&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;helpx&quot;, correction_budget=1)  # extra 'x'&#10;        assert result == &quot;help&quot;&#10;        assert exact is False&#10;&#10;        # Test substitutions&#10;        result, exact = trie.search(&quot;helo&quot;, correction_budget=1)  # 'o'-&gt;'p' substitution&#10;        assert result == &quot;help&quot;  # This is correct - only 1 edit needed&#10;        assert exact is False&#10;&#10;    def test_complex_indel_combinations(self):&#10;        &quot;&quot;&quot;Test combinations of insertions, deletions, and substitutions&quot;&quot;&quot;&#10;        entries = [&quot;algorithm&quot;, &quot;logarithm&quot;, &quot;rhythm&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Combination: deletion + substitution&#10;        result, exact = trie.search(&quot;algrothm&quot;, correction_budget=2)  # missing 'i', 'i'-&gt;'o'&#10;        assert result == &quot;algorithm&quot;&#10;        assert exact is False&#10;&#10;        # Combination: insertion + substitution&#10;        result, exact = trie.search(&quot;logxarithm&quot;, correction_budget=2)  # extra 'x', 'x'-&gt;'a'&#10;        assert result == &quot;logarithm&quot;&#10;        assert exact is False&#10;&#10;    def test_prefix_collision_scenarios(self):&#10;        &quot;&quot;&quot;Test scenarios where prefixes collide and could cause issues&quot;&quot;&quot;&#10;        entries = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;, &quot;aaaaa&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Exact matches should work&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Fuzzy matching should find closest match&#10;        result, exact = trie.search(&quot;aax&quot;, correction_budget=1)&#10;        assert result == &quot;aaa&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;aaax&quot;, correction_budget=1)&#10;        assert result == &quot;aaaa&quot;&#10;        assert exact is False&#10;&#10;    def test_shared_prefix_disambiguation(self):&#10;        &quot;&quot;&quot;Test disambiguation when multiple entries share long prefixes&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;programming&quot;, &quot;programmer&quot;, &quot;programmed&quot;, &quot;programmable&quot;,&#10;            &quot;program&quot;, &quot;programs&quot;, &quot;programmatic&quot;&#10;        ]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching with shared prefixes&#10;        result, exact = trie.search(&quot;programmin&quot;, correction_budget=1)  # missing 'g'&#10;        assert result == &quot;programming&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;programmerz&quot;, correction_budget=1)  # 'z' instead of final char&#10;        assert result == &quot;programmer&quot;&#10;        assert exact is False&#10;&#10;    def test_empty_and_very_short_queries(self):&#10;        &quot;&quot;&quot;Test behavior with empty and very short queries&quot;&quot;&quot;&#10;        entries = [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;hello&quot;, &quot;world&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Empty query&#10;        result, exact = trie.search(&quot;&quot;, correction_budget=0)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;&quot;, correction_budget=1)&#10;        assert result == &quot;a&quot;  # Should find shortest entry&#10;        assert exact is False&#10;&#10;        # Single character queries&#10;        result, exact = trie.search(&quot;x&quot;, correction_budget=1)&#10;        assert result == &quot;a&quot;  # Should find closest single char&#10;        assert exact is False&#10;&#10;    def test_correction_budget_edge_cases(self):&#10;        &quot;&quot;&quot;Test edge cases around correction budget limits&quot;&quot;&quot;&#10;        entries = [&quot;test&quot;, &quot;best&quot;, &quot;rest&quot;, &quot;nest&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Exact budget limit&#10;        result, exact = trie.search(&quot;zest&quot;, correction_budget=1)  # 'z'-&gt;'t', 'e'-&gt;'e', 's'-&gt;'s', 't'-&gt;'t'&#10;        assert result == &quot;test&quot;&#10;        assert exact is False&#10;&#10;        # Just over budget&#10;        result, exact = trie.search(&quot;zesz&quot;, correction_budget=1)  # needs 2 corrections&#10;        assert result is None&#10;        assert exact is False&#10;&#10;        # Zero budget should only find exact matches&#10;        result, exact = trie.search(&quot;test&quot;, correction_budget=0)&#10;        assert result == &quot;test&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;tesy&quot;, correction_budget=0)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_alphabet_boundary_conditions(self):&#10;        &quot;&quot;&quot;Test with characters at alphabet boundaries&quot;&quot;&quot;&#10;        entries = [&quot;aaa&quot;, &quot;zzz&quot;, &quot;AZaz&quot;, &quot;09azAZ&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching across character boundaries&#10;        result, exact = trie.search(&quot;aab&quot;, correction_budget=1)&#10;        assert result == &quot;aaa&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;zzy&quot;, correction_budget=1)&#10;        assert result == &quot;zzz&quot;&#10;        assert exact is False&#10;&#10;    def test_collapsed_path_edge_cases(self):&#10;        &quot;&quot;&quot;Test edge cases with collapsed paths in the trie&quot;&quot;&quot;&#10;        # Create entries that will cause path collapsing&#10;        entries = [&quot;abcdefghijk&quot;, &quot;abcdefghijl&quot;, &quot;xyz&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching that might interact with collapsed paths&#10;        result, exact = trie.search(&quot;abcdefghijx&quot;, correction_budget=1)  # Last char different&#10;        expected = &quot;abcdefghijk&quot;  # Should match first entry&#10;        assert result == expected&#10;        assert exact is False&#10;&#10;    def test_memory_intensive_operations(self):&#10;        &quot;&quot;&quot;Test operations that might stress memory management&quot;&quot;&quot;&#10;        # Create many similar entries&#10;        entries = [f&quot;pattern{i:03d}suffix&quot; for i in range(100)]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test a few random exact matches&#10;        test_entries = [entries[0], entries[50], entries[99]]&#10;        for entry in test_entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching&#10;        result, exact = trie.search(&quot;pattern050suffi&quot;, correction_budget=1)  # missing 'x'&#10;        assert result == &quot;pattern050suffix&quot;&#10;        assert exact is False&#10;&#10;    def test_very_high_correction_budget(self):&#10;        &quot;&quot;&quot;Test with very high correction budgets&quot;&quot;&quot;&#10;        entries = [&quot;short&quot;, &quot;verylongstring&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Very high budget should still work correctly&#10;        result, exact = trie.search(&quot;x&quot;, correction_budget=100)&#10;        assert result == &quot;short&quot;  # Should find shortest&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;completelydifferent&quot;, correction_budget=100)&#10;        assert result is not None  # Should find something&#10;        assert exact is False&#10;&#10;    def test_indel_vs_substitution_preference(self):&#10;        &quot;&quot;&quot;Test algorithm preference between indels and substitutions&quot;&quot;&quot;&#10;        entries = [&quot;abc&quot;, &quot;abcd&quot;, &quot;abce&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # This query could match &quot;abc&quot; with 1 deletion or &quot;abcd&quot;/&quot;abce&quot; with 1 substitution&#10;        result, exact = trie.search(&quot;abcx&quot;, correction_budget=1)&#10;        # The algorithm should prefer the substitution (keeping same length)&#10;        assert result in [&quot;abcd&quot;, &quot;abce&quot;]&#10;        assert exact is False&#10;&#10;    def test_multiple_valid_corrections(self):&#10;        &quot;&quot;&quot;Test scenarios where multiple corrections have same cost&quot;&quot;&quot;&#10;        entries = [&quot;cat&quot;, &quot;bat&quot;, &quot;hat&quot;, &quot;rat&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Query that's 1 edit away from multiple entries&#10;        result, exact = trie.search(&quot;dat&quot;, correction_budget=1)&#10;        assert result in entries  # Should find one of them&#10;        assert exact is False&#10;&#10;        # With higher budget, should still work&#10;        result, exact = trie.search(&quot;zat&quot;, correction_budget=1)&#10;        assert result in entries&#10;        assert exact is False&#10;&#10;    def test_nested_prefix_structures(self):&#10;        &quot;&quot;&quot;Test deeply nested prefix structures&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;, &quot;abcdef&quot;,&#10;            &quot;abcdeg&quot;, &quot;abcdeh&quot;, &quot;abcdei&quot;&#10;        ]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching at different depths&#10;        result, exact = trie.search(&quot;abcdej&quot;, correction_budget=1)&#10;        assert result in [&quot;abcdef&quot;, &quot;abcdeg&quot;, &quot;abcdeh&quot;, &quot;abcdei&quot;]&#10;        assert exact is False&#10;&#10;    def test_boundary_string_lengths(self):&#10;        &quot;&quot;&quot;Test with strings at various length boundaries&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;&quot;,  # This might not be supported, but let's test&#10;            &quot;x&quot;,  # Length 1&#10;            &quot;xy&quot;,  # Length 2&#10;            &quot;x&quot; * 10,  # Length 10&#10;            &quot;x&quot; * 100,  # Length 100&#10;            &quot;x&quot; * 255,  # Near byte boundary&#10;        ]&#10;&#10;        # Filter out empty string if not supported&#10;        try:&#10;            trie = PrefixTrie(entries, allow_indels=True)&#10;        except:&#10;            entries = entries[1:]  # Remove empty string&#10;            trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches for supported entries&#10;        for entry in entries:&#10;            if entry:  # Skip empty string&#10;                result, exact = trie.search(entry)&#10;                assert result == entry&#10;                assert exact is True&#10;&#10;    def test_cache_behavior_stress(self):&#10;        &quot;&quot;&quot;Test to stress the internal cache mechanisms&quot;&quot;&quot;&#10;        entries = [&quot;cache&quot;, &quot;caching&quot;, &quot;cached&quot;, &quot;caches&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Repeatedly search similar queries to stress cache&#10;        queries = [&quot;cachx&quot;, &quot;cachng&quot;, &quot;cachd&quot;, &quot;cachs&quot;, &quot;cach&quot;]&#10;&#10;        for _ in range(10):  # Repeat to test cache reuse&#10;            for query in queries:&#10;                result, exact = trie.search(query, correction_budget=2)&#10;                assert result is not None&#10;                assert exact is False&#10;&#10;class TestPrefixTrieAlgorithmCorrectness:&#10;    &quot;&quot;&quot;Test algorithm correctness for specific scenarios&quot;&quot;&quot;&#10;&#10;    def test_edit_distance_calculation(self):&#10;        &quot;&quot;&quot;Test that edit distances are calculated correctly&quot;&quot;&quot;&#10;        entries = [&quot;kitten&quot;, &quot;sitting&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # &quot;kitten&quot; -&gt; &quot;sitting&quot; requires 3 edits (k-&gt;s, e-&gt;i, insert g)&#10;        result, exact = trie.search(&quot;kitten&quot;, correction_budget=3)&#10;        assert result == &quot;kitten&quot;&#10;        assert exact is True&#10;&#10;        # Should not find &quot;sitting&quot; with budget of 2 (needs 3 edits)&#10;        result, exact = trie.search(&quot;sitting&quot;, correction_budget=2)&#10;        # This should find &quot;sitting&quot; exactly since it's in the trie&#10;        assert result == &quot;sitting&quot;&#10;        assert exact is True&#10;&#10;    def test_optimal_alignment_selection(self):&#10;        &quot;&quot;&quot;Test that the algorithm selects optimal alignments&quot;&quot;&quot;&#10;        entries = [&quot;ACGT&quot;, &quot;TGCA&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Query that could align different ways&#10;        result, exact = trie.search(&quot;ACGA&quot;, correction_budget=2)&#10;        assert result in [&quot;ACGT&quot;, &quot;TGCA&quot;]&#10;        assert exact is False&#10;&#10;    def test_backtracking_scenarios(self):&#10;        &quot;&quot;&quot;Test scenarios that might require backtracking in search&quot;&quot;&quot;&#10;        entries = [&quot;abcdef&quot;, &quot;abcxyz&quot;, &quot;defghi&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Query that shares prefix with multiple entries&#10;        result, exact = trie.search(&quot;abcxef&quot;, correction_budget=2)&#10;        assert result in [&quot;abcdef&quot;, &quot;abcxyz&quot;]&#10;        assert exact is False&#10;&#10;def generate_barcodes(n: int, length: int = 16) -&gt; list[str]:&#10;    &quot;&quot;&quot;Generate `n` deterministic barcodes of given length&quot;&quot;&quot;&#10;    bases = &quot;ACGT&quot;&#10;    barcodes = []&#10;    for i in range(n):&#10;        seq = []&#10;        num = i&#10;        for _ in range(length):&#10;            seq.append(bases[num &amp; 3])&#10;            num &gt;&gt;= 2&#10;        barcodes.append(&quot;&quot;.join(seq))&#10;    return barcodes&#10;&#10;&#10;class TestLargeWhitelist:&#10;&#10;    def test_thousands_of_barcodes(self):&#10;        # Generate 10k deterministic 16bp barcodes&#10;        barcodes = generate_barcodes(10000)&#10;        trie = PrefixTrie(barcodes, allow_indels=True)&#10;&#10;        # Spot check a few barcodes for exact match&#10;        samples = [barcodes[0], barcodes[123], barcodes[9999], barcodes[5000], barcodes[7777]]&#10;        for bc in samples:&#10;            result, exact = trie.search(bc)&#10;            assert result == bc&#10;            assert exact is True&#10;&#10;        # Mutate a high-order position to ensure it is not already in whitelist&#10;        for idx, pos in [(42, 12), (123, 8), (9999, 15), (5000, 0), (7777, 5)]:&#10;            original = barcodes[idx]&#10;            replacement = &quot;A&quot; if original[pos] != &quot;A&quot; else &quot;C&quot;&#10;            mutated = original[:pos] + replacement + original[pos + 1:]&#10;            if mutated in barcodes:&#10;                continue  # Skip if mutated barcode is already in whitelist&#10;            result, exact = trie.search(mutated, correction_budget=1)&#10;            assert result == original&#10;            assert exact is False&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Run a quick smoke test&#10;    print(&quot;Running smoke test...&quot;)&#10;&#10;    # Basic functionality test&#10;    trie = PrefixTrie([&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;])&#10;    result, exact = trie.search(&quot;hello&quot;)&#10;    assert result == &quot;hello&quot; and exact is True&#10;&#10;    # Fuzzy matching test&#10;    trie_fuzzy = PrefixTrie([&quot;hello&quot;], allow_indels=True)&#10;    result, exact = trie_fuzzy.search(&quot;hllo&quot;, correction_budget=1)&#10;    assert result == &quot;hello&quot; and exact is False&#10;&#10;    print(&quot;Smoke test passed! Run 'pytest test.py' for full test suite.&quot;)&#10;" />
              <option name="updatedContent" value="import pytest&#10;import pyximport&#10;pyximport.install()&#10;from prefixtrie import PrefixTrie&#10;&#10;&#10;class TestPrefixTrieBasic:&#10;    &quot;&quot;&quot;Test basic functionality of PrefixTrie&quot;&quot;&quot;&#10;&#10;    def test_empty_trie(self):&#10;        &quot;&quot;&quot;Test creating an empty trie&quot;&quot;&quot;&#10;        trie = PrefixTrie([])&#10;        result, exact = trie.search(&quot;test&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;        # Searching for an empty string in an empty trie should not report an&#10;        # exact match.&#10;        result, exact = trie.search(&quot;&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_single_entry(self):&#10;        &quot;&quot;&quot;Test trie with single entry&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;hello&quot;])&#10;&#10;        # Exact match&#10;        result, exact = trie.search(&quot;hello&quot;)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is True&#10;&#10;        # No match&#10;        result, exact = trie.search(&quot;world&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_multiple_entries(self):&#10;        &quot;&quot;&quot;Test trie with multiple entries&quot;&quot;&quot;&#10;        entries = [&quot;cat&quot;, &quot;car&quot;, &quot;card&quot;, &quot;care&quot;, &quot;careful&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;    def test_trailing_and_missing_characters(self):&#10;        &quot;&quot;&quot;Ensure extra or missing characters are handled with indels&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Extra character at the end should count as a deletion&#10;        result, exact = trie.search(&quot;hello!&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        # Missing character should be handled as an insertion&#10;        result, exact = trie.search(&quot;hell&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;    def test_prefix_matching(self):&#10;        &quot;&quot;&quot;Test prefix-based matching&quot;&quot;&quot;&#10;        entries = [&quot;test&quot;, &quot;testing&quot;, &quot;tester&quot;, &quot;tea&quot;, &quot;team&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        # Test exact matches for complete entries&#10;        result, exact = trie.search(&quot;test&quot;)&#10;        assert result == &quot;test&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;tea&quot;)&#10;        assert result == &quot;tea&quot;&#10;        assert exact is True&#10;&#10;        # Test that partial prefixes don't match without fuzzy search&#10;        result, exact = trie.search(&quot;te&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;&#10;class TestPrefixTrieEdgeCases:&#10;    &quot;&quot;&quot;Test edge cases and special characters&quot;&quot;&quot;&#10;&#10;    def test_empty_string_entry(self):&#10;        &quot;&quot;&quot;Test with empty string in entries&quot;&quot;&quot;&#10;        # Empty strings may not be supported by this trie implementation&#10;        trie = PrefixTrie([&quot;hello&quot;, &quot;world&quot;])&#10;&#10;        result, exact = trie.search(&quot;&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_single_character_entries(self):&#10;        &quot;&quot;&quot;Test with single character entries&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;])&#10;&#10;        result, exact = trie.search(&quot;a&quot;)&#10;        assert result == &quot;a&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;d&quot;)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_duplicate_entries(self):&#10;        &quot;&quot;&quot;Test with duplicate entries&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;hello&quot;, &quot;hello&quot;, &quot;world&quot;])&#10;&#10;        result, exact = trie.search(&quot;hello&quot;)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is True&#10;&#10;    def test_special_characters(self):&#10;        &quot;&quot;&quot;Test with special characters&quot;&quot;&quot;&#10;        entries = [&quot;hello!&quot;, &quot;test@123&quot;, &quot;a-b-c&quot;, &quot;x_y_z&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;    def test_case_sensitivity(self):&#10;        &quot;&quot;&quot;Test case sensitivity&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;Hello&quot;, &quot;hello&quot;, &quot;HELLO&quot;])&#10;&#10;        result, exact = trie.search(&quot;Hello&quot;)&#10;        assert result == &quot;Hello&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;hello&quot;)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;HELLO&quot;)&#10;        assert result == &quot;HELLO&quot;&#10;        assert exact is True&#10;&#10;    def test_budget_increase_recomputes(self):&#10;        trie = PrefixTrie([&quot;hello&quot;], allow_indels=True)&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=0)&#10;        assert result is None and exact is False&#10;&#10;        # With more corrections available, the match should now succeed&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot; and exact is False&#10;&#10;class TestPrefixTrieFuzzyMatching:&#10;    &quot;&quot;&quot;Test fuzzy matching capabilities&quot;&quot;&quot;&#10;&#10;    def test_basic_fuzzy_matching(self):&#10;        &quot;&quot;&quot;Test basic fuzzy matching with corrections&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;, &quot;world&quot;, &quot;python&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=False)&#10;&#10;        # Test with 1 correction budget - single character substitution&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)  # e-&gt;a substitution&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;worle&quot;, correction_budget=1)  # d-&gt;e substitution&#10;        assert result == &quot;world&quot;&#10;        assert exact is False&#10;&#10;    def test_fuzzy_matching_with_indels(self):&#10;        &quot;&quot;&quot;Test fuzzy matching with insertions and deletions&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;, &quot;world&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test simple substitution that should work&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=1)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        # Test that we can find matches with small edits&#10;        result, exact = trie.search(&quot;worlx&quot;, correction_budget=1)&#10;        assert result == &quot;world&quot;&#10;        assert exact is False&#10;&#10;    def test_correction_budget_limits(self):&#10;        &quot;&quot;&quot;Test that correction budget is respected&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Should find with budget of 2&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=2)&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        # Should not find with budget of 0&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=0)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_multiple_corrections(self):&#10;        &quot;&quot;&quot;Test queries requiring multiple corrections&quot;&quot;&quot;&#10;        entries = [&quot;testing&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Two substitutions&#10;        result, exact = trie.search(&quot;taxting&quot;, correction_budget=2)&#10;        assert result == &quot;testing&quot;&#10;        assert exact is False&#10;&#10;        # Should not find with insufficient budget&#10;        result, exact = trie.search(&quot;taxting&quot;, correction_budget=1)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;&#10;class TestPrefixTriePerformance:&#10;    &quot;&quot;&quot;Test performance-related scenarios&quot;&quot;&quot;&#10;&#10;    def test_large_alphabet(self):&#10;        &quot;&quot;&quot;Test with entries using large character set&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;abcdefghijklmnopqrstuvwxyz&quot;,&#10;            &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;,&#10;            &quot;0123456789&quot;,&#10;            &quot;!@#$%^&amp;*()_+-=&quot;&#10;        ]&#10;        trie = PrefixTrie(entries)&#10;&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;    def test_long_strings(self):&#10;        &quot;&quot;&quot;Test with very long strings&quot;&quot;&quot;&#10;        long_string = &quot;a&quot; * 1000&#10;        entries = [long_string, long_string + &quot;b&quot;]&#10;        trie = PrefixTrie(entries)&#10;&#10;        result, exact = trie.search(long_string)&#10;        assert result == long_string&#10;        assert exact is True&#10;&#10;    def test_many_entries(self):&#10;        &quot;&quot;&quot;Test with many entries&quot;&quot;&quot;&#10;        entries = [f&quot;entry_{i:04d}&quot; for i in range(1000)]&#10;        trie = PrefixTrie(entries)&#10;&#10;        # Test a few random entries&#10;        test_entries = [entries[0], entries[500], entries[999]]&#10;        for entry in test_entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;&#10;class TestPrefixTrieDNASequences:&#10;    &quot;&quot;&quot;Test with DNA-like sequences (similar to the original test)&quot;&quot;&quot;&#10;&#10;    def test_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with DNA sequences&quot;&quot;&quot;&#10;        sequences = [&quot;ACGT&quot;, &quot;TCGA&quot;, &quot;AAAA&quot;, &quot;TTTT&quot;, &quot;CCCC&quot;, &quot;GGGG&quot;]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_dna_fuzzy_matching(self):&#10;        &quot;&quot;&quot;Test fuzzy matching with DNA sequences&quot;&quot;&quot;&#10;        sequences = [&quot;ACGT&quot;, &quot;TCGA&quot;]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Single base substitution&#10;        result, exact = trie.search(&quot;ACCT&quot;, correction_budget=1)&#10;        assert result == &quot;ACGT&quot;&#10;        assert exact is False&#10;&#10;        # Test with a clear mismatch that requires correction&#10;        result, exact = trie.search(&quot;ACXX&quot;, correction_budget=2)&#10;        assert result == &quot;ACGT&quot;&#10;        assert exact is False&#10;&#10;        # Test that fuzzy matching works with sufficient budget&#10;        result, exact = trie.search(&quot;TCXX&quot;, correction_budget=2)&#10;        assert result == &quot;TCGA&quot;&#10;        assert exact is False&#10;&#10;    def test_similar_sequences(self):&#10;        &quot;&quot;&quot;Test with very similar sequences&quot;&quot;&quot;&#10;        sequences = [&quot;ATCG&quot;, &quot;ATCGA&quot;, &quot;ATCGAA&quot;, &quot;ATCGAAA&quot;]&#10;        trie = PrefixTrie(sequences)&#10;&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_medium_length_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with medium-length DNA sequences (20-50 bases)&quot;&quot;&quot;&#10;        sequences = [&#10;            &quot;ATCGATCGATCGATCGATCG&quot;,  # 20 bases&#10;            &quot;GCTAGCTAGCTAGCTAGCTAGCTA&quot;,  # 23 bases&#10;            &quot;AAATTTCCCGGGAAATTTCCCGGGAAATTT&quot;,  # 29 bases&#10;            &quot;TCGATCGATCGATCGATCGATCGATCGATCG&quot;,  # 30 bases&#10;            &quot;AGCTTAGCTTAGCTTAGCTTAGCTTAGCTTAGCTTA&quot;,  # 35 bases&#10;            &quot;CGTACGTACGTACGTACGTACGTACGTACGTACGTACGTA&quot;,  # 39 bases&#10;            &quot;TTAATTAATTAATTAATTAATTAATTAATTAATTAATTAATTAA&quot;,  # 43 bases&#10;            &quot;GCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCGGCCG&quot;  # 45 bases&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching with single substitution&#10;        result, exact = trie.search(&quot;ATCGATCGATCGATCGATCX&quot;, correction_budget=1)&#10;        assert result == &quot;ATCGATCGATCGATCGATCG&quot;&#10;        assert exact is False&#10;&#10;    def test_long_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with long DNA sequences (100+ bases)&quot;&quot;&quot;&#10;        sequences = [&#10;            # 100 base sequence&#10;            &quot;ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG&quot;,&#10;            # 120 base sequence&#10;            &quot;GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA&quot;,&#10;            # 150 base sequence with more variety&#10;            &quot;AAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGGAAATTTCCCGGG&quot;,&#10;            # 200 base sequence&#10;            &quot;TCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG&quot;&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_realistic_gene_sequences(self):&#10;        &quot;&quot;&quot;Test with realistic gene-like sequences&quot;&quot;&quot;&#10;        # Simulated gene sequences with typical biological patterns&#10;        sequences = [&#10;            # Start codon (ATG) followed by coding sequence&#10;            &quot;ATGAAACGTCTAGCTAGCTAGCTAGCTAG&quot;,&#10;            # Promoter-like sequence&#10;            &quot;TATAAAAGGCCGCTCGAGCTCGAGCTCGA&quot;,&#10;            # Enhancer-like sequence&#10;            &quot;GCGCGCGCATATATATGCGCGCGCATATA&quot;,&#10;            # Terminator-like sequence&#10;            &quot;TTTTTTTTAAAAAAAAGGGGGGGGCCCCCCCC&quot;,&#10;            # Splice site-like sequences&#10;            &quot;GTAAGTATCGATCGATCGATCGCAG&quot;,&#10;            &quot;CTCGATCGATCGATCGATCGATCAG&quot;,&#10;            # Ribosome binding site&#10;            &quot;AGGAGGTTGACATGAAACGTCTAG&quot;,&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test mutation simulation (single nucleotide polymorphism)&#10;        result, exact = trie.search(&quot;ATGAAACGTCTAGCTAGCTAGCTAGCTAX&quot;, correction_budget=1)&#10;        assert result == &quot;ATGAAACGTCTAGCTAGCTAGCTAGCTAG&quot;&#10;        assert exact is False&#10;&#10;    def test_repetitive_dna_sequences(self):&#10;        &quot;&quot;&quot;Test with highly repetitive DNA sequences&quot;&quot;&quot;&#10;        sequences = [&#10;            # Tandem repeats&#10;            &quot;CACACACACACACACACACACACACA&quot;,  # CA repeat&#10;            &quot;GTGTGTGTGTGTGTGTGTGTGTGTGT&quot;,  # GT repeat&#10;            &quot;ATATATATATATATATATATATATAT&quot;,  # AT repeat&#10;            &quot;CGCGCGCGCGCGCGCGCGCGCGCGCG&quot;,  # CG repeat&#10;            # Short tandem repeats (STRs)&#10;            &quot;AAGAAGAAGAAGAAGAAGAAGAAGAAG&quot;,  # AAG repeat&#10;            &quot;CTTCTTCTTCTTCTTCTTCTTCTTCTT&quot;,  # CTT repeat&#10;            # Palindromic sequences&#10;            &quot;GAATTCGAATTCGAATTCGAATTC&quot;,&#10;            &quot;GCTAGCGCTAGCGCTAGCGCTAGC&quot;,&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test with a shorter repetitive sequence for fuzzy matching&#10;        short_sequences = [&quot;CACA&quot;, &quot;GTGT&quot;, &quot;ATAT&quot;]&#10;        short_trie = PrefixTrie(short_sequences, allow_indels=True)&#10;&#10;        result, exact = short_trie.search(&quot;CACX&quot;, correction_budget=1)&#10;        assert result == &quot;CACA&quot;&#10;        assert exact is False&#10;&#10;    def test_mixed_length_dna_database(self):&#10;        &quot;&quot;&quot;Test with a mixed database of various length sequences&quot;&quot;&quot;&#10;        sequences = [&#10;            # Short sequences&#10;            &quot;ATCG&quot;, &quot;GCTA&quot;, &quot;TTAA&quot;, &quot;CCGG&quot;,&#10;            # Medium sequences&#10;            &quot;ATCGATCGATCGATCG&quot;, &quot;GCTAGCTAGCTAGCTA&quot;, &quot;TTAATTAATTAATTAA&quot;,&#10;            # Long sequences&#10;            &quot;ATCGATCGATCGATCGATCGATCGATCGATCGATCGATCGATCG&quot;,&#10;            &quot;GCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTAGCTA&quot;,&#10;            # Very long sequence (500+ bases)&#10;            &quot;A&quot; * 100 + &quot;T&quot; * 100 + &quot;C&quot; * 100 + &quot;G&quot; * 100 + &quot;ATCG&quot; * 25,&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches for all lengths&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching across different lengths&#10;        result, exact = trie.search(&quot;ATCX&quot;, correction_budget=1)&#10;        assert result == &quot;ATCG&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;ATCGATCGATCGATCX&quot;, correction_budget=1)&#10;        assert result == &quot;ATCGATCGATCGATCG&quot;&#10;        assert exact is False&#10;&#10;    def test_dna_with_ambiguous_bases(self):&#10;        &quot;&quot;&quot;Test with sequences containing ambiguous DNA bases&quot;&quot;&quot;&#10;        sequences = [&#10;            &quot;ATCGNNNGATCG&quot;,  # N represents any base&#10;            &quot;RYSWKMBDHVRYSWKM&quot;,  # IUPAC ambiguous codes&#10;            &quot;ATCGWSATCGWS&quot;,  # W=A/T, S=G/C&#10;            &quot;MRYGATKBHDVM&quot;,  # Mixed ambiguous bases&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;    def test_codon_sequences(self):&#10;        &quot;&quot;&quot;Test with codon-based sequences (triplets)&quot;&quot;&quot;&#10;        # Common codons and their variations&#10;        sequences = [&#10;            &quot;ATGAAATTTCCCGGG&quot;,  # Start codon + amino acids&#10;            &quot;TTTTTCTTATTGCTG&quot;,  # Phenylalanine + Leucine codons&#10;            &quot;AAAAAGGATGACGAT&quot;,  # Lysine + Aspartic acid codons&#10;            &quot;TAATAGTAA&quot;,  # Stop codons&#10;            &quot;GGGGGAGGTGGA&quot;,  # Glycine codons&#10;            &quot;CCACCGCCACCCCCT&quot;,  # Proline codons&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test single codon mutations&#10;        result, exact = trie.search(&quot;ATGAAATTTCCCGGT&quot;, correction_budget=1)  # G-&gt;T in last codon&#10;        assert result == &quot;ATGAAATTTCCCGGG&quot;&#10;        assert exact is False&#10;&#10;    def test_extremely_long_sequences(self):&#10;        &quot;&quot;&quot;Test with extremely long DNA sequences (1000+ bases)&quot;&quot;&quot;&#10;        # Generate very long sequences&#10;        sequences = [&#10;            &quot;ATCG&quot; * 250,  # 1000 bases&#10;            &quot;GCTA&quot; * 300,  # 1200 bases&#10;            &quot;A&quot; * 500 + &quot;T&quot; * 500,  # 1000 bases, two halves&#10;            (&quot;ATCGATCGATCG&quot; * 100)[:1500],  # 1500 bases&#10;        ]&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for seq in sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching with very long sequences&#10;        query = &quot;ATCG&quot; * 249 + &quot;ATCX&quot;  # 999 bases + ATCX&#10;        result, exact = trie.search(query, correction_budget=1)&#10;        assert result == &quot;ATCG&quot; * 250&#10;        assert exact is False&#10;&#10;    def test_dna_performance_benchmark(self):&#10;        &quot;&quot;&quot;Performance test with many DNA sequences&quot;&quot;&quot;&#10;        # Generate a large set of unique sequences&#10;        sequences = []&#10;        bases = &quot;ATCG&quot;&#10;&#10;        # 100 sequences of length 50 each&#10;        for i in range(100):&#10;            seq = &quot;&quot;&#10;            for j in range(50):&#10;                seq += bases[(i * 50 + j) % 4]&#10;            sequences.append(seq)&#10;&#10;        trie = PrefixTrie(sequences, allow_indels=True)&#10;&#10;        # Test a subset for correctness&#10;        test_sequences = sequences[::10]  # Every 10th sequence&#10;        for seq in test_sequences:&#10;            result, exact = trie.search(seq)&#10;            assert result == seq&#10;            assert exact is True&#10;&#10;&#10;class TestPrefixTrieDunderMethods:&#10;    &quot;&quot;&quot;Test dunder methods of PrefixTrie&quot;&quot;&quot;&#10;&#10;    def test_contains(self):&#10;        trie = PrefixTrie([&quot;foo&quot;, &quot;bar&quot;])&#10;        assert &quot;foo&quot; in trie&#10;        assert &quot;bar&quot; in trie&#10;        assert &quot;baz&quot; not in trie&#10;&#10;    def test_iter(self):&#10;        entries = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]&#10;        trie = PrefixTrie(entries)&#10;        assert set(iter(trie)) == set(entries)&#10;&#10;    def test_len(self):&#10;        entries = [&quot;x&quot;, &quot;y&quot;, &quot;z&quot;]&#10;        trie = PrefixTrie(entries)&#10;        assert len(trie) == 3&#10;        empty_trie = PrefixTrie([])&#10;        assert len(empty_trie) == 0&#10;&#10;    def test_getitem(self):&#10;        trie = PrefixTrie([&quot;alpha&quot;, &quot;beta&quot;])&#10;        assert trie[&quot;alpha&quot;] == &quot;alpha&quot;&#10;        assert trie[&quot;beta&quot;] == &quot;beta&quot;&#10;        with pytest.raises(KeyError):&#10;            _ = trie[&quot;gamma&quot;]&#10;&#10;    def test_repr_and_str(self):&#10;        trie = PrefixTrie([&quot;one&quot;, &quot;two&quot;], allow_indels=True)&#10;        r = repr(trie)&#10;        s = str(trie)&#10;        assert &quot;PrefixTrie&quot; in r&#10;        assert &quot;PrefixTrie&quot; in s&#10;        assert &quot;allow_indels=True&quot; in r&#10;        assert &quot;allow_indels=True&quot; in s&#10;&#10;&#10;class TestPrefixTrieErrorHandling:&#10;    &quot;&quot;&quot;Test error handling and edge cases&quot;&quot;&quot;&#10;&#10;    def test_invalid_correction_budget(self):&#10;        &quot;&quot;&quot;Test with negative correction budget&quot;&quot;&quot;&#10;        trie = PrefixTrie([&quot;hello&quot;])&#10;&#10;        # Negative budget should be treated as 0&#10;        result, exact = trie.search(&quot;hallo&quot;, correction_budget=-1)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;class TestPrefixTrieAdvancedEdgeCases:&#10;    &quot;&quot;&quot;Test advanced edge cases and algorithm-specific scenarios&quot;&quot;&quot;&#10;&#10;    def test_insertion_and_deletion_operations(self):&#10;        &quot;&quot;&quot;Test specific insertion and deletion operations in fuzzy matching&quot;&quot;&quot;&#10;        entries = [&quot;hello&quot;, &quot;help&quot;, &quot;helicopter&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test insertions - query is shorter than target&#10;        result, exact = trie.search(&quot;hell&quot;, correction_budget=1)  # could be &quot;hello&quot; or &quot;help&quot; (both 1 edit)&#10;        assert result in [&quot;hello&quot;, &quot;help&quot;]  # Both are valid with 1 edit&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;hel&quot;, correction_budget=1)  # missing 'p' to make &quot;help&quot;&#10;        assert result == &quot;help&quot;&#10;        assert exact is False&#10;&#10;        # Test deletions - query is longer than target&#10;        result, exact = trie.search(&quot;helllo&quot;, correction_budget=1)  # extra 'l'&#10;        assert result == &quot;hello&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;helpx&quot;, correction_budget=1)  # extra 'x'&#10;        assert result == &quot;help&quot;&#10;        assert exact is False&#10;&#10;        # Test substitutions&#10;        result, exact = trie.search(&quot;helo&quot;, correction_budget=1)  # 'o'-&gt;'p' substitution&#10;        assert result == &quot;help&quot;  # This is correct - only 1 edit needed&#10;        assert exact is False&#10;&#10;    def test_complex_indel_combinations(self):&#10;        &quot;&quot;&quot;Test combinations of insertions, deletions, and substitutions&quot;&quot;&quot;&#10;        entries = [&quot;algorithm&quot;, &quot;logarithm&quot;, &quot;rhythm&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Combination: deletion + substitution&#10;        result, exact = trie.search(&quot;algrothm&quot;, correction_budget=2)  # missing 'i', 'i'-&gt;'o'&#10;        assert result == &quot;algorithm&quot;&#10;        assert exact is False&#10;&#10;        # Combination: insertion + substitution&#10;        result, exact = trie.search(&quot;logxarithm&quot;, correction_budget=2)  # extra 'x', 'x'-&gt;'a'&#10;        assert result == &quot;logarithm&quot;&#10;        assert exact is False&#10;&#10;    def test_prefix_collision_scenarios(self):&#10;        &quot;&quot;&quot;Test scenarios where prefixes collide and could cause issues&quot;&quot;&quot;&#10;        entries = [&quot;a&quot;, &quot;aa&quot;, &quot;aaa&quot;, &quot;aaaa&quot;, &quot;aaaaa&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Exact matches should work&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Fuzzy matching should find closest match&#10;        result, exact = trie.search(&quot;aax&quot;, correction_budget=1)&#10;        assert result == &quot;aaa&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;aaax&quot;, correction_budget=1)&#10;        assert result == &quot;aaaa&quot;&#10;        assert exact is False&#10;&#10;    def test_shared_prefix_disambiguation(self):&#10;        &quot;&quot;&quot;Test disambiguation when multiple entries share long prefixes&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;programming&quot;, &quot;programmer&quot;, &quot;programmed&quot;, &quot;programmable&quot;,&#10;            &quot;program&quot;, &quot;programs&quot;, &quot;programmatic&quot;&#10;        ]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching with shared prefixes&#10;        result, exact = trie.search(&quot;programmin&quot;, correction_budget=1)  # missing 'g'&#10;        assert result == &quot;programming&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;programmerz&quot;, correction_budget=1)  # 'z' instead of final char&#10;        assert result == &quot;programmer&quot;&#10;        assert exact is False&#10;&#10;    def test_empty_and_very_short_queries(self):&#10;        &quot;&quot;&quot;Test behavior with empty and very short queries&quot;&quot;&quot;&#10;        entries = [&quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;hello&quot;, &quot;world&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Empty query&#10;        result, exact = trie.search(&quot;&quot;, correction_budget=0)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;&quot;, correction_budget=1)&#10;        assert result == &quot;a&quot;  # Should find shortest entry&#10;        assert exact is False&#10;&#10;        # Single character queries&#10;        result, exact = trie.search(&quot;x&quot;, correction_budget=1)&#10;        assert result == &quot;a&quot;  # Should find closest single char&#10;        assert exact is False&#10;&#10;    def test_correction_budget_edge_cases(self):&#10;        &quot;&quot;&quot;Test edge cases around correction budget limits&quot;&quot;&quot;&#10;        entries = [&quot;test&quot;, &quot;best&quot;, &quot;rest&quot;, &quot;nest&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Exact budget limit&#10;        result, exact = trie.search(&quot;zest&quot;, correction_budget=1)  # 'z'-&gt;'t', 'e'-&gt;'e', 's'-&gt;'s', 't'-&gt;'t'&#10;        assert result == &quot;test&quot;&#10;        assert exact is False&#10;&#10;        # Just over budget&#10;        result, exact = trie.search(&quot;zesz&quot;, correction_budget=1)  # needs 2 corrections&#10;        assert result is None&#10;        assert exact is False&#10;&#10;        # Zero budget should only find exact matches&#10;        result, exact = trie.search(&quot;test&quot;, correction_budget=0)&#10;        assert result == &quot;test&quot;&#10;        assert exact is True&#10;&#10;        result, exact = trie.search(&quot;tesy&quot;, correction_budget=0)&#10;        assert result is None&#10;        assert exact is False&#10;&#10;    def test_alphabet_boundary_conditions(self):&#10;        &quot;&quot;&quot;Test with characters at alphabet boundaries&quot;&quot;&quot;&#10;        entries = [&quot;aaa&quot;, &quot;zzz&quot;, &quot;AZaz&quot;, &quot;09azAZ&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching across character boundaries&#10;        result, exact = trie.search(&quot;aab&quot;, correction_budget=1)&#10;        assert result == &quot;aaa&quot;&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;zzy&quot;, correction_budget=1)&#10;        assert result == &quot;zzz&quot;&#10;        assert exact is False&#10;&#10;    def test_collapsed_path_edge_cases(self):&#10;        &quot;&quot;&quot;Test edge cases with collapsed paths in the trie&quot;&quot;&quot;&#10;        # Create entries that will cause path collapsing&#10;        entries = [&quot;abcdefghijk&quot;, &quot;abcdefghijl&quot;, &quot;xyz&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching that might interact with collapsed paths&#10;        result, exact = trie.search(&quot;abcdefghijx&quot;, correction_budget=1)  # Last char different&#10;        expected = &quot;abcdefghijk&quot;  # Should match first entry&#10;        assert result == expected&#10;        assert exact is False&#10;&#10;    def test_memory_intensive_operations(self):&#10;        &quot;&quot;&quot;Test operations that might stress memory management&quot;&quot;&quot;&#10;        # Create many similar entries&#10;        entries = [f&quot;pattern{i:03d}suffix&quot; for i in range(100)]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test a few random exact matches&#10;        test_entries = [entries[0], entries[50], entries[99]]&#10;        for entry in test_entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching&#10;        result, exact = trie.search(&quot;pattern050suffi&quot;, correction_budget=1)  # missing 'x'&#10;        assert result == &quot;pattern050suffix&quot;&#10;        assert exact is False&#10;&#10;    def test_very_high_correction_budget(self):&#10;        &quot;&quot;&quot;Test with very high correction budgets&quot;&quot;&quot;&#10;        entries = [&quot;short&quot;, &quot;verylongstring&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Very high budget should still work correctly&#10;        result, exact = trie.search(&quot;x&quot;, correction_budget=100)&#10;        assert result == &quot;short&quot;  # Should find shortest&#10;        assert exact is False&#10;&#10;        result, exact = trie.search(&quot;completelydifferent&quot;, correction_budget=100)&#10;        assert result is not None  # Should find something&#10;        assert exact is False&#10;&#10;    def test_indel_vs_substitution_preference(self):&#10;        &quot;&quot;&quot;Test algorithm preference between indels and substitutions&quot;&quot;&quot;&#10;        entries = [&quot;abc&quot;, &quot;abcd&quot;, &quot;abce&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # This query could match &quot;abc&quot; with 1 deletion or &quot;abcd&quot;/&quot;abce&quot; with 1 substitution&#10;        result, exact = trie.search(&quot;abcx&quot;, correction_budget=1)&#10;        # The algorithm should prefer the substitution (keeping same length)&#10;        assert result in [&quot;abcd&quot;, &quot;abce&quot;]&#10;        assert exact is False&#10;&#10;    def test_multiple_valid_corrections(self):&#10;        &quot;&quot;&quot;Test scenarios where multiple corrections have same cost&quot;&quot;&quot;&#10;        entries = [&quot;cat&quot;, &quot;bat&quot;, &quot;hat&quot;, &quot;rat&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Query that's 1 edit away from multiple entries&#10;        result, exact = trie.search(&quot;dat&quot;, correction_budget=1)&#10;        assert result in entries  # Should find one of them&#10;        assert exact is False&#10;&#10;        # With higher budget, should still work&#10;        result, exact = trie.search(&quot;zat&quot;, correction_budget=1)&#10;        assert result in entries&#10;        assert exact is False&#10;&#10;    def test_nested_prefix_structures(self):&#10;        &quot;&quot;&quot;Test deeply nested prefix structures&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;a&quot;, &quot;ab&quot;, &quot;abc&quot;, &quot;abcd&quot;, &quot;abcde&quot;, &quot;abcdef&quot;,&#10;            &quot;abcdeg&quot;, &quot;abcdeh&quot;, &quot;abcdei&quot;&#10;        ]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches&#10;        for entry in entries:&#10;            result, exact = trie.search(entry)&#10;            assert result == entry&#10;            assert exact is True&#10;&#10;        # Test fuzzy matching at different depths&#10;        result, exact = trie.search(&quot;abcdej&quot;, correction_budget=1)&#10;        assert result in [&quot;abcdef&quot;, &quot;abcdeg&quot;, &quot;abcdeh&quot;, &quot;abcdei&quot;]&#10;        assert exact is False&#10;&#10;    def test_boundary_string_lengths(self):&#10;        &quot;&quot;&quot;Test with strings at various length boundaries&quot;&quot;&quot;&#10;        entries = [&#10;            &quot;&quot;,  # This might not be supported, but let's test&#10;            &quot;x&quot;,  # Length 1&#10;            &quot;xy&quot;,  # Length 2&#10;            &quot;x&quot; * 10,  # Length 10&#10;            &quot;x&quot; * 100,  # Length 100&#10;            &quot;x&quot; * 255,  # Near byte boundary&#10;        ]&#10;&#10;        # Filter out empty string if not supported&#10;        try:&#10;            trie = PrefixTrie(entries, allow_indels=True)&#10;        except:&#10;            entries = entries[1:]  # Remove empty string&#10;            trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Test exact matches for supported entries&#10;        for entry in entries:&#10;            if entry:  # Skip empty string&#10;                result, exact = trie.search(entry)&#10;                assert result == entry&#10;                assert exact is True&#10;&#10;    def test_cache_behavior_stress(self):&#10;        &quot;&quot;&quot;Test to stress the internal cache mechanisms&quot;&quot;&quot;&#10;        entries = [&quot;cache&quot;, &quot;caching&quot;, &quot;cached&quot;, &quot;caches&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Repeatedly search similar queries to stress cache&#10;        queries = [&quot;cachx&quot;, &quot;cachng&quot;, &quot;cachd&quot;, &quot;cachs&quot;, &quot;cach&quot;]&#10;&#10;        for _ in range(10):  # Repeat to test cache reuse&#10;            for query in queries:&#10;                result, exact = trie.search(query, correction_budget=2)&#10;                assert result is not None&#10;                assert exact is False&#10;&#10;class TestPrefixTrieAlgorithmCorrectness:&#10;    &quot;&quot;&quot;Test algorithm correctness for specific scenarios&quot;&quot;&quot;&#10;&#10;    def test_edit_distance_calculation(self):&#10;        &quot;&quot;&quot;Test that edit distances are calculated correctly&quot;&quot;&quot;&#10;        entries = [&quot;kitten&quot;, &quot;sitting&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # &quot;kitten&quot; -&gt; &quot;sitting&quot; requires 3 edits (k-&gt;s, e-&gt;i, insert g)&#10;        result, exact = trie.search(&quot;kitten&quot;, correction_budget=3)&#10;        assert result == &quot;kitten&quot;&#10;        assert exact is True&#10;&#10;        # Should not find &quot;sitting&quot; with budget of 2 (needs 3 edits)&#10;        result, exact = trie.search(&quot;sitting&quot;, correction_budget=2)&#10;        # This should find &quot;sitting&quot; exactly since it's in the trie&#10;        assert result == &quot;sitting&quot;&#10;        assert exact is True&#10;&#10;    def test_optimal_alignment_selection(self):&#10;        &quot;&quot;&quot;Test that the algorithm selects optimal alignments&quot;&quot;&quot;&#10;        entries = [&quot;ACGT&quot;, &quot;TGCA&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Query that could align different ways&#10;        result, exact = trie.search(&quot;ACGA&quot;, correction_budget=2)&#10;        assert result in [&quot;ACGT&quot;, &quot;TGCA&quot;]&#10;        assert exact is False&#10;&#10;    def test_backtracking_scenarios(self):&#10;        &quot;&quot;&quot;Test scenarios that might require backtracking in search&quot;&quot;&quot;&#10;        entries = [&quot;abcdef&quot;, &quot;abcxyz&quot;, &quot;defghi&quot;]&#10;        trie = PrefixTrie(entries, allow_indels=True)&#10;&#10;        # Query that shares prefix with multiple entries&#10;        result, exact = trie.search(&quot;abcxef&quot;, correction_budget=2)&#10;        assert result in [&quot;abcdef&quot;, &quot;abcxyz&quot;]&#10;        assert exact is False&#10;&#10;def generate_barcodes(n: int, length: int = 16) -&gt; list[str]:&#10;    &quot;&quot;&quot;Generate `n` deterministic barcodes of given length&quot;&quot;&quot;&#10;    bases = &quot;ACGT&quot;&#10;    barcodes = []&#10;    for i in range(n):&#10;        seq = []&#10;        num = i&#10;        for _ in range(length):&#10;            seq.append(bases[num &amp; 3])&#10;            num &gt;&gt;= 2&#10;        barcodes.append(&quot;&quot;.join(seq))&#10;    return barcodes&#10;&#10;&#10;class TestLargeWhitelist:&#10;&#10;    def test_thousands_of_barcodes(self):&#10;        # Generate 10k deterministic 16bp barcodes&#10;        barcodes = generate_barcodes(10000)&#10;        trie = PrefixTrie(barcodes, allow_indels=True)&#10;&#10;        # Spot check a few barcodes for exact match&#10;        samples = [barcodes[0], barcodes[123], barcodes[9999], barcodes[5000], barcodes[7777]]&#10;        for bc in samples:&#10;            result, exact = trie.search(bc)&#10;            assert result == bc&#10;            assert exact is True&#10;&#10;        # Mutate a high-order position to ensure it is not already in whitelist&#10;        for idx, pos in [(42, 12), (123, 8), (9999, 15), (5000, 0), (7777, 5)]:&#10;            original = barcodes[idx]&#10;            replacement = &quot;A&quot; if original[pos] != &quot;A&quot; else &quot;C&quot;&#10;            mutated = original[:pos] + replacement + original[pos + 1:]&#10;            if mutated in barcodes:&#10;                continue  # Skip if mutated barcode is already in whitelist&#10;            result, exact = trie.search(mutated, correction_budget=1)&#10;            assert result == original&#10;            assert exact is False&#10;&#10;&#10;if __name__ == &quot;__main__&quot;:&#10;    # Run a quick smoke test&#10;    print(&quot;Running smoke test...&quot;)&#10;&#10;    # Basic functionality test&#10;    trie = PrefixTrie([&quot;hello&quot;, &quot;world&quot;, &quot;test&quot;])&#10;    result, exact = trie.search(&quot;hello&quot;)&#10;    assert result == &quot;hello&quot; and exact is True&#10;&#10;    # Fuzzy matching test&#10;    trie_fuzzy = PrefixTrie([&quot;hello&quot;], allow_indels=True)&#10;    result, exact = trie_fuzzy.search(&quot;hllo&quot;, correction_budget=1)&#10;    assert result == &quot;hello&quot; and exact is False&#10;&#10;    print(&quot;Smoke test passed! Run 'pytest test.py' for full test suite.&quot;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>