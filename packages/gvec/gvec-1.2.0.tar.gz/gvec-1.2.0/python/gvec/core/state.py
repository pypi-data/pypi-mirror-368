# Copyright (c) 2025 GVEC Contributors, Max Planck Institute for Plasma Physics
# License: MIT
"""gvec.state - low-level python API for postprocessing

The gvec.state module provides the `State` class which wraps the src/pygvec/state.f90 fortran module.
It provides an encapsulation for the state of the GVEC library, allowing safe postprocessing routines.
This module checks the input arguments and handles the initialization and finalization of the Fortran state.

1) gvec library - src/*
2) fortran API - src/pygvec/*
    - 1 & 2 are compiled into the `gveclib` (static) library
3) fortran wrapping layer - f90wrap_* - autogenerated by f90wrap
4) C wrapping layer - _libpygvecmodule.c - autogenerated by f2py
    - 3 & 4 are compiled into the `_libpygvec*` shared library which can be imported in python
5) python wrapping layer - lib.py - autogenerated by f90wrap
6) low-level python API - state.py
    - ensures safe access to the underlying layers
7) high-level python API - comp.py, run.py
"""

# === Imports === #

from pathlib import Path
from typing import Literal, Union, TypeAlias
from collections.abc import Iterable, Sequence, Mapping
import re
import inspect
import functools
import tempfile
import logging
import warnings

import numpy as np
import xarray as xr

import gvec.util
import gvec.lib
from gvec.lib import modgvec_py_state as _state
from gvec.lib import modgvec_py_binding as _binding
from gvec.lib import modgvec_py_run as _run

# === Globals === #

__all__ = [
    "State",
    "load_state",
    "find_state",
    "find_states",
]

logger = logging.getLogger("gvec.state")
CoordinateSpec: TypeAlias = int | float | xr.DataArray | np.ndarray | Sequence

# this variable tracks the global state of the fortran library
# it tracks which State object is currently bound/loaded/initialized
# _post.initialized tracks additionally if the State was properly initialized
bound_state: Union["State", None] = None


# === Decorators & Utility Functions === #


def with_binding(method):
    """This decorator wraps a method to ensure the State object is bound
    and the fortran library is initialized.

    If another state is bound, it is first unbound and the current state is bound.
    This ensures that unnecessary re-initialization of the fortran library is avoided,
    but switching between different State objects is still possible with minimal (syntactic) overhead.
    """

    @functools.wraps(method)
    def wrapped(self, *args, **kwargs):
        global bound_state

        if _run.initialized:
            raise RuntimeError(
                "The fortran library was left in a corrupted state by a run. Please restart the python interpreter."
            )

        if bound_state is self:
            if not _state.initialized:
                raise RuntimeError(
                    f"Expected {bound_state!r} to be bound, but fortran library is not initialized!"
                )
            return method(self, *args, **kwargs)

        if bound_state is not None:
            bound_state.unbind()

        self.bind()
        return method(self, *args, **kwargs)

    return wrapped


def _evaluate_1D_factory(
    func: callable, argnames: Iterable[str], n_out: int, vector_out: bool = False
):
    params = [inspect.Parameter("self", inspect.Parameter.POSITIONAL_OR_KEYWORD)] + [
        inspect.Parameter(name, inspect.Parameter.POSITIONAL_OR_KEYWORD, annotation=np.ndarray)
        for name in argnames
    ]
    returns = tuple[tuple(np.ndarray for _ in range(n_out))]
    sig = inspect.Signature(params, return_annotation=returns)

    @with_binding
    def wrapper(self, *args, **kwargs):
        bound_args = sig.bind(self, *args, **kwargs)
        inputs = [
            np.asfortranarray(value, dtype=np.float64)
            for key, value in bound_args.arguments.items()
            if key != "self"
        ]
        n = inputs[0].size
        for value in inputs:
            if value.shape != (n,):
                raise ValueError("All arguments must be 1D arrays of the same size.")

        if vector_out:
            outputs = [np.zeros((3, n), dtype=np.float64, order="F") for _ in range(n_out)]
        else:
            outputs = [np.zeros(n, dtype=np.float64) for _ in range(n_out)]
        func(n, *inputs, *outputs)
        return outputs

    wrapper.__signature__ = sig
    wrapper.__name__ = func.__name__
    return wrapper


# === State Class === #


class State:
    """A class for encapsulating the 'state' of the GVEC library with all relevant parameters and variables."""

    # === Constructor & Destructor === #

    def __init__(
        self,
        parameterfile: str | Path,
        statefile: str | Path | None = None,
    ):
        self.parameterfile: Path = Path(parameterfile).absolute()
        self.statefile: Path | None = Path(statefile).absolute() if statefile else None

        self._stdout: tempfile.NamedTemporaryFile | None = None
        self._children: list[gvec.lib.Modgvec_Sfl_Boozer.t_sfl_boozer] = []
        self.parameters: gvec.util.CaseInsensitiveDict = None

        if not self.parameterfile.exists():
            raise FileNotFoundError(f"Parameter file {self.parameterfile} does not exist.")
        if self.statefile is not None and not self.statefile.exists():
            raise FileNotFoundError(f"State file {self.statefile} does not exist.")
        self.parameters = gvec.util.read_parameters(
            self.parameterfile, format="ini"
        )  # read-only !!!

    def __del__(self):
        logger.debug(f"Deleting state {self!r}")
        if bound_state is self:
            self.unbind()
        if self._stdout is not None:
            self._stdout.close()

    # === Additional Constructors === #

    @classmethod
    def new(cls, parameters: Mapping, rundir: str | Path | None = None):
        if rundir is None:
            rundir = Path.cwd()
        parameterfile = Path(rundir) / "parameter.ini"
        gvec.util.write_parameters(parameters, parameterfile)
        return cls(parameterfile)

    # === Binding to the Fortran library === #

    def bind(self):
        """Bind this State object to the Fortran library. Allocate & initialize everything."""
        global bound_state
        if bound_state is not None:
            raise RuntimeError(
                f"Another state {bound_state!r} is already bound to the fortran library. Unbind that first."
            )
        if _state.initialized:
            raise RuntimeError("Fortran library is initialized, but no state is bound!?")

        bound_state = self
        logger.debug(f"Binding state {self!r} to the fortran library.")

        _binding.redirect_abort()  # redirect 'abort' to raise a 'RuntimeError'
        if self._stdout is None:
            self._stdout = tempfile.NamedTemporaryFile(mode="r", prefix="gvec-stdout-")
        _binding.redirect_stdout(self._stdout.name)

        with gvec.util.chdir(self.rundir):
            _state.init(self.parameterfile.name)
            if self.statefile is not None:
                _state.readstate(self.statefile.relative_to(self.rundir))
            else:
                _state.initsolution()
        self._children = []

        if not _state.initialized:
            raise RuntimeError("Failed to initialize fortran library.")

    def unbind(self):
        """Unbind this State object from the Fortran library. Finalize & deallocate everything."""
        global bound_state

        if bound_state is not self:
            raise RuntimeError(
                f"State {self!r} is not bound to the fortran library, but {bound_state!r} is."
            )
        if not _state.initialized:
            raise RuntimeError("Fortran library is not initialized, but state is bound!?")

        bound_state = None
        logger.debug(f"Unbinding state {self!r} from the fortran library.")

        for child in self._children:
            if isinstance(child, gvec.lib.Modgvec_Sfl_Boozer.t_sfl_boozer):
                if child.initialized:
                    logger.debug(f"Finalizing Boozer potential {child!r}")
                    child.free()
            else:
                logger.error(f"Unknown child: {child!r}")
        self._children = []

        _state.finalize()
        if _state.initialized:
            raise RuntimeError("Failed to finalize fortran library.")

    # === Context Manager === #

    def __enter__(self):
        warnings.warn(
            "Using State as a context manager is no longer necessary.", DeprecationWarning
        )
        return self

    def __exit__(self, exc_type, exc_value, traceback):
        pass

    # === Debug Information === #

    def __repr__(self):
        return (
            "<pygvec.State("
            + ",".join(
                [
                    str(self.parameterfile),
                    str(self.statefile),
                ]
            )
            + ")>"
        )

    @property
    def stdout(self) -> str:
        if self._stdout is None:
            return ""
        if bound_state is self:
            _binding.flush_stdout()
        self._stdout.seek(0)
        return self._stdout.read()

    @property
    def rundir(self):
        return self.parameterfile.parent

    # === Evaluation Methods === #

    @property
    @with_binding
    def nfp(self):
        return _state.nfp

    @with_binding
    def get_integration_points(self, quantity: str = "LA"):
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["X1", "X2", "LA"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'X1', 'X2', 'LA'.")

        r_n, t_n, z_n = _state.get_integration_points_num(quantity)
        r_GP, r_w = (np.zeros(r_n, dtype=np.float64) for _ in range(2))
        t_w, z_w = _state.get_integration_points(quantity, r_GP, r_w)
        return r_GP, r_w, t_n, t_w, z_n, z_w

    @with_binding
    def get_mn_max(self, quantity: str = "all") -> tuple[int, int]:
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["X1", "X2", "LA", "all"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'X1', 'X2', 'LA'.")

        if quantity == "all":
            m, n = zip(*[self.get_mn_max(q) for q in ["X1", "X2", "LA"]])
            return max(m), max(n)

        return _state.get_mn_max(quantity)

    @with_binding
    def evaluate_base_tens(
        self,
        quantity: str,
        derivs: str | None,
        rho: np.ndarray,
        theta: np.ndarray,
        zeta: np.ndarray,
    ):
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["X1", "X2", "LA"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'X1', 'X2', 'LA'.")
        if derivs is not None:
            if not isinstance(derivs, str):
                raise ValueError("Derivatives must be a string.")
            if m := re.match(r"(r{0,2})(t{0,2}|z{0,2}|tz)$", derivs):
                sel_derivs = m.groups()
            else:
                raise ValueError(f"Unknown derivative: {derivs}")
        else:
            sel_derivs = ("", "")

        rho = np.asfortranarray(rho, dtype=np.float64)
        theta = np.asfortranarray(theta, dtype=np.float64)
        zeta = np.asfortranarray(zeta, dtype=np.float64)
        if rho.ndim != 1 or theta.ndim != 1 or zeta.ndim != 1:
            raise ValueError("rho, theta, and zeta must be 1D arrays.")
        if rho.max() > 1.0 or rho.min() < 0.0:
            raise ValueError("rho must be in the range [0, 1].")

        result = np.zeros((rho.size, theta.size, zeta.size), dtype=np.float64, order="F")
        _state.evaluate_base_tens(rho, theta, zeta, quantity, *sel_derivs, result)
        return result

    @with_binding
    def evaluate_base_list_tz(
        self, quantity: str, derivs: str | None, rho: np.ndarray, thetazeta: np.ndarray
    ):
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["X1", "X2", "LA"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'X1', 'X2', 'LA'.")
        if derivs is not None:
            if not isinstance(derivs, str):
                raise ValueError("Derivatives must be a string.")
            if m := re.match(r"(r{0,2})(t{0,2}|z{0,2}|tz)$", derivs):
                sel_derivs = m.groups()
            else:
                raise ValueError(f"Unknown derivative: {derivs}")
        else:
            sel_derivs = ("", "")

        rho = np.asfortranarray(rho, dtype=np.float64)
        thetazeta = np.asfortranarray(thetazeta, dtype=np.float64)
        if rho.ndim != 1:
            raise ValueError("rho must be a 1D array.")
        if thetazeta.ndim != 2 or thetazeta.shape[0] != 2:
            raise ValueError("thetazeta must be a 2D array with shape (2, n).")
        if rho.max() > 1.0 or rho.min() < 0.0:
            raise ValueError("rho must be in the range [0, 1].")

        result = np.zeros((rho.size, thetazeta.shape[1]), dtype=np.float64, order="F")
        _state.evaluate_base_list_tz(
            rho.size, thetazeta.shape[1], rho, thetazeta, quantity, *sel_derivs, result
        )
        return result

    @with_binding
    def evaluate_base_list_tz_all(self, quantity: str, rho: np.ndarray, thetazeta: np.ndarray):
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["X1", "X2", "LA"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'X1', 'X2', 'LA'.")

        rho = np.asfortranarray(rho, dtype=np.float64)
        thetazeta = np.asfortranarray(thetazeta, dtype=np.float64)
        if rho.ndim != 1:
            raise ValueError("rho must be a 1D array.")
        if thetazeta.ndim != 2 or thetazeta.shape[0] != 2:
            raise ValueError("thetazeta must be a 2D array with shape (2, n).")
        if rho.max() > 1.0 or rho.min() < 0.0:
            raise ValueError("rho must be in the range [0, 1].")

        # Q, dQ_drho, dQ_dtheta, dQ_dzeta, dQ_drr, dQ_drt, dQ_drz, dQ_dtt, dQ_dtz, dQ_dzz
        outputs = [
            np.zeros((rho.size, thetazeta.shape[1]), dtype=np.float64, order="F")
            for _ in range(10)
        ]

        _state.evaluate_base_list_tz_all(
            rho.size, thetazeta.shape[1], rho, thetazeta, quantity, *outputs
        )
        return outputs

    @with_binding
    def evaluate_base_list_rtz_all(self, quantity: str, rhothetazeta: np.ndarray):
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["X1", "X2", "LA"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'X1', 'X2', 'LA'.")

        rhothetazeta = np.asarray(rhothetazeta)
        if rhothetazeta.ndim != 2 or rhothetazeta.shape[0] != 3:
            raise ValueError(
                f"rhothetazeta must be a 2D array with shape (3, n), but has shape {rhothetazeta.shape}"
            )
        rho = np.asfortranarray(rhothetazeta[0, :], dtype=np.float64)
        thetazeta = np.asfortranarray(rhothetazeta[1:, :], dtype=np.float64)
        if rho.max() > 1.0 or rho.min() < 0.0:
            raise ValueError("rho must be in the range [0, 1].")

        # Q, dQ_drho, dQ_dtheta, dQ_dzeta, dQ_drr, dQ_drt, dQ_drz, dQ_dtt, dQ_dtz, dQ_dzz
        outputs = [
            np.zeros((rhothetazeta.shape[1]), dtype=np.float64, order="F") for _ in range(10)
        ]

        _state.evaluate_base_list_stz_all(
            rhothetazeta.shape[1], rho, thetazeta, quantity, *outputs
        )
        return outputs

    @with_binding
    def evaluate_base_tens_all(
        self, quantity: str, rho: np.ndarray, theta: np.ndarray, zeta: np.ndarray
    ):
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["X1", "X2", "LA"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'X1', 'X2', 'LA'.")

        rho = np.asfortranarray(rho, dtype=np.float64)
        theta = np.asfortranarray(theta, dtype=np.float64)
        zeta = np.asfortranarray(zeta, dtype=np.float64)
        if rho.ndim != 1 or theta.ndim != 1 or zeta.ndim != 1:
            raise ValueError("rho, theta, and zeta must be 1D arrays.")
        if rho.max() > 1.0 or rho.min() < 0.0:
            raise ValueError("rho must be in the range [0, 1].")

        # Q, dQ_drho, dQ_dtheta, dQ_dzeta, dQ_drr, dQ_drt, dQ_drz, dQ_dtt, dQ_dtz, dQ_dzz
        outputs = [
            np.zeros((rho.size, theta.size, zeta.size), dtype=np.float64, order="F")
            for _ in range(10)
        ]

        _state.evaluate_base_tens_all(
            rho.size, theta.size, zeta.size, rho, theta, zeta, quantity, *outputs
        )
        return outputs

    evaluate_hmap = _evaluate_1D_factory(
        _state.evaluate_hmap,
        [
            "X1",
            "X2",
            "zeta",
        ]
        + [f"d{Q}_d{i}" for i in "rtz" for Q in ["X1", "X2"]],
        4,
        True,
    )  # -> pos, e_rho, e_theta, e_zeta

    evaluate_hmap_only = _evaluate_1D_factory(
        _state.evaluate_hmap_only, ["X1", "X2", "zeta"], 4, True
    )  # -> pos, e_X1, e_X2, e_zeta3

    evaluate_metric_derivs = _evaluate_1D_factory(
        _state.evaluate_metric_derivs,
        [
            "X1",
            "X2",
            "zeta",
        ]
        + [f"d{Q}_d{i}" for i in "r t z rr rt rz tt tz zz".split() for Q in ["X1", "X2"]],
        18,
    )  # -> dg_rr_dr, dg_rt_dr ... dg_zz_dz

    evaluate_jac_h_derivs = _evaluate_1D_factory(
        _state.evaluate_jac_h_derivs,
        [
            "X1",
            "X2",
            "zeta",
            "dX1_dr",
            "dX2_dr",
            "dX1_dt",
            "dX2_dt",
            "dX1_dz",
            "dX2_dz",
        ],
        3,
    )  # ->  dJac_h_dr, dJac_h_dt, dJac_h_dz

    @with_binding
    def evaluate_profile(self, quantity: str, rho: np.ndarray, deriv: int = 0):
        """Evaluate 1D profiles at the provided positions of the radial coordinate rho.

        Args:
            quantity (str): name of the profile. Has to be either `iota` (rotational transform), `p` (pressure), `chi`(poloidal magn. flux), `Phi`(toroidal magn. flux)
            rho (np.ndarray): Positions at the radial flux coordinate rho.
            deriv (int, optional): Order of the derivative in rho. Note that for some quantities not all derivatives can be calculated, e.g. for `iota` and `p` the maximum is `deriv=4`. Defaults to 0.

        Raises:
            ValueError: If `quantity`is not a string.
            ValueError: If an invalid quantity is provided.
            NotImplementedError: If `deriv > 1` for `quantity="chi"`.
            ValueError: If `rho` is not a 1D array.
            ValueError: If `rho` is not in [0, 1].

        Returns:
            np.ndarray: profile values at `rho`.
        """
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["iota", "p", "chi", "Phi"]:
            raise ValueError(f"Unknown quantity: {quantity}")

        rho = np.asfortranarray(rho, dtype=np.float64)
        if rho.ndim != 1:
            raise ValueError("rho must be a 1D array.")
        if rho.max() > 1.0 or rho.min() < 0.0:
            raise ValueError("rho must be in the range [0, 1].")

        result = np.zeros(rho.size, dtype=np.float64, order="F")

        _state.evaluate_profile(rho.size, rho, deriv, quantity, result)
        return result

    @with_binding
    def evaluate_rho2_profile(self, quantity: str, rho2: np.ndarray, deriv: int = 0):
        r"""Evaluate 1D profiles at the provided positions of the radial coordinate `rho2`=:math:`\rho^2`.
        Note: Use this routine to obtain derivarives with respect to `rho2`, else use `evaluate_profile`.

        Args:
            quantity (str): name of the profile. Has to be either `iota` or `p`
            rho2 (np.ndarray): Positions at the radial flux coordinate rho^2.
            deriv (int, optional): Order of the derivative, in s=rho^2 (!). Defaults to 0.

        Raises:
            ValueError: If `quantity`is not a string.
            ValueError: If an invalid quantity is provided.
            ValueError: If `rho2` is not a 1D array.
            ValueError: If `rho2` is not in [0, 1].

        Returns:
            np.ndarray: profile values at `rho2`.
        """
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["iota", "p", "chi", "Phi"]:
            raise ValueError(f"Unknown quantity: {quantity}")

        rho2 = np.asfortranarray(rho2, dtype=np.float64)
        if rho2.ndim != 1:
            raise ValueError("rho2 must be a 1D array.")
        if rho2.max() > 1.0 or rho2.min() < 0.0:
            raise ValueError("rho2 must be in the range [0, 1].")

        result = np.zeros(rho2.size, dtype=np.float64, order="F")

        _state.evaluate_rho2_profile(rho2.size, rho2, deriv, quantity, result)
        return result

    # === Boozer Potential === #

    @with_binding
    def get_boozer(
        self,
        rho: np.ndarray,
        MNfactor: int = 5,
        *,
        M: int | None = None,
        N: int | None = None,
        M_nyq: int | None = None,
        N_nyq: int | None = None,
        sincos: Literal["sin", "cos", "sincos"] = "sin",
        recompute_lambda: bool = True,
    ):
        r"""
        Initialize a new Boozer potential with M poloidal and N toroidal nodes for all fluxsurfaces given by rho.

        Parameters
        ----------
        rho
            Array of (radius-like) flux surface labels.
        MNfactor
            Multiplication factor between the maximum M, N of the equilbrium and the maximum M, N of the Boozer potential.
            Only used if M, N are not explicitly given.
        M
            Number of poloidal nodes of the Boozer potential :math:`\nu_B`. Defaults to the maximum number of nodes of the basis.
        N
            Number of toroidal nodes of the Boozer potential :math:`\nu_B`. Defaults to the maximum number of nodes of the basis.

        Returns
        -------
        sfl_boozer
            Straight-fieldline Boozer object (wrapped Fortran object).
        """
        # --- Defaults --- #
        M_max, N_max = self.get_mn_max()
        _, M_nyq_LA, N_nyq_LA = _state.get_integration_points_num("LA")

        if M is None:
            M = MNfactor * M_max
        if N is None:
            N = MNfactor * N_max
        if M_nyq is None:
            M_nyq = max(4 * M + 1, M_nyq_LA)
        if N_nyq is None:
            N_nyq = max(4 * N + 1, N_nyq_LA)

        # --- Argument Handling --- #
        if not isinstance(M, int) or not isinstance(N, int) or M < 0 or N < 0:
            raise ValueError("M and N must be non-negative integers (or None).")
        if M < M_max or N < N_max:
            raise ValueError(
                f"The number of poloidal and toroidal nodes for the Boozer potential must be equal or larger to those of the original lambda: ({M}, {N}) < ({M_max}, {N_max})"
            )
        if (
            not isinstance(M_nyq, int)
            or not isinstance(N_nyq, int)
            or M_nyq < min(2 * M + 1, M_nyq_LA)
            or N_nyq < min(2 * N + 1, N_nyq_LA)
        ):
            raise ValueError(
                f"M_nyq and N_nyq must be integers larger than min({2 * M + 1=}, {M_nyq_LA=}) and min({2 * N + 1=}, {N_nyq_LA=}) (or None)."
            )

        rho = np.asfortranarray(rho, dtype=np.float64)
        if rho.ndim != 1 or rho.max() > 1.0 or rho.min() < 1e-4:
            raise ValueError("rho must be a 1D array in the range [1e-4, 1].")

        if sincos not in ["sin", "cos", "sincos"]:
            raise ValueError("sincos must be 'sin', 'cos', or 'sincos'.")
        sincos = {"sin": " _sin_", "cos": " _cos_", "sincos": "_sin_cos_"}[sincos]

        recompute_lambda = bool(recompute_lambda)

        # --- Create & compute Boozer potential --- #
        logger.debug("Initializing new Boozer potential.")
        sfl_boozer = _state.init_boozer(
            (M, N), (M_nyq, N_nyq), sincos, rho.size, rho, recompute_lambda
        )
        self._children.append(sfl_boozer)
        logger.debug(f"Computing Boozer potential {sfl_boozer!r}")
        _state.get_boozer(sfl_boozer)

        # ToDo: wrap sfl_boozer again to make it safer?
        return sfl_boozer

    @with_binding
    def get_boozer_angles(
        self,
        sfl_boozer: gvec.lib.Modgvec_Sfl_Boozer.t_sfl_boozer,
        tz_list: np.ndarray,
        rad: int | None = None,
    ):
        """
        Find the logical angles (theta, zeta) for the corresponding (theta_B, zeta_B) coordinates on the Boozer surface.

        Parameters
        ----------
        sfl_boozer : lib.Modgvec_Sfl_Boozer.t_sfl_boozer
            The Boozer potential object to use.
        tz_list : 2D array or Sequence of shape (2, n)
            The list of (theta_B, zeta_B) coordinates for which to find the logical angles.
            The first row contains theta_B and the second row contains zeta_B.
        rad : int, optional
            The (optional) radial index of the surface (with respect to the sfl_boozer object) on which to find the angles.

        Returns
        -------
        2D or 3D np.ndarray
            The logical angles (theta, zeta) corresponding to the input (theta_B, zeta_B) coordinates.
            If rad is None, returns a 3D array of shape (2, n, nrho), where nrho is the number of radial surfaces in sfl_boozer.
            If rad is specified, returns a 2D array of shape (2, n).
        """
        if not isinstance(sfl_boozer, gvec.lib.Modgvec_Sfl_Boozer.t_sfl_boozer):
            raise ValueError(f"Boozer object {sfl_boozer!r} must be of type `t_sfl_boozer`.")
        if sfl_boozer not in self._children:
            raise ValueError(
                f"Boozer object {sfl_boozer!r} is not known to the state {self!r}."
            )
        if not sfl_boozer.initialized:
            raise ValueError(f"Boozer object {sfl_boozer!r} is not initialized.")

        tz_list = np.asfortranarray(tz_list, dtype=np.float64)
        if tz_list.ndim != 2 or tz_list.shape[0] != 2:
            raise ValueError("thetazeta must be a 2D array with shape (2, n).")

        if rad is None:  # find angles on all surfaces
            tz_out = np.ndarray(
                (2, tz_list.shape[1], sfl_boozer.nrho), dtype=np.float64, order="F"
            )
            sfl_boozer.find_angles(tz_list.shape[1], tz_list, tz_out)
        else:  # find angles on a specific surface
            if rad not in range(sfl_boozer.nrho):
                raise ValueError(
                    f"rad must be in the range [0, {sfl_boozer.nrho - 1}], got {rad}."
                )
            irho = rad + 1  # 1-indexed
            tz_out = np.ndarray((2, tz_list.shape[1]), dtype=np.float64, order="F")
            sfl_boozer.find_angles_irho(irho, tz_list.shape[1], tz_list, tz_out)
        return tz_out

    @with_binding
    def evaluate_boozer_list_tz_all(
        self,
        sfl_boozer: gvec.lib.Modgvec_Sfl_Boozer.t_sfl_boozer,
        quantity: str,
        rad: np.ndarray,
        thetazeta: np.ndarray,
    ):
        if not isinstance(quantity, str):
            raise ValueError("Quantity must be a string.")
        elif quantity not in ["LA", "NU"]:
            raise ValueError(f"Unknown quantity: {quantity}, expected one of 'LA', 'NU'.")
        if not isinstance(sfl_boozer, gvec.lib.Modgvec_Sfl_Boozer.t_sfl_boozer):
            raise ValueError(f"Boozer object {sfl_boozer!r} must be of type `t_sfl_boozer`.")
        if sfl_boozer not in self._children:
            raise ValueError(
                f"Boozer object {sfl_boozer!r} is not known to the state {self!r}."
            )
        if not sfl_boozer.initialized:
            raise ValueError(f"Boozer object {sfl_boozer!r} is not initialized.")

        rad = np.asfortranarray(rad, dtype=np.int64)
        thetazeta = np.asfortranarray(thetazeta, dtype=np.float64)
        if rad.ndim != 1:
            raise ValueError("rad must be a 1D array.")
        if thetazeta.ndim != 2 or thetazeta.shape[0] != 2:
            raise ValueError("thetazeta must be a 2D array with shape (2, n).")
        if rad.min() < 0:
            raise ValueError("rad must be a positive integer.")

        # Q, dQ_dtheta, dQ_dzeta, dQ_dtt, dQ_dtz, dQ_dzz
        outputs = [
            np.zeros((rad.size, thetazeta.shape[1]), dtype=np.float64, order="F")
            for _ in range(6)
        ]

        _state.evaluate_boozer_list_tz_all(
            sfl_boozer, rad.size, thetazeta.shape[1], rad, thetazeta, quantity, *outputs
        )
        return outputs

    # === High Level Interface for Evaluations === #

    def compute(
        self,
        ev: xr.Dataset,
        *quantities: str,
    ):
        from gvec.core.compute import compute

        return compute(ev, *quantities, state=self)

    def evaluate(
        self,
        *quantities: str,
        rho: Literal["int"] | CoordinateSpec | None = "int",
        theta: Literal["int"] | CoordinateSpec | None = "int",
        zeta: Literal["int"] | CoordinateSpec | None = "int",
    ):
        from gvec.core.compute import evaluate

        return evaluate(self, *quantities, rho=rho, theta=theta, zeta=zeta)

    def evaluate_sfl(
        self,
        *quantities: str,
        rho: Literal["int"] | CoordinateSpec | None = "int",
        theta: Literal["int"] | CoordinateSpec | None = "int",
        zeta: Literal["int"] | CoordinateSpec | None = "int",
        sfl: Literal["boozer", "pest"] = "boozer",
        **boozer_kwargs,
    ):
        from gvec.core.compute import evaluate_sfl

        return evaluate_sfl(
            self, *quantities, rho=rho, theta=theta, zeta=zeta, sfl=sfl, **boozer_kwargs
        )


# === Functions === #


def load_state(parameterfile: Path | str, statefile: Path | str):
    """Load a State object from a given parameterfile (.ini) and statefile (.dat)."""
    return State(parameterfile, statefile)


def find_state(rundir: Path | str | None = None):
    """Load a State object from a given run-directory. Use the latest statefile which is found."""
    if rundir is None:
        rundir = Path.cwd()
    else:
        rundir = Path(rundir)
    parameterfiles = list(rundir.glob("parameter*.ini"))
    if len(parameterfiles) > 1:
        raise ValueError(
            f"Found more than one candidate parameterfile: {[file.name for file in parameterfiles]}"
        )
    elif len(parameterfiles) == 0:
        raise ValueError("No parameterfile found.")
    statefiles = sorted(rundir.glob("*State*.dat"))
    if len(statefiles) == 0:
        raise ValueError("No statefile found.")
    return State(parameterfiles[0], statefiles[-1])


def find_states(rundir: Path | str | None = None):
    """Load a Sequence of State objects from a given run-directory."""
    if rundir is None:
        rundir = Path.cwd()
    else:
        rundir = Path(rundir)
    parameterfiles = list(rundir.glob("parameter*.ini"))
    if len(parameterfiles) > 1:
        raise ValueError(
            f"Found more than one candidate parameterfile: {[file.name for file in parameterfiles]}"
        )
    elif len(parameterfiles) == 0:
        raise ValueError("No parameterfile found.")
    statefiles = sorted(rundir.glob("*State*.dat"))
    return [State(parameterfiles[0], statefile) for statefile in statefiles]
