{
  "version": "2.5",
  "isOffline": false,
  "datasetID": "1743287673.886393.csv/Sheet1",
  "title": "Predictive AI Project",
  "positivePolarityValues": [
    "1"
  ],
  "projectedPopulation": null,
  "customChartLayoutMap": {
    "xl": [
      {
        "w": 11,
        "h": 9,
        "x": 0,
        "y": 0,
        "i": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56",
        "moved": false,
        "static": false
      },
      {
        "w": 7,
        "h": 8,
        "x": 5,
        "y": 9,
        "i": "74a92600-9334-4e57-afe5-2dbb61526547",
        "moved": false,
        "static": false
      },
      {
        "w": 5,
        "h": 8,
        "x": 0,
        "y": 9,
        "i": "94afbde0-ecc9-47f3-8643-9546d2ebac17",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 8,
        "x": 0,
        "y": 17,
        "i": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 25,
        "i": "49adfed8-4e6d-4659-8cd2-ab1048b09d53",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 36,
        "i": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 8,
        "x": 0,
        "y": 45,
        "i": "2f897f6a-1a88-4016-8cc0-0f4bfe440007",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 53,
        "i": "53638649-4c64-46de-a425-96c2ffc1c976",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 63,
        "i": "7110f5af-74a2-493e-9048-a6336be22c77",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 72,
        "i": "23eaed6c-2269-47b7-b2d1-25fd8f3345df",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 82,
        "i": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e",
        "moved": false,
        "static": false
      },
      {
        "w": 7,
        "h": 10,
        "x": 0,
        "y": 91,
        "i": "d97ad6f2-5924-4413-b5b7-0a75e1bd6e94",
        "moved": false,
        "static": false
      }
    ],
    "lg": [
      {
        "w": 11,
        "h": 9,
        "x": 0,
        "y": 0,
        "i": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56",
        "moved": false,
        "static": false
      },
      {
        "w": 7,
        "h": 8,
        "x": 5,
        "y": 9,
        "i": "74a92600-9334-4e57-afe5-2dbb61526547",
        "moved": false,
        "static": false
      },
      {
        "w": 5,
        "h": 8,
        "x": 0,
        "y": 9,
        "i": "94afbde0-ecc9-47f3-8643-9546d2ebac17",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 8,
        "x": 0,
        "y": 17,
        "i": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 25,
        "i": "49adfed8-4e6d-4659-8cd2-ab1048b09d53",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 36,
        "i": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 8,
        "x": 0,
        "y": 45,
        "i": "2f897f6a-1a88-4016-8cc0-0f4bfe440007",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 53,
        "i": "53638649-4c64-46de-a425-96c2ffc1c976",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 63,
        "i": "7110f5af-74a2-493e-9048-a6336be22c77",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 72,
        "i": "23eaed6c-2269-47b7-b2d1-25fd8f3345df",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 82,
        "i": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e",
        "moved": false,
        "static": false
      },
      {
        "w": 7,
        "h": 10,
        "x": 0,
        "y": 91,
        "i": "d97ad6f2-5924-4413-b5b7-0a75e1bd6e94",
        "moved": false,
        "static": false
      }
    ],
    "md": [
      {
        "w": 11,
        "h": 9,
        "x": 0,
        "y": 0,
        "i": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56",
        "moved": false,
        "static": false
      },
      {
        "w": 7,
        "h": 8,
        "x": 5,
        "y": 9,
        "i": "74a92600-9334-4e57-afe5-2dbb61526547",
        "moved": false,
        "static": false
      },
      {
        "w": 5,
        "h": 8,
        "x": 0,
        "y": 9,
        "i": "94afbde0-ecc9-47f3-8643-9546d2ebac17",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 8,
        "x": 0,
        "y": 17,
        "i": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 25,
        "i": "49adfed8-4e6d-4659-8cd2-ab1048b09d53",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 36,
        "i": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 8,
        "x": 0,
        "y": 45,
        "i": "2f897f6a-1a88-4016-8cc0-0f4bfe440007",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 53,
        "i": "53638649-4c64-46de-a425-96c2ffc1c976",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 63,
        "i": "7110f5af-74a2-493e-9048-a6336be22c77",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 10,
        "x": 0,
        "y": 72,
        "i": "23eaed6c-2269-47b7-b2d1-25fd8f3345df",
        "moved": false,
        "static": false
      },
      {
        "w": 12,
        "h": 9,
        "x": 0,
        "y": 82,
        "i": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e",
        "moved": false,
        "static": false
      },
      {
        "w": 7,
        "h": 10,
        "x": 0,
        "y": 91,
        "i": "d97ad6f2-5924-4413-b5b7-0a75e1bd6e94",
        "moved": false,
        "static": false
      }
    ],
    "xs": [
      {
        "i": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56",
        "x": 0,
        "y": 0,
        "w": 12,
        "h": 12
      },
      {
        "i": "74a92600-9334-4e57-afe5-2dbb61526547",
        "x": 0,
        "y": 12,
        "w": 12,
        "h": 12
      },
      {
        "i": "94afbde0-ecc9-47f3-8643-9546d2ebac17",
        "x": 0,
        "y": 24,
        "w": 12,
        "h": 12
      },
      {
        "i": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 36
      },
      {
        "i": "49adfed8-4e6d-4659-8cd2-ab1048b09d53",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 48
      },
      {
        "i": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 60
      },
      {
        "i": "2f897f6a-1a88-4016-8cc0-0f4bfe440007",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 72
      },
      {
        "i": "53638649-4c64-46de-a425-96c2ffc1c976",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 84
      },
      {
        "i": "7110f5af-74a2-493e-9048-a6336be22c77",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 96
      },
      {
        "i": "23eaed6c-2269-47b7-b2d1-25fd8f3345df",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 108
      },
      {
        "i": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 120
      },
      {
        "i": "d97ad6f2-5924-4413-b5b7-0a75e1bd6e94",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 132
      },
      {
        "i": "2db67e79-3c40-40c5-ae42-7d426fa37597",
        "x": 0,
        "y": 144,
        "w": 12,
        "h": 12
      },
      {
        "i": "f8e84792-fc0f-4721-8e50-bb53f2d6d9ae",
        "x": 0,
        "y": 156,
        "w": 12,
        "h": 12
      }
    ],
    "sm": [
      {
        "i": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56",
        "x": 0,
        "y": 0,
        "w": 12,
        "h": 12
      },
      {
        "i": "74a92600-9334-4e57-afe5-2dbb61526547",
        "x": 0,
        "y": 12,
        "w": 12,
        "h": 12
      },
      {
        "i": "94afbde0-ecc9-47f3-8643-9546d2ebac17",
        "x": 0,
        "y": 24,
        "w": 12,
        "h": 12
      },
      {
        "i": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 36
      },
      {
        "i": "49adfed8-4e6d-4659-8cd2-ab1048b09d53",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 48
      },
      {
        "i": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 60
      },
      {
        "i": "2f897f6a-1a88-4016-8cc0-0f4bfe440007",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 72
      },
      {
        "i": "53638649-4c64-46de-a425-96c2ffc1c976",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 84
      },
      {
        "i": "7110f5af-74a2-493e-9048-a6336be22c77",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 96
      },
      {
        "i": "23eaed6c-2269-47b7-b2d1-25fd8f3345df",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 108
      },
      {
        "i": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 120
      },
      {
        "i": "d97ad6f2-5924-4413-b5b7-0a75e1bd6e94",
        "h": 12,
        "w": 12,
        "x": 0,
        "y": 132
      },
      {
        "i": "2db67e79-3c40-40c5-ae42-7d426fa37597",
        "x": 0,
        "y": 144,
        "w": 12,
        "h": 12
      },
      {
        "i": "f8e84792-fc0f-4721-8e50-bb53f2d6d9ae",
        "x": 0,
        "y": 156,
        "w": 12,
        "h": 12
      }
    ]
  },
  "sliders": [
    {
      "id": "2b3ef657-a75d-45f5-9e39-4f07e6de23ae",
      "name": "Gain per correctly treated (true-positive earnings)",
      "description": null,
      "min": 0,
      "max": 100,
      "value": 37
    },
    {
      "id": "29a827d4-35ac-410e-9a31-45203dc1bb18",
      "name": "Loss per incorrectly treated (false-positive cost)",
      "description": null,
      "min": 0,
      "max": 100,
      "value": 38
    },
    {
      "id": "512dc446-c838-4878-b904-9b0dbbddd5f3",
      "max": 100,
      "min": 0,
      "name": "Gain per correctly treated (true-positive earnings) - percentage",
      "value": 100,
      "description": null,
      "label": null
    },
    {
      "id": "7ae2b7bb-84e5-4185-a9ab-2bdc991b3d80",
      "max": 100,
      "min": 0,
      "name": "Loss per incorrectly treated (false-positive cost) - percentage",
      "value": 12,
      "description": null,
      "label": null
    },
    {
      "id": "c5470490-afa2-4b7a-a3fa-dbef1f026750",
      "max": 100,
      "min": 0,
      "name": "Cost per treatment",
      "value": 15,
      "description": null,
      "label": null
    },
    {
      "id": "0a020a5f-94ee-40b9-9fce-4fab79946dd3",
      "max": 100,
      "min": 0,
      "name": "Cost per treatment - percentage",
      "value": 10,
      "description": null,
      "label": null
    },
    {
      "id": "dae38394-6a72-4cd9-86fa-de4818626c6a",
      "max": 100,
      "min": 0,
      "name": "Effectiveness of treatment - percentage",
      "value": 100,
      "description": null,
      "label": null
    }
  ],
  "sliderAssociations": [
    {
      "sliderID": "512dc446-c838-4878-b904-9b0dbbddd5f3",
      "uswID": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f"
    },
    {
      "sliderID": "29a827d4-35ac-410e-9a31-45203dc1bb18",
      "uswID": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f"
    },
    {
      "sliderID": "512dc446-c838-4878-b904-9b0dbbddd5f3",
      "uswID": "49adfed8-4e6d-4659-8cd2-ab1048b09d53"
    },
    {
      "sliderID": "7ae2b7bb-84e5-4185-a9ab-2bdc991b3d80",
      "uswID": "49adfed8-4e6d-4659-8cd2-ab1048b09d53"
    },
    {
      "sliderID": "2b3ef657-a75d-45f5-9e39-4f07e6de23ae",
      "uswID": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56"
    },
    {
      "sliderID": "29a827d4-35ac-410e-9a31-45203dc1bb18",
      "uswID": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56"
    },
    {
      "sliderID": "512dc446-c838-4878-b904-9b0dbbddd5f3",
      "uswID": "2f897f6a-1a88-4016-8cc0-0f4bfe440007"
    },
    {
      "sliderID": "c5470490-afa2-4b7a-a3fa-dbef1f026750",
      "uswID": "2f897f6a-1a88-4016-8cc0-0f4bfe440007"
    },
    {
      "sliderID": "2b3ef657-a75d-45f5-9e39-4f07e6de23ae",
      "uswID": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5"
    },
    {
      "sliderID": "c5470490-afa2-4b7a-a3fa-dbef1f026750",
      "uswID": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5"
    },
    {
      "sliderID": "512dc446-c838-4878-b904-9b0dbbddd5f3",
      "uswID": "53638649-4c64-46de-a425-96c2ffc1c976"
    },
    {
      "sliderID": "0a020a5f-94ee-40b9-9fce-4fab79946dd3",
      "uswID": "53638649-4c64-46de-a425-96c2ffc1c976"
    },
    {
      "sliderID": "dae38394-6a72-4cd9-86fa-de4818626c6a",
      "uswID": "7110f5af-74a2-493e-9048-a6336be22c77"
    },
    {
      "sliderID": "2b3ef657-a75d-45f5-9e39-4f07e6de23ae",
      "uswID": "7110f5af-74a2-493e-9048-a6336be22c77"
    },
    {
      "sliderID": "29a827d4-35ac-410e-9a31-45203dc1bb18",
      "uswID": "7110f5af-74a2-493e-9048-a6336be22c77"
    },
    {
      "sliderID": "dae38394-6a72-4cd9-86fa-de4818626c6a",
      "uswID": "23eaed6c-2269-47b7-b2d1-25fd8f3345df"
    },
    {
      "sliderID": "512dc446-c838-4878-b904-9b0dbbddd5f3",
      "uswID": "23eaed6c-2269-47b7-b2d1-25fd8f3345df"
    },
    {
      "sliderID": "29a827d4-35ac-410e-9a31-45203dc1bb18",
      "uswID": "23eaed6c-2269-47b7-b2d1-25fd8f3345df"
    },
    {
      "sliderID": "dae38394-6a72-4cd9-86fa-de4818626c6a",
      "uswID": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e"
    },
    {
      "sliderID": "512dc446-c838-4878-b904-9b0dbbddd5f3",
      "uswID": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e"
    },
    {
      "sliderID": "7ae2b7bb-84e5-4185-a9ab-2bdc991b3d80",
      "uswID": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e"
    }
  ],
  "xAxisName": "Percent treated",
  "percentTreated": 62.1431232431334,
  "rules": null,
  "filters": null,
  "activeFilter": null,
  "showFiltersOnDashboard": false,
  "numberOfRowsSentInAIPrompt": 10,
  "variableSelectors": [
    {
      "name": "TransactionAmt",
      "label": "AMOUNT"
    }
  ],
  "customColumns": null,
  "scores": [
    {
      "fieldName": "model-0-score-class-1"
    },
    {
      "fieldName": "model-4-score-class-1"
    },
    {
      "fieldName": "model-6-score-class-1"
    },
    {
      "fieldName": "model-7-score-class-1"
    }
  ],
  "dependentVariable": "dependent_variable",
  "customCharts": [
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the num pos cases below the zoom view\n  var lower_bin = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin++;\n    }\n  }\n  // After this loop, bins[] holds the number of positive cases in each bin\n  let bins = [];\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins[i]++;\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the num pos cases above the zoom view\n  var higher_bin = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin++;\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: { bin_size, bins, lower_bin, range_min },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n  aggregator +=\n    lower_bin *\n    (sliders[\"Gain per correctly treated (true-positive earnings)\"].value ?? 0);\n  aggregator -=\n    (range_min - lower_bin) * (sliders[\"Loss per incorrectly treated (false-positive cost)\"].value ?? 0);\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    // For each positive case, add slider-1's value:\n    aggregator +=\n      bins[i] *\n      (sliders[\"Gain per correctly treated (true-positive earnings)\"].value ??\n        0);\n\n    // For each negative case, subtract slider-1's value:\n    aggregator -=\n      (bin_size - bins[i]) *\n      (sliders[\"Loss per incorrectly treated (false-positive cost)\"].value ??\n        0);\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "d292c59c-e1f6-4f7e-ac53-525b7b6e6a56",
      "title": "Profit Curve A",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 9.595213473186586,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 0,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": "The profit of a targeted marketing campaign. This calculated in a simple way that can be expanded upon -- currently, with an overall average TP win and FP cost (cost of contact).",
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": "You are a chatbot embedded within a software product called Gooder AI. Here is the background information you need in order to serve Gooder AI's user, followed by guidance on how pithy you must keep your responses.\n\nGooder AI is the business-user console for predictive analytics (aka predictive AI) projects. Data scientists always evaluate their machine learning models, but almost never valuate them. Evaluating and valuating models are two very different things. To valuate a model is to test its performance in terms of business metrics and KPIs like profit and savings, rather than only evaluating the model in terms of technical metrics (like precision, recall, F-score, and AUC). Business metrics and KPIs are critical because, if you aren't measuring the business value, you're not pursuing business value. \n\nYour purpose is to help the user understand and get value from the Gooder AI product, including the chart included here. The user can see the chart as well as other charts and tables. \n\nEvery predictive AI project can be defined by two main things: what's predicted by an ML model and what's done about. For this project, the model predicts which customer will buy if contacted, and what's done about it, the deployment, will be to target marketing with the model. \n\nThe chart's horizontal coordinate represents the percentage of customers contacted with marketing. It orders the customers by model score: From left to right, it orders customers predicted most likely to buy if contacted down to least likely. Each model output, a predictive score, is the probability the customer will buy if contacted. So the horizontal axis represents the user's range of options for model deployment; by setting a decision threshold, the user can determine how many customers are contacted. \n\nThe user can change the percent contacted by moving a vertical line called the \"decision threshold\" left and right across the chart (although that is not shown in the version of the chart image given to you). Moving that vertical line selects a horizontal position on the chart, but does not change the values on the chart or the shape of the curve(s). However, there are other business metrics besides profit that do change when the user changes the threshold position, such as the budget needed for the marketing campaign, that is, how much it will cost to contact that many customers. Gooder AI displays those other metrics for the user elsewhere. Since the user must strike a tradeoff between various metrics for any choice of decision threshold, we can say that the metrics are competing. By moving the decision threshold, the user can view the tradeoffs between competing metrics. \n\nThis and other charts plot a metric on the vertical axis against the percent contacted, which provides an intuitive view for the user. In model deployment, that percent will be enacted with a decision threshold. A higher threshold means the model is used to target more narrowly. The Gooder AI product can provide to the user the decision threshold corresponding with the selected percent contacted, in another function outside the chart shown to you. \n\nThe profit (vertical coordinate) is calculated for each percent contacted with a simple formula: the number of customers contacted times the cost of contact (a parameter the user can change), plus the number of customers who respond times the profit per response (another parameter the user can change). The result is scaled based on the specified population size, which is another parameter the user can change. \n\nThe cost of contact and the profit per response are expressed as dollar amounts.\n\nTo make these calculations, the product has the actuals on which customers actually responded. The actuals are within a test set of examples provided by the user. While ML models are always evaluated with a test set, Gooder AI's unique contribution is to use a test set to also valuate models in terms of business metrics like profit and savings. \n\nTherefore, the profit shown is an estimated forecast of the value the model would deliver when deployed, applied across a set of customers, where the set has the given population size. \n\nA prompt hidden from the user will provide you with the settings for these parameters, updating you on their values when the user changes one or more of them.\n\nWith this chart, Gooder AI provides the user with unique visibility: the range of possible decision threshold settings and the forecasted business value at each setting. This view is important, but rarely generated for enterprise machine learning or predictive AI projects. Gooder AI is the only off-the-shelf software solution for creating such views and related interactive capabilities. \n\nThe user can adjust the parameters that affect the metric calculations by moving sliders within the Gooder AI user interface (not shown within the chart image shared with you). Therefore, the parameter settings change the shape of the curve(s) shown in the chart. As the user moves the sliders, the chart's curve(s)  smoothly change in real-time, allowing the user an interactive experience that provides an intuitive sense of how the parameter settings affect forecasted metric values. That interactive capability is unique to Gooder AI. \n\nWith this interactive visualization, Gooder AI uniquely solves two problems: (1) Model development can pursue business value, since each iteration of model training can be assessed in terms of business metrics. This makes it possible to navigate model development toward business value. And (2) model deployment can be planned according to business value by business stakeholders. This makes it possible to determine whether there is a model that performs well enough for deployment, which model would be best to deploy, and what decision threshold to apply in deployment. \n\nSince this visibility is understandable to non-data scientists and is relevant to line of business managers and other business stakeholders, Gooder AI serves as the business user console for enterprise machine learning projects.\n\nWhile answering the user's questions, keep every response very, very short: one sentence maximum. Always respond with a single sentence, without any additional explanation or sentences. ",
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "id": "74a92600-9334-4e57-afe5-2dbb61526547",
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the num pos cases below the zoom view\n  var lower_bin = 0;\n  var tot_pos_cases = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    // only up to, and not incl, minrange\n    if (records[i][dependentVariable] === 1) {\n      lower_bin++;\n      tot_pos_cases++;\n    }\n  }\n\n  // After this loop, bins[] holds the number of positive cases in each bin\n  let bins = []; // new var that must be available within generateData()\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins[i]++;\n        tot_pos_cases++;\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the num pos cases above the zoom view\n  var higher_bin = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin++;\n      tot_pos_cases++;\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    tot_pos_cases,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: { bin_size, bins, lower_bin,tot_pos_cases,range_min },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n  for (var i = 0; i < resolution; i++) {\n    // Count up positive cases\n    aggregator += bins[i];\n\n    // response[i] = aggregator/tot_pos_cases; // this was the gains ones\n    // response[i] = aggregator;\n    response[i] = bins[i];\n  }\n  return response;\n}\n\n\n",
      "metric": "Num responses",
      "title": "Response deciles",
      "resolution": 10,
      "unit": "none",
      "xAxisDecimalPlaces": 0,
      "yAxisDecimalPlaces": 2,
      "minRange": 0,
      "maxRange": 100,
      "seriesType": "bar",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": false,
      "showBaseline": false,
      "description": "The profit of a targeted marketing campaign. This calculated in a simple way that can be expanded upon -- currently, with an overall average TP win and FP cost (cost of contact).",
      "metricTableRowOrder": 1,
      "aspectRatio": null,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "showThreshold": false,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "none",
      "optimizeResolution": false
    },
    {
      "id": "94afbde0-ecc9-47f3-8643-9546d2ebac17",
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the num pos cases below the zoom view\n  var lower_bin = 0;\n  var tot_pos_cases = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    // only up to, and not incl, minrange\n    if (records[i][dependentVariable] === 1) {\n      lower_bin++;\n      tot_pos_cases++;\n    }\n  }\n\n  // After this loop, bins[] holds the number of positive cases in each bin\n  let bins = []; // new var that must be available within generateData()\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins[i]++;\n        tot_pos_cases++;\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the num pos cases above the zoom view\n  var higher_bin = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin++;\n      tot_pos_cases++;\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    tot_pos_cases,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: { bin_size, bins, lower_bin,tot_pos_cases,range_min },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n  for (var i = 0; i < resolution; i++) {\n    // Count up positive cases\n    aggregator += bins[i];\n\n    response[i] = aggregator/tot_pos_cases;\n  }\n  return response;\n}\n\n\n",
      "metric": "Gains (% of responses)",
      "title": "Gains curve",
      "resolution": 2449,
      "unit": "percentage",
      "xAxisDecimalPlaces": 0,
      "yAxisDecimalPlaces": 2,
      "minRange": 0,
      "maxRange": 100,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": true,
      "description": "",
      "metricTableRowOrder": 4,
      "aspectRatio": 1,
      "scaleMetric": false,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": "While answering the user's questions, keep every response very, very short: one sentence maximum. Always respond with a single sentence, without any additional explanation or sentences. ",
      "highlightType": "none",
      "optimizeResolution": true
    },
    {
      "id": "2db67e79-3c40-40c5-ae42-7d426fa37597",
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the num cases below the zoom view\n  var lower_bin = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    // only up to, and not incl, minrange\n    lower_bin++;\n  }\n\n  // After this loop, bins[] holds the number of cases in each bin\n  let bins = []; // new var that must be available within generateData()\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      bins[i]++;\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the num cases above the zoom view\n  var higher_bin = 0;\n  for (i = rec_index; i < records.length; i++) {\n    higher_bin++;\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: { bin_size, bins, lower_bin, range_min },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n  for (var i = 0; i < resolution; i++) {\n    aggregator += bins[i];\n    // response[i] = aggregator/tot_pos_cases; // this was the gains ones\n    // response[i] = aggregator;\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Num contacted",
      "title": "Num customers contacted",
      "resolution": 2449,
      "unit": "none",
      "xAxisDecimalPlaces": 0,
      "yAxisDecimalPlaces": 0,
      "minRange": 0,
      "maxRange": 100,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": false,
      "showInMetricTable": true,
      "showBaseline": false,
      "description": "The profit of a targeted marketing campaign. This calculated in a simple way that can be expanded upon -- currently, with an overall average TP win and FP cost (cost of contact).",
      "metricTableRowOrder": 2,
      "aspectRatio": null,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "none",
      "optimizeResolution": true
    },
    {
      "id": "f8e84792-fc0f-4721-8e50-bb53f2d6d9ae",
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the num pos cases below the zoom view\n  var lower_bin = 0;\n  var tot_pos_cases = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    // only up to, and not incl, minrange\n    if (records[i][dependentVariable] === 1) {\n      lower_bin++;\n      tot_pos_cases++;\n    }\n  }\n\n  // After this loop, bins[] holds the number of positive cases in each bin\n  let bins = []; // new var that must be available within generateData()\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins[i]++;\n        tot_pos_cases++;\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the num pos cases above the zoom view\n  var higher_bin = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin++;\n      tot_pos_cases++;\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    tot_pos_cases,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: {\n      bin_size,\n      bins,\n      lower_bin,\n      tot_pos_cases,\n      range_min,\n    },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n  for (var i = 0; i < resolution; i++) {\n    // Count up positive cases\n    aggregator += bins[i];\n\n    // response[i] = aggregator/tot_pos_cases; // this was the gains ones\n    response[i] = aggregator;\n    // response[i] = bins[i];\n  }\n  return response;\n}\n",
      "metric": "Num responses",
      "title": "Num responses",
      "resolution": 2449,
      "unit": "none",
      "xAxisDecimalPlaces": 0,
      "yAxisDecimalPlaces": 0,
      "minRange": 0,
      "maxRange": 100,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": false,
      "showInMetricTable": true,
      "showBaseline": false,
      "description": "The profit of a targeted marketing campaign. This calculated in a simple way that can be expanded upon -- currently, with an overall average TP win and FP cost (cost of contact).",
      "metricTableRowOrder": 3,
      "aspectRatio": null,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "none",
      "optimizeResolution": true
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the total-gift below the zoom view\n  var lower_bin = 0;\n  var lower_bin_cum_neg = 0;\n  var lower_bin_pos = 0;\n  var lower_bin_neg = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin_pos++;\n      lower_bin += records[i][\"AMOUNT\"];\n    } else {\n      lower_bin_neg++;\n      lower_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  // After this loop, bins[] holds the total-gift in each bin\n  let bins = [];\n  let bins_cum_neg = [];\n  let bins_pos = [];\n  let bins_neg = [];\n  bins_neg[0] = lower_bin_neg;\n  bins_pos[0] = lower_bin_pos;\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  bins_cum_neg[0] = lower_bin_cum_neg;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    bins_cum_neg[i] = 0;\n    bins_neg[i] = 0;\n    bins_pos[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins_pos[i]++;\n        bins[i] += records[rec_index][\"AMOUNT\"];\n      } else {\n        bins_neg[i]++;\n        bins_cum_neg[i] += records[rec_index][\"AMOUNT\"];\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the total-gift above the zoom view\n  var higher_bin = 0;\n  var higher_bin_cum_neg = 0;\n  var higher_bin_pos = 0;\n  var higher_bin_neg = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin_pos++;\n      higher_bin += records[i][\"AMOUNT\"];\n    } else {\n      higher_bin_neg++;\n      higher_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    lower_bin_pos,\n    lower_bin_neg,\n    higher_bin_pos,\n    higher_bin_neg,\n    lower_bin_cum_neg,\n    bins_cum_neg,\n    higher_bin_cum_neg,\n    bins_pos,\n    bins_neg,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: {\n      bin_size,\n      bins,\n      lower_bin,\n      higher_bin,\n      lower_bin_pos,\n      lower_bin_neg,\n      higher_bin_pos,\n      higher_bin_neg,\n      lower_bin_cum_neg,\n      bins_cum_neg,\n      higher_bin_cum_neg,\n      bins_pos,\n      bins_neg,\n      range_min,\n    },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n\n  var TP_gain =\n    (sliders[\"Gain per correctly treated (true-positive earnings) - percentage\"]\n      .value ?? 0) / 100;\n  var FP_loss = sliders[\"Loss per incorrectly treated (false-positive cost)\"].value ?? 0;\n\n  aggregator += TP_gain * lower_bin;\n  aggregator -= FP_loss * lower_bin_neg;\n\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    aggregator += TP_gain * bins[i];\n    aggregator -= FP_loss * bins_neg[i];\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "8f24fa34-e3f1-4427-9ef8-8479ad0eda3f",
      "title": "Profit Curve B",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 100,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 2,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": null,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the total-gift below the zoom view\n  var lower_bin = 0;\n  var lower_bin_cum_neg = 0;\n  var lower_bin_pos = 0;\n  var lower_bin_neg = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin_pos++;\n      lower_bin += records[i][\"AMOUNT\"];\n    } else {\n      lower_bin_neg++;\n      lower_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  // After this loop, bins[] holds the total-gift in each bin\n  let bins = [];\n  let bins_cum_neg = [];\n  let bins_pos = [];\n  let bins_neg = [];\n  bins_neg[0] = lower_bin_neg;\n  bins_pos[0] = lower_bin_pos;\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  bins_cum_neg[0] = lower_bin_cum_neg;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    bins_cum_neg[i] = 0;\n    bins_neg[i] = 0;\n    bins_pos[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins_pos[i]++;\n        bins[i] += records[rec_index][\"AMOUNT\"];\n      } else {\n        bins_neg[i]++;\n        bins_cum_neg[i] += records[rec_index][\"AMOUNT\"];\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the total-gift above the zoom view\n  var higher_bin = 0;\n  var higher_bin_cum_neg = 0;\n  var higher_bin_pos = 0;\n  var higher_bin_neg = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin_pos++;\n      higher_bin += records[i][\"AMOUNT\"];\n    } else {\n      higher_bin_neg++;\n      higher_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    lower_bin_pos,\n    lower_bin_neg,\n    higher_bin_pos,\n    higher_bin_neg,\n    lower_bin_cum_neg,\n    bins_cum_neg,\n    higher_bin_cum_neg,\n    bins_pos,\n    bins_neg,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: {\n      bin_size,\n      bins,\n      lower_bin,\n      higher_bin,\n      lower_bin_pos,\n      lower_bin_neg,\n      higher_bin_pos,\n      higher_bin_neg,\n      lower_bin_cum_neg,\n      bins_cum_neg,\n      higher_bin_cum_neg,\n      bins_pos,\n      bins_neg,\n      range_min,\n    },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n\n  var TP_gain =\n    (sliders[\"Gain per correctly treated (true-positive earnings) - percentage\"]\n      .value ?? 0) / 100;\n  var FP_loss = (sliders[\"Loss per incorrectly treated (false-positive cost) - percentage\"].value ?? 0) / 100;\n\n  aggregator += TP_gain * lower_bin;\n  aggregator -= FP_loss * lower_bin_cum_neg;\n\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    aggregator += TP_gain * bins[i];\n    aggregator -= FP_loss * bins_cum_neg[i];\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "49adfed8-4e6d-4659-8cd2-ab1048b09d53",
      "title": "Profit Curve C",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 100,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 2,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": null,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the num pos cases below the zoom view\n  var lower_bin = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin++;\n    }\n  }\n  // After this loop, bins[] holds the number of positive cases in each bin\n  let bins = [];\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins[i]++;\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the num pos cases above the zoom view\n  var higher_bin = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin++;\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: { bin_size, bins, lower_bin, range_min },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n  aggregator +=\n    lower_bin *\n    (sliders[\"Gain per correctly treated (true-positive earnings)\"].value ?? 0);\n  aggregator -= range_min * (sliders[\"Cost per treatment\"].value ?? 0);\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    // For each positive case, add slider-1's value:\n    aggregator +=\n      bins[i] *\n      (sliders[\"Gain per correctly treated (true-positive earnings)\"].value ??\n        0);\n\n    // For each  case, subtract slider-1's value:\n    aggregator -= bin_size * (sliders[\"Cost per treatment\"].value ?? 0);\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "579562d5-4d73-4f3a-bfe6-a69d1b4c17e5",
      "title": "Profit Curve D",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 9.595213473186586,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 0,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": "The profit of a targeted marketing campaign. This calculated in a simple way that can be expanded upon -- currently, with an overall average TP win and FP cost (cost of contact).",
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": "You are a chatbot embedded within a software product called Gooder AI. Here is the background information you need in order to serve Gooder AI's user, followed by guidance on how pithy you must keep your responses.\n\nGooder AI is the business-user console for predictive analytics (aka predictive AI) projects. Data scientists always evaluate their machine learning models, but almost never valuate them. Evaluating and valuating models are two very different things. To valuate a model is to test its performance in terms of business metrics and KPIs like profit and savings, rather than only evaluating the model in terms of technical metrics (like precision, recall, F-score, and AUC). Business metrics and KPIs are critical because, if you aren't measuring the business value, you're not pursuing business value. \n\nYour purpose is to help the user understand and get value from the Gooder AI product, including the chart included here. The user can see the chart as well as other charts and tables. \n\nEvery predictive AI project can be defined by two main things: what's predicted by an ML model and what's done about. For this project, the model predicts which customer will buy if contacted, and what's done about it, the deployment, will be to target marketing with the model. \n\nThe chart's horizontal coordinate represents the percentage of customers contacted with marketing. It orders the customers by model score: From left to right, it orders customers predicted most likely to buy if contacted down to least likely. Each model output, a predictive score, is the probability the customer will buy if contacted. So the horizontal axis represents the user's range of options for model deployment; by setting a decision threshold, the user can determine how many customers are contacted. \n\nThe user can change the percent contacted by moving a vertical line called the \"decision threshold\" left and right across the chart (although that is not shown in the version of the chart image given to you). Moving that vertical line selects a horizontal position on the chart, but does not change the values on the chart or the shape of the curve(s). However, there are other business metrics besides profit that do change when the user changes the threshold position, such as the budget needed for the marketing campaign, that is, how much it will cost to contact that many customers. Gooder AI displays those other metrics for the user elsewhere. Since the user must strike a tradeoff between various metrics for any choice of decision threshold, we can say that the metrics are competing. By moving the decision threshold, the user can view the tradeoffs between competing metrics. \n\nThis and other charts plot a metric on the vertical axis against the percent contacted, which provides an intuitive view for the user. In model deployment, that percent will be enacted with a decision threshold. A higher threshold means the model is used to target more narrowly. The Gooder AI product can provide to the user the decision threshold corresponding with the selected percent contacted, in another function outside the chart shown to you. \n\nThe profit (vertical coordinate) is calculated for each percent contacted with a simple formula: the number of customers contacted times the cost of contact (a parameter the user can change), plus the number of customers who respond times the profit per response (another parameter the user can change). The result is scaled based on the specified population size, which is another parameter the user can change. \n\nThe cost of contact and the profit per response are expressed as dollar amounts.\n\nTo make these calculations, the product has the actuals on which customers actually responded. The actuals are within a test set of examples provided by the user. While ML models are always evaluated with a test set, Gooder AI's unique contribution is to use a test set to also valuate models in terms of business metrics like profit and savings. \n\nTherefore, the profit shown is an estimated forecast of the value the model would deliver when deployed, applied across a set of customers, where the set has the given population size. \n\nA prompt hidden from the user will provide you with the settings for these parameters, updating you on their values when the user changes one or more of them.\n\nWith this chart, Gooder AI provides the user with unique visibility: the range of possible decision threshold settings and the forecasted business value at each setting. This view is important, but rarely generated for enterprise machine learning or predictive AI projects. Gooder AI is the only off-the-shelf software solution for creating such views and related interactive capabilities. \n\nThe user can adjust the parameters that affect the metric calculations by moving sliders within the Gooder AI user interface (not shown within the chart image shared with you). Therefore, the parameter settings change the shape of the curve(s) shown in the chart. As the user moves the sliders, the chart's curve(s)  smoothly change in real-time, allowing the user an interactive experience that provides an intuitive sense of how the parameter settings affect forecasted metric values. That interactive capability is unique to Gooder AI. \n\nWith this interactive visualization, Gooder AI uniquely solves two problems: (1) Model development can pursue business value, since each iteration of model training can be assessed in terms of business metrics. This makes it possible to navigate model development toward business value. And (2) model deployment can be planned according to business value by business stakeholders. This makes it possible to determine whether there is a model that performs well enough for deployment, which model would be best to deploy, and what decision threshold to apply in deployment. \n\nSince this visibility is understandable to non-data scientists and is relevant to line of business managers and other business stakeholders, Gooder AI serves as the business user console for enterprise machine learning projects.\n\nWhile answering the user's questions, keep every response very, very short: one sentence maximum. Always respond with a single sentence, without any additional explanation or sentences. ",
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the total-gift below the zoom view\n  var lower_bin = 0;\n  var lower_bin_cum_neg = 0;\n  var lower_bin_pos = 0;\n  var lower_bin_neg = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin_pos++;\n      lower_bin += records[i][\"AMOUNT\"];\n    } else {\n      lower_bin_neg++;\n      lower_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  // After this loop, bins[] holds the total-gift in each bin\n  let bins = [];\n  let bins_cum_neg = [];\n  let bins_pos = [];\n  let bins_neg = [];\n  bins_neg[0] = lower_bin_neg;\n  bins_pos[0] = lower_bin_pos;\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  bins_cum_neg[0] = lower_bin_cum_neg;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    bins_cum_neg[i] = 0;\n    bins_neg[i] = 0;\n    bins_pos[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins_pos[i]++;\n        bins[i] += records[rec_index][\"AMOUNT\"];\n      } else {\n        bins_neg[i]++;\n        bins_cum_neg[i] += records[rec_index][\"AMOUNT\"];\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the total-gift above the zoom view\n  var higher_bin = 0;\n  var higher_bin_cum_neg = 0;\n  var higher_bin_pos = 0;\n  var higher_bin_neg = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin_pos++;\n      higher_bin += records[i][\"AMOUNT\"];\n    } else {\n      higher_bin_neg++;\n      higher_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    lower_bin_pos,\n    lower_bin_neg,\n    higher_bin_pos,\n    higher_bin_neg,\n    lower_bin_cum_neg,\n    bins_cum_neg,\n    higher_bin_cum_neg,\n    bins_pos,\n    bins_neg,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: {\n      bin_size,\n      bins,\n      lower_bin,\n      higher_bin,\n      lower_bin_pos,\n      lower_bin_neg,\n      higher_bin_pos,\n      higher_bin_neg,\n      lower_bin_cum_neg,\n      bins_cum_neg,\n      higher_bin_cum_neg,\n      bins_pos,\n      bins_neg,\n      range_min,\n    },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n\n  var TP_gain =\n    (sliders[\"Gain per correctly treated (true-positive earnings) - percentage\"]\n      .value ?? 0) / 100;\n  var FP_loss = sliders[\"Cost per treatment\"].value ?? 0;\n\n  aggregator += TP_gain * lower_bin;\n  aggregator -= FP_loss * range_min;\n\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    aggregator += TP_gain * bins[i];\n    aggregator -= FP_loss * bin_size;\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "2f897f6a-1a88-4016-8cc0-0f4bfe440007",
      "title": "Profit Curve E",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 100,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 2,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": null,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the total-gift below the zoom view\n  var lower_bin = 0;\n  var lower_bin_cum_neg = 0;\n  var lower_bin_pos = 0;\n  var lower_bin_neg = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin_pos++;\n      lower_bin += records[i][\"AMOUNT\"];\n    } else {\n      lower_bin_neg++;\n      lower_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  // After this loop, bins[] holds the total-gift in each bin\n  let bins = [];\n  let bins_cum_neg = [];\n  let bins_pos = [];\n  let bins_neg = [];\n  bins_neg[0] = lower_bin_neg;\n  bins_pos[0] = lower_bin_pos;\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  bins_cum_neg[0] = lower_bin_cum_neg;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    bins_cum_neg[i] = 0;\n    bins_neg[i] = 0;\n    bins_pos[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins_pos[i]++;\n        bins[i] += records[rec_index][\"AMOUNT\"];\n      } else {\n        bins_neg[i]++;\n        bins_cum_neg[i] += records[rec_index][\"AMOUNT\"];\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the total-gift above the zoom view\n  var higher_bin = 0;\n  var higher_bin_cum_neg = 0;\n  var higher_bin_pos = 0;\n  var higher_bin_neg = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin_pos++;\n      higher_bin += records[i][\"AMOUNT\"];\n    } else {\n      higher_bin_neg++;\n      higher_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    lower_bin_pos,\n    lower_bin_neg,\n    higher_bin_pos,\n    higher_bin_neg,\n    lower_bin_cum_neg,\n    bins_cum_neg,\n    higher_bin_cum_neg,\n    bins_pos,\n    bins_neg,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: {\n      bin_size,\n      bins,\n      lower_bin,\n      higher_bin,\n      lower_bin_pos,\n      lower_bin_neg,\n      higher_bin_pos,\n      higher_bin_neg,\n      lower_bin_cum_neg,\n      bins_cum_neg,\n      higher_bin_cum_neg,\n      bins_pos,\n      bins_neg,\n      range_min,\n    },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n\n  var TP_gain =\n    (sliders[\"Gain per correctly treated (true-positive earnings) - percentage\"]\n      .value ?? 0) / 100;\n  var FP_loss = (sliders[\"Cost per treatment - percentage\"].value ?? 0) / 100;\n\n  aggregator += TP_gain * lower_bin;\n  aggregator -= FP_loss * (lower_bin + lower_bin_cum_neg);\n\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    aggregator += TP_gain * bins[i];\n    aggregator -= FP_loss * (bins[i] + bins_cum_neg[i]);\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "53638649-4c64-46de-a425-96c2ffc1c976",
      "title": "Profit Curve F",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 100,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 2,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": null,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the num pos cases below the zoom view\n  var lower_bin = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin++;\n    }\n  }\n  // After this loop, bins[] holds the number of positive cases in each bin\n  let bins = [];\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins[i]++;\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the num pos cases above the zoom view\n  var higher_bin = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin++;\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: { bin_size, bins, lower_bin, range_min },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n\n  let factor =\n    (sliders[\"Effectiveness of treatment - percentage\"].value ?? 0) / 100;\n\n  aggregator +=\n    factor * lower_bin *\n    (sliders[\"Gain per correctly treated (true-positive earnings)\"].value ?? 0);\n  aggregator -=\n    (range_min - lower_bin) *\n    (sliders[\"Loss per incorrectly treated (false-positive cost)\"].value ?? 0);\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    // For each positive case, add slider-1's value:\n    aggregator +=\n      bins[i] * factor *\n      (sliders[\"Gain per correctly treated (true-positive earnings)\"].value ??\n        0);\n\n    // For each negative case, subtract slider-1's value:\n    aggregator -=\n      (bin_size - bins[i]) *\n      (sliders[\"Loss per incorrectly treated (false-positive cost)\"].value ??\n        0);\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "7110f5af-74a2-493e-9048-a6336be22c77",
      "title": "Profit Curve G",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 9.595213473186586,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 0,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": "The profit of a targeted marketing campaign. This calculated in a simple way that can be expanded upon -- currently, with an overall average TP win and FP cost (cost of contact).",
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": "You are a chatbot embedded within a software product called Gooder AI. Here is the background information you need in order to serve Gooder AI's user, followed by guidance on how pithy you must keep your responses.\n\nGooder AI is the business-user console for predictive analytics (aka predictive AI) projects. Data scientists always evaluate their machine learning models, but almost never valuate them. Evaluating and valuating models are two very different things. To valuate a model is to test its performance in terms of business metrics and KPIs like profit and savings, rather than only evaluating the model in terms of technical metrics (like precision, recall, F-score, and AUC). Business metrics and KPIs are critical because, if you aren't measuring the business value, you're not pursuing business value. \n\nYour purpose is to help the user understand and get value from the Gooder AI product, including the chart included here. The user can see the chart as well as other charts and tables. \n\nEvery predictive AI project can be defined by two main things: what's predicted by an ML model and what's done about. For this project, the model predicts which customer will buy if contacted, and what's done about it, the deployment, will be to target marketing with the model. \n\nThe chart's horizontal coordinate represents the percentage of customers contacted with marketing. It orders the customers by model score: From left to right, it orders customers predicted most likely to buy if contacted down to least likely. Each model output, a predictive score, is the probability the customer will buy if contacted. So the horizontal axis represents the user's range of options for model deployment; by setting a decision threshold, the user can determine how many customers are contacted. \n\nThe user can change the percent contacted by moving a vertical line called the \"decision threshold\" left and right across the chart (although that is not shown in the version of the chart image given to you). Moving that vertical line selects a horizontal position on the chart, but does not change the values on the chart or the shape of the curve(s). However, there are other business metrics besides profit that do change when the user changes the threshold position, such as the budget needed for the marketing campaign, that is, how much it will cost to contact that many customers. Gooder AI displays those other metrics for the user elsewhere. Since the user must strike a tradeoff between various metrics for any choice of decision threshold, we can say that the metrics are competing. By moving the decision threshold, the user can view the tradeoffs between competing metrics. \n\nThis and other charts plot a metric on the vertical axis against the percent contacted, which provides an intuitive view for the user. In model deployment, that percent will be enacted with a decision threshold. A higher threshold means the model is used to target more narrowly. The Gooder AI product can provide to the user the decision threshold corresponding with the selected percent contacted, in another function outside the chart shown to you. \n\nThe profit (vertical coordinate) is calculated for each percent contacted with a simple formula: the number of customers contacted times the cost of contact (a parameter the user can change), plus the number of customers who respond times the profit per response (another parameter the user can change). The result is scaled based on the specified population size, which is another parameter the user can change. \n\nThe cost of contact and the profit per response are expressed as dollar amounts.\n\nTo make these calculations, the product has the actuals on which customers actually responded. The actuals are within a test set of examples provided by the user. While ML models are always evaluated with a test set, Gooder AI's unique contribution is to use a test set to also valuate models in terms of business metrics like profit and savings. \n\nTherefore, the profit shown is an estimated forecast of the value the model would deliver when deployed, applied across a set of customers, where the set has the given population size. \n\nA prompt hidden from the user will provide you with the settings for these parameters, updating you on their values when the user changes one or more of them.\n\nWith this chart, Gooder AI provides the user with unique visibility: the range of possible decision threshold settings and the forecasted business value at each setting. This view is important, but rarely generated for enterprise machine learning or predictive AI projects. Gooder AI is the only off-the-shelf software solution for creating such views and related interactive capabilities. \n\nThe user can adjust the parameters that affect the metric calculations by moving sliders within the Gooder AI user interface (not shown within the chart image shared with you). Therefore, the parameter settings change the shape of the curve(s) shown in the chart. As the user moves the sliders, the chart's curve(s)  smoothly change in real-time, allowing the user an interactive experience that provides an intuitive sense of how the parameter settings affect forecasted metric values. That interactive capability is unique to Gooder AI. \n\nWith this interactive visualization, Gooder AI uniquely solves two problems: (1) Model development can pursue business value, since each iteration of model training can be assessed in terms of business metrics. This makes it possible to navigate model development toward business value. And (2) model deployment can be planned according to business value by business stakeholders. This makes it possible to determine whether there is a model that performs well enough for deployment, which model would be best to deploy, and what decision threshold to apply in deployment. \n\nSince this visibility is understandable to non-data scientists and is relevant to line of business managers and other business stakeholders, Gooder AI serves as the business user console for enterprise machine learning projects.\n\nWhile answering the user's questions, keep every response very, very short: one sentence maximum. Always respond with a single sentence, without any additional explanation or sentences. ",
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the total-gift below the zoom view\n  var lower_bin = 0;\n  var lower_bin_cum_neg = 0;\n  var lower_bin_pos = 0;\n  var lower_bin_neg = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin_pos++;\n      lower_bin += records[i][\"AMOUNT\"];\n    } else {\n      lower_bin_neg++;\n      lower_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  // After this loop, bins[] holds the total-gift in each bin\n  let bins = [];\n  let bins_cum_neg = [];\n  let bins_pos = [];\n  let bins_neg = [];\n  bins_neg[0] = lower_bin_neg;\n  bins_pos[0] = lower_bin_pos;\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  bins_cum_neg[0] = lower_bin_cum_neg;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    bins_cum_neg[i] = 0;\n    bins_neg[i] = 0;\n    bins_pos[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins_pos[i]++;\n        bins[i] += records[rec_index][\"AMOUNT\"];\n      } else {\n        bins_neg[i]++;\n        bins_cum_neg[i] += records[rec_index][\"AMOUNT\"];\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the total-gift above the zoom view\n  var higher_bin = 0;\n  var higher_bin_cum_neg = 0;\n  var higher_bin_pos = 0;\n  var higher_bin_neg = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin_pos++;\n      higher_bin += records[i][\"AMOUNT\"];\n    } else {\n      higher_bin_neg++;\n      higher_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    lower_bin_pos,\n    lower_bin_neg,\n    higher_bin_pos,\n    higher_bin_neg,\n    lower_bin_cum_neg,\n    bins_cum_neg,\n    higher_bin_cum_neg,\n    bins_pos,\n    bins_neg,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: {\n      bin_size,\n      bins,\n      lower_bin,\n      higher_bin,\n      lower_bin_pos,\n      lower_bin_neg,\n      higher_bin_pos,\n      higher_bin_neg,\n      lower_bin_cum_neg,\n      bins_cum_neg,\n      higher_bin_cum_neg,\n      bins_pos,\n      bins_neg,\n      range_min,\n    },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n\n  let factor =\n    (sliders[\"Effectiveness of treatment - percentage\"].value ?? 0) / 100;\n\n  var TP_gain = factor *\n    (sliders[\"Gain per correctly treated (true-positive earnings) - percentage\"]\n      .value ?? 0) / 100;\n  var FP_loss =\n    sliders[\"Loss per incorrectly treated (false-positive cost)\"].value ?? 0;\n\n  aggregator += TP_gain * lower_bin;\n  aggregator -= FP_loss * lower_bin_neg;\n\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    aggregator += TP_gain * bins[i];\n    aggregator -= FP_loss * bins_neg[i];\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "23eaed6c-2269-47b7-b2d1-25fd8f3345df",
      "title": "Profit Curve H",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 100,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 2,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": null,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const { dependentVariable, records, resolution, minRange, maxRange } = params;\n\n  // After this loop, lower_bin holds the total-gift below the zoom view\n  var lower_bin = 0;\n  var lower_bin_cum_neg = 0;\n  var lower_bin_pos = 0;\n  var lower_bin_neg = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin_pos++;\n      lower_bin += records[i][\"AMOUNT\"];\n    } else {\n      lower_bin_neg++;\n      lower_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  // After this loop, bins[] holds the total-gift in each bin\n  let bins = [];\n  let bins_cum_neg = [];\n  let bins_pos = [];\n  let bins_neg = [];\n  bins_neg[0] = lower_bin_neg;\n  bins_pos[0] = lower_bin_pos;\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins[0] = lower_bin;\n  bins_cum_neg[0] = lower_bin_cum_neg;\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i < resolution; i++) {\n    bins[i] = 0;\n    bins_cum_neg[i] = 0;\n    bins_neg[i] = 0;\n    bins_pos[i] = 0;\n    for (var j = 0; j < bin_size; j++) {\n      // Note that it must only access datapoints 0 through resolution-2\n      if (records[rec_index][dependentVariable] === 1) {\n        bins_pos[i]++;\n        bins[i] += records[rec_index][\"AMOUNT\"];\n      } else {\n        bins_neg[i]++;\n        bins_cum_neg[i] += records[rec_index][\"AMOUNT\"];\n      }\n      rec_index++;\n    }\n  }\n\n  // After this loop, higher_bin holds the total-gift above the zoom view\n  var higher_bin = 0;\n  var higher_bin_cum_neg = 0;\n  var higher_bin_pos = 0;\n  var higher_bin_neg = 0;\n  for (i = rec_index; i < records.length; i++) {\n    if (records[i][dependentVariable] === 1) {\n      higher_bin_pos++;\n      higher_bin += records[i][\"AMOUNT\"];\n    } else {\n      higher_bin_neg++;\n      higher_bin_cum_neg += records[i][\"AMOUNT\"];\n    }\n  }\n\n  return {\n    bins,\n    bin_size,\n    lower_bin,\n    higher_bin,\n    lower_bin_pos,\n    lower_bin_neg,\n    higher_bin_pos,\n    higher_bin_neg,\n    lower_bin_cum_neg,\n    bins_cum_neg,\n    higher_bin_cum_neg,\n    bins_pos,\n    bins_neg,\n    range_min: minRange,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: {\n      bin_size,\n      bins,\n      lower_bin,\n      higher_bin,\n      lower_bin_pos,\n      lower_bin_neg,\n      higher_bin_pos,\n      higher_bin_neg,\n      lower_bin_cum_neg,\n      bins_cum_neg,\n      higher_bin_cum_neg,\n      bins_pos,\n      bins_neg,\n      range_min,\n    },\n  } = params;\n  let response = [];\n  let aggregator = 0;\n\n  let factor =\n    (sliders[\"Effectiveness of treatment - percentage\"].value ?? 0) / 100;\n\n  var TP_gain = factor *\n    (sliders[\"Gain per correctly treated (true-positive earnings) - percentage\"]\n      .value ?? 0) / 100;\n  var FP_loss =\n    (sliders[\"Loss per incorrectly treated (false-positive cost) - percentage\"]\n      .value ?? 0) / 100;\n\n  aggregator += TP_gain * lower_bin;\n  aggregator -= FP_loss * lower_bin_cum_neg;\n\n  response[0] = aggregator;\n  for (var i = 1; i < resolution; i++) {\n    aggregator += TP_gain * bins[i];\n    aggregator -= FP_loss * bins_cum_neg[i];\n\n    response[i] = aggregator;\n  }\n  return response;\n}\n",
      "metric": "Profit",
      "id": "d6521901-e6c7-4c06-ad05-1cb8cf7d610e",
      "title": "Profit Curve I",
      "resolution": 1000,
      "unit": "currency",
      "minRange": 0,
      "maxRange": 100,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 2,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": true,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": null,
      "description": null,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "max",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    },
    {
      "dataInitializationCode": "function initializeWidget(params) {\n  const {\n    scoreVariable,\n    dependentVariable,\n    records,\n    resolution,\n    minRange,\n    maxRange,\n  } = params;\n\n  let response = [];\n  var num_pos = 0;\n\n  // THIS LOOPS CAN BE CUT -- NOT USED FOR DECISION THRESHOLD\n  // After this loop, lower_bin holds the num pos/neg cases below the zoom view\n  var lower_bin_pos = 0;\n  var lower_bin_neg = 0;\n  for (var i = 0; i < minRange - 1; i++) {\n    if (records[i][dependentVariable] === 1) {\n      lower_bin_pos++;\n      num_pos++;\n    } else {\n      lower_bin_neg++;\n    }\n  }\n\n  var lowerbinlastindex = Math.max(Math.floor(minRange) - 1, 0);\n  // Last of lower bin: records[lowerbinlastindex][scoreVariable]\n  var previous_last = records[lowerbinlastindex][scoreVariable];\n  //  response[0] = Math.min(1, records[0][scoreVariable]);\n\n  // After this loop, bins[] holds the number of pos/neg cases in each bin\n  let bins_pos = [];\n  let bins_neg = [];\n  let bin_size = Math.floor((maxRange - minRange) / (resolution - 1));\n  bins_pos[0] = 0;\n  bins_neg[0] = lower_bin_neg;\n\n  var rec_index = i; // pickup where last loop stopped\n  for (let i = 1; i <= resolution; i++) {\n    // the first of this bin\n    if (rec_index < records.length)\n      var this_first = records[rec_index][scoreVariable];\n    else this_first = Math.max(0, records[records.length - 1][scoreVariable]);\n\n    response[i - 1] = (previous_last + this_first) / 2;\n\n    if (rec_index + bin_size < records.length)\n      previous_last = records[rec_index + bin_size][scoreVariable];\n\n    rec_index += bin_size;\n  }\n\n  return {\n    bins_pos,\n    bins_neg,\n    bin_size,\n    num_pos,\n    range_min: minRange,\n    response,\n  };\n}\n",
      "metricCalculationCode": "function userInputFunction(params) {\n  const {\n    sliders,\n    resolution,\n    initializationResult: { bin_size, bins_pos, bins_neg, lower_bin_pos,\n        range_min,\n\tresponse},\n  } = params;\n\n  return response;\n}\n\n\n",
      "metric": "Decision threshold",
      "id": "d97ad6f2-5924-4413-b5b7-0a75e1bd6e94",
      "title": "Decision threshold",
      "resolution": 1000,
      "unit": "none",
      "minRange": 0,
      "maxRange": 100,
      "yAxisDecimalPlaces": 2,
      "xAxisDecimalPlaces": 2,
      "seriesType": "line",
      "showRangeSlider": false,
      "showInDashboard": true,
      "showInMetricTable": true,
      "showBaseline": false,
      "scaleMetric": false,
      "suppressBar": true,
      "suppressXAxisLabel": true,
      "aspectRatio": 1,
      "description": null,
      "showThreshold": true,
      "reverseXAxis": false,
      "aiPrompt": null,
      "highlightType": "none",
      "optimizeResolution": true,
      "metricTableRowOrder": 0
    }
  ]
}