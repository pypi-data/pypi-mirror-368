# coding: utf-8

"""
    Inventory

    No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

    The version of the OpenAPI document: 1.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

import warnings
from pydantic import validate_call, Field, StrictFloat, StrictStr, StrictInt
from typing import Any, Dict, List, Optional, Tuple, Union
from typing_extensions import Annotated

from datetime import datetime
from pydantic import Field, StrictBool, StrictFloat, StrictInt, StrictStr
from typing import Any, List, Optional, Union
from typing_extensions import Annotated
from legit_api_client.models.control_classification import ControlClassification
from legit_api_client.models.customer_facing_issue_dto import CustomerFacingIssueDto
from legit_api_client.models.customer_facing_issues_page_dto import CustomerFacingIssuesPageDto
from legit_api_client.models.dependency_fix_type import DependencyFixType
from legit_api_client.models.issue_origin_params import IssueOriginParams
from legit_api_client.models.issue_status import IssueStatus
from legit_api_client.models.issue_type import IssueType
from legit_api_client.models.severity import Severity

from legit_api_client.api_client import ApiClient, RequestSerialized
from legit_api_client.api_response import ApiResponse
from legit_api_client.rest import RESTResponseType


class IssuesV2Api:
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None) -> None:
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client


    @validate_call
    def get_additional_data_by_issue_by_id(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> object:
        """Get additional data on issue by id

        Get specific data on the issue, response structure can change per issue

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_additional_data_by_issue_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_additional_data_by_issue_by_id_with_http_info(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[object]:
        """Get additional data on issue by id

        Get specific data on the issue, response structure can change per issue

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_additional_data_by_issue_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_additional_data_by_issue_by_id_without_preload_content(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get additional data on issue by id

        Get specific data on the issue, response structure can change per issue

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_additional_data_by_issue_by_id_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "object",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_additional_data_by_issue_by_id_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2.0/issues/{id}/additional-data',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_issue_by_id_v2(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerFacingIssueDto:
        """Get Issue data by id

        Get a single Issue data by the issue's Id

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issue_by_id_v2_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerFacingIssueDto",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_issue_by_id_v2_with_http_info(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerFacingIssueDto]:
        """Get Issue data by id

        Get a single Issue data by the issue's Id

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issue_by_id_v2_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerFacingIssueDto",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_issue_by_id_v2_without_preload_content(
        self,
        id: StrictStr,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get Issue data by id

        Get a single Issue data by the issue's Id

        :param id: (required)
        :type id: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issue_by_id_v2_serialize(
            id=id,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerFacingIssueDto",
            '404': None,
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_issue_by_id_v2_serialize(
        self,
        id,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        if id is not None:
            _path_params['id'] = id
        # process the query parameters
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2.0/issues/{id}',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_issues_count(
        self,
        title: Optional[StrictStr] = None,
        title_search: Annotated[Optional[StrictStr], Field(description="Filter issues that their title contains the given string")] = None,
        issue_types: Annotated[Optional[List[IssueType]], Field(description="Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone")] = None,
        severities: Annotated[Optional[List[Severity]], Field(description="Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone")] = None,
        policy_severity: Optional[Any] = None,
        statuses: Annotated[Optional[List[IssueStatus]], Field(description="Filter issues that their status is in the given list. To filter for a specific status provide it here alone")] = None,
        detected_from_date: Annotated[Optional[datetime], Field(description="Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        detected_to_date: Annotated[Optional[datetime], Field(description="Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        opening_reason: Optional[Any] = None,
        last_action_time_from_date: Annotated[Optional[datetime], Field(description="Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        last_action_time_to_date: Annotated[Optional[datetime], Field(description="Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        closing_reason: Optional[Any] = None,
        closing_location: Optional[Any] = None,
        workspace_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter issues that their WorkspaceId is in the given list")] = None,
        vulnerable_file: Annotated[Optional[StrictStr], Field(description="Filter issues that originated from the given file")] = None,
        cve_id: Optional[StrictStr] = None,
        min_score: Optional[Union[StrictFloat, StrictInt]] = None,
        min_epss_score: Optional[Union[StrictFloat, StrictInt]] = None,
        dependency_fix_types: Optional[List[DependencyFixType]] = None,
        product_ids: Optional[List[StrictStr]] = None,
        has_ticket: Optional[StrictBool] = None,
        is_assigned: Annotated[Optional[StrictBool], Field(description="Filter issues that have a user assigned to them in the legit platform")] = None,
        is_assigned_to_me: Optional[StrictBool] = None,
        is_triaged: Annotated[Optional[StrictBool], Field(description="Filter issues that have either a user or a ticket assigned to them in the legit platform")] = None,
        assigned_user_id: Optional[StrictStr] = None,
        origin_id: Optional[StrictStr] = None,
        origin_origin_type: Optional[Any] = None,
        origin_type: Optional[Any] = None,
        origins: Annotated[Optional[List[IssueOriginParams]], Field(description="Filter issues that their origin is in the given list")] = None,
        policy_name: Optional[StrictStr] = None,
        action_id: Annotated[Optional[StrictStr], Field(description="Filter issues that are part of the action with the given id")] = None,
        tag: Optional[StrictStr] = None,
        source_name: Optional[StrictStr] = None,
        integration_id: Annotated[Optional[StrictStr], Field(description="Filter issues that were detected by the given integration")] = None,
        source_scanner_ids: Annotated[Optional[List[ControlClassification]], Field(description="Filter issues that their SourceScannerId is in the given list")] = None,
        ai_validation_result: Optional[Any] = None,
        validity_status: Optional[Any] = None,
        validity_check_from_date: Annotated[Optional[datetime], Field(description="Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        validity_check_to_date: Annotated[Optional[datetime], Field(description="Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        file_path: Annotated[Optional[StrictStr], Field(description="Filter issues that their fila-path contains the given string")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> int:
        """Get the issues count

        Get the count of the issues matching the query params filters

        :param title:
        :type title: str
        :param title_search: Filter issues that their title contains the given string
        :type title_search: str
        :param issue_types: Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone
        :type issue_types: List[IssueType]
        :param severities: Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone
        :type severities: List[Severity]
        :param policy_severity:
        :type policy_severity: Severity
        :param statuses: Filter issues that their status is in the given list. To filter for a specific status provide it here alone
        :type statuses: List[IssueStatus]
        :param detected_from_date: Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type detected_from_date: datetime
        :param detected_to_date: Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type detected_to_date: datetime
        :param opening_reason:
        :type opening_reason: IssueOpeningReasonDto
        :param last_action_time_from_date: Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type last_action_time_from_date: datetime
        :param last_action_time_to_date: Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type last_action_time_to_date: datetime
        :param closing_reason:
        :type closing_reason: ClosingReason
        :param closing_location:
        :type closing_location: IssueClosingLocationDto
        :param workspace_ids: Filter issues that their WorkspaceId is in the given list
        :type workspace_ids: List[str]
        :param vulnerable_file: Filter issues that originated from the given file
        :type vulnerable_file: str
        :param cve_id:
        :type cve_id: str
        :param min_score:
        :type min_score: float
        :param min_epss_score:
        :type min_epss_score: float
        :param dependency_fix_types:
        :type dependency_fix_types: List[DependencyFixType]
        :param product_ids:
        :type product_ids: List[str]
        :param has_ticket:
        :type has_ticket: bool
        :param is_assigned: Filter issues that have a user assigned to them in the legit platform
        :type is_assigned: bool
        :param is_assigned_to_me:
        :type is_assigned_to_me: bool
        :param is_triaged: Filter issues that have either a user or a ticket assigned to them in the legit platform
        :type is_triaged: bool
        :param assigned_user_id:
        :type assigned_user_id: str
        :param origin_id:
        :type origin_id: str
        :param origin_origin_type:
        :type origin_origin_type: OriginType
        :param origin_type:
        :type origin_type: OriginType
        :param origins: Filter issues that their origin is in the given list
        :type origins: List[IssueOriginParams]
        :param policy_name:
        :type policy_name: str
        :param action_id: Filter issues that are part of the action with the given id
        :type action_id: str
        :param tag:
        :type tag: str
        :param source_name:
        :type source_name: str
        :param integration_id: Filter issues that were detected by the given integration
        :type integration_id: str
        :param source_scanner_ids: Filter issues that their SourceScannerId is in the given list
        :type source_scanner_ids: List[ControlClassification]
        :param ai_validation_result:
        :type ai_validation_result: AiValidationResult
        :param validity_status:
        :type validity_status: SecretIssueValidityStatus
        :param validity_check_from_date: Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type validity_check_from_date: datetime
        :param validity_check_to_date: Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type validity_check_to_date: datetime
        :param file_path: Filter issues that their fila-path contains the given string
        :type file_path: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issues_count_serialize(
            title=title,
            title_search=title_search,
            issue_types=issue_types,
            severities=severities,
            policy_severity=policy_severity,
            statuses=statuses,
            detected_from_date=detected_from_date,
            detected_to_date=detected_to_date,
            opening_reason=opening_reason,
            last_action_time_from_date=last_action_time_from_date,
            last_action_time_to_date=last_action_time_to_date,
            closing_reason=closing_reason,
            closing_location=closing_location,
            workspace_ids=workspace_ids,
            vulnerable_file=vulnerable_file,
            cve_id=cve_id,
            min_score=min_score,
            min_epss_score=min_epss_score,
            dependency_fix_types=dependency_fix_types,
            product_ids=product_ids,
            has_ticket=has_ticket,
            is_assigned=is_assigned,
            is_assigned_to_me=is_assigned_to_me,
            is_triaged=is_triaged,
            assigned_user_id=assigned_user_id,
            origin_id=origin_id,
            origin_origin_type=origin_origin_type,
            origin_type=origin_type,
            origins=origins,
            policy_name=policy_name,
            action_id=action_id,
            tag=tag,
            source_name=source_name,
            integration_id=integration_id,
            source_scanner_ids=source_scanner_ids,
            ai_validation_result=ai_validation_result,
            validity_status=validity_status,
            validity_check_from_date=validity_check_from_date,
            validity_check_to_date=validity_check_to_date,
            file_path=file_path,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_issues_count_with_http_info(
        self,
        title: Optional[StrictStr] = None,
        title_search: Annotated[Optional[StrictStr], Field(description="Filter issues that their title contains the given string")] = None,
        issue_types: Annotated[Optional[List[IssueType]], Field(description="Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone")] = None,
        severities: Annotated[Optional[List[Severity]], Field(description="Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone")] = None,
        policy_severity: Optional[Any] = None,
        statuses: Annotated[Optional[List[IssueStatus]], Field(description="Filter issues that their status is in the given list. To filter for a specific status provide it here alone")] = None,
        detected_from_date: Annotated[Optional[datetime], Field(description="Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        detected_to_date: Annotated[Optional[datetime], Field(description="Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        opening_reason: Optional[Any] = None,
        last_action_time_from_date: Annotated[Optional[datetime], Field(description="Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        last_action_time_to_date: Annotated[Optional[datetime], Field(description="Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        closing_reason: Optional[Any] = None,
        closing_location: Optional[Any] = None,
        workspace_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter issues that their WorkspaceId is in the given list")] = None,
        vulnerable_file: Annotated[Optional[StrictStr], Field(description="Filter issues that originated from the given file")] = None,
        cve_id: Optional[StrictStr] = None,
        min_score: Optional[Union[StrictFloat, StrictInt]] = None,
        min_epss_score: Optional[Union[StrictFloat, StrictInt]] = None,
        dependency_fix_types: Optional[List[DependencyFixType]] = None,
        product_ids: Optional[List[StrictStr]] = None,
        has_ticket: Optional[StrictBool] = None,
        is_assigned: Annotated[Optional[StrictBool], Field(description="Filter issues that have a user assigned to them in the legit platform")] = None,
        is_assigned_to_me: Optional[StrictBool] = None,
        is_triaged: Annotated[Optional[StrictBool], Field(description="Filter issues that have either a user or a ticket assigned to them in the legit platform")] = None,
        assigned_user_id: Optional[StrictStr] = None,
        origin_id: Optional[StrictStr] = None,
        origin_origin_type: Optional[Any] = None,
        origin_type: Optional[Any] = None,
        origins: Annotated[Optional[List[IssueOriginParams]], Field(description="Filter issues that their origin is in the given list")] = None,
        policy_name: Optional[StrictStr] = None,
        action_id: Annotated[Optional[StrictStr], Field(description="Filter issues that are part of the action with the given id")] = None,
        tag: Optional[StrictStr] = None,
        source_name: Optional[StrictStr] = None,
        integration_id: Annotated[Optional[StrictStr], Field(description="Filter issues that were detected by the given integration")] = None,
        source_scanner_ids: Annotated[Optional[List[ControlClassification]], Field(description="Filter issues that their SourceScannerId is in the given list")] = None,
        ai_validation_result: Optional[Any] = None,
        validity_status: Optional[Any] = None,
        validity_check_from_date: Annotated[Optional[datetime], Field(description="Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        validity_check_to_date: Annotated[Optional[datetime], Field(description="Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        file_path: Annotated[Optional[StrictStr], Field(description="Filter issues that their fila-path contains the given string")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[int]:
        """Get the issues count

        Get the count of the issues matching the query params filters

        :param title:
        :type title: str
        :param title_search: Filter issues that their title contains the given string
        :type title_search: str
        :param issue_types: Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone
        :type issue_types: List[IssueType]
        :param severities: Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone
        :type severities: List[Severity]
        :param policy_severity:
        :type policy_severity: Severity
        :param statuses: Filter issues that their status is in the given list. To filter for a specific status provide it here alone
        :type statuses: List[IssueStatus]
        :param detected_from_date: Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type detected_from_date: datetime
        :param detected_to_date: Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type detected_to_date: datetime
        :param opening_reason:
        :type opening_reason: IssueOpeningReasonDto
        :param last_action_time_from_date: Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type last_action_time_from_date: datetime
        :param last_action_time_to_date: Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type last_action_time_to_date: datetime
        :param closing_reason:
        :type closing_reason: ClosingReason
        :param closing_location:
        :type closing_location: IssueClosingLocationDto
        :param workspace_ids: Filter issues that their WorkspaceId is in the given list
        :type workspace_ids: List[str]
        :param vulnerable_file: Filter issues that originated from the given file
        :type vulnerable_file: str
        :param cve_id:
        :type cve_id: str
        :param min_score:
        :type min_score: float
        :param min_epss_score:
        :type min_epss_score: float
        :param dependency_fix_types:
        :type dependency_fix_types: List[DependencyFixType]
        :param product_ids:
        :type product_ids: List[str]
        :param has_ticket:
        :type has_ticket: bool
        :param is_assigned: Filter issues that have a user assigned to them in the legit platform
        :type is_assigned: bool
        :param is_assigned_to_me:
        :type is_assigned_to_me: bool
        :param is_triaged: Filter issues that have either a user or a ticket assigned to them in the legit platform
        :type is_triaged: bool
        :param assigned_user_id:
        :type assigned_user_id: str
        :param origin_id:
        :type origin_id: str
        :param origin_origin_type:
        :type origin_origin_type: OriginType
        :param origin_type:
        :type origin_type: OriginType
        :param origins: Filter issues that their origin is in the given list
        :type origins: List[IssueOriginParams]
        :param policy_name:
        :type policy_name: str
        :param action_id: Filter issues that are part of the action with the given id
        :type action_id: str
        :param tag:
        :type tag: str
        :param source_name:
        :type source_name: str
        :param integration_id: Filter issues that were detected by the given integration
        :type integration_id: str
        :param source_scanner_ids: Filter issues that their SourceScannerId is in the given list
        :type source_scanner_ids: List[ControlClassification]
        :param ai_validation_result:
        :type ai_validation_result: AiValidationResult
        :param validity_status:
        :type validity_status: SecretIssueValidityStatus
        :param validity_check_from_date: Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type validity_check_from_date: datetime
        :param validity_check_to_date: Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type validity_check_to_date: datetime
        :param file_path: Filter issues that their fila-path contains the given string
        :type file_path: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issues_count_serialize(
            title=title,
            title_search=title_search,
            issue_types=issue_types,
            severities=severities,
            policy_severity=policy_severity,
            statuses=statuses,
            detected_from_date=detected_from_date,
            detected_to_date=detected_to_date,
            opening_reason=opening_reason,
            last_action_time_from_date=last_action_time_from_date,
            last_action_time_to_date=last_action_time_to_date,
            closing_reason=closing_reason,
            closing_location=closing_location,
            workspace_ids=workspace_ids,
            vulnerable_file=vulnerable_file,
            cve_id=cve_id,
            min_score=min_score,
            min_epss_score=min_epss_score,
            dependency_fix_types=dependency_fix_types,
            product_ids=product_ids,
            has_ticket=has_ticket,
            is_assigned=is_assigned,
            is_assigned_to_me=is_assigned_to_me,
            is_triaged=is_triaged,
            assigned_user_id=assigned_user_id,
            origin_id=origin_id,
            origin_origin_type=origin_origin_type,
            origin_type=origin_type,
            origins=origins,
            policy_name=policy_name,
            action_id=action_id,
            tag=tag,
            source_name=source_name,
            integration_id=integration_id,
            source_scanner_ids=source_scanner_ids,
            ai_validation_result=ai_validation_result,
            validity_status=validity_status,
            validity_check_from_date=validity_check_from_date,
            validity_check_to_date=validity_check_to_date,
            file_path=file_path,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_issues_count_without_preload_content(
        self,
        title: Optional[StrictStr] = None,
        title_search: Annotated[Optional[StrictStr], Field(description="Filter issues that their title contains the given string")] = None,
        issue_types: Annotated[Optional[List[IssueType]], Field(description="Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone")] = None,
        severities: Annotated[Optional[List[Severity]], Field(description="Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone")] = None,
        policy_severity: Optional[Any] = None,
        statuses: Annotated[Optional[List[IssueStatus]], Field(description="Filter issues that their status is in the given list. To filter for a specific status provide it here alone")] = None,
        detected_from_date: Annotated[Optional[datetime], Field(description="Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        detected_to_date: Annotated[Optional[datetime], Field(description="Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        opening_reason: Optional[Any] = None,
        last_action_time_from_date: Annotated[Optional[datetime], Field(description="Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        last_action_time_to_date: Annotated[Optional[datetime], Field(description="Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        closing_reason: Optional[Any] = None,
        closing_location: Optional[Any] = None,
        workspace_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter issues that their WorkspaceId is in the given list")] = None,
        vulnerable_file: Annotated[Optional[StrictStr], Field(description="Filter issues that originated from the given file")] = None,
        cve_id: Optional[StrictStr] = None,
        min_score: Optional[Union[StrictFloat, StrictInt]] = None,
        min_epss_score: Optional[Union[StrictFloat, StrictInt]] = None,
        dependency_fix_types: Optional[List[DependencyFixType]] = None,
        product_ids: Optional[List[StrictStr]] = None,
        has_ticket: Optional[StrictBool] = None,
        is_assigned: Annotated[Optional[StrictBool], Field(description="Filter issues that have a user assigned to them in the legit platform")] = None,
        is_assigned_to_me: Optional[StrictBool] = None,
        is_triaged: Annotated[Optional[StrictBool], Field(description="Filter issues that have either a user or a ticket assigned to them in the legit platform")] = None,
        assigned_user_id: Optional[StrictStr] = None,
        origin_id: Optional[StrictStr] = None,
        origin_origin_type: Optional[Any] = None,
        origin_type: Optional[Any] = None,
        origins: Annotated[Optional[List[IssueOriginParams]], Field(description="Filter issues that their origin is in the given list")] = None,
        policy_name: Optional[StrictStr] = None,
        action_id: Annotated[Optional[StrictStr], Field(description="Filter issues that are part of the action with the given id")] = None,
        tag: Optional[StrictStr] = None,
        source_name: Optional[StrictStr] = None,
        integration_id: Annotated[Optional[StrictStr], Field(description="Filter issues that were detected by the given integration")] = None,
        source_scanner_ids: Annotated[Optional[List[ControlClassification]], Field(description="Filter issues that their SourceScannerId is in the given list")] = None,
        ai_validation_result: Optional[Any] = None,
        validity_status: Optional[Any] = None,
        validity_check_from_date: Annotated[Optional[datetime], Field(description="Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        validity_check_to_date: Annotated[Optional[datetime], Field(description="Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        file_path: Annotated[Optional[StrictStr], Field(description="Filter issues that their fila-path contains the given string")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get the issues count

        Get the count of the issues matching the query params filters

        :param title:
        :type title: str
        :param title_search: Filter issues that their title contains the given string
        :type title_search: str
        :param issue_types: Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone
        :type issue_types: List[IssueType]
        :param severities: Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone
        :type severities: List[Severity]
        :param policy_severity:
        :type policy_severity: Severity
        :param statuses: Filter issues that their status is in the given list. To filter for a specific status provide it here alone
        :type statuses: List[IssueStatus]
        :param detected_from_date: Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type detected_from_date: datetime
        :param detected_to_date: Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type detected_to_date: datetime
        :param opening_reason:
        :type opening_reason: IssueOpeningReasonDto
        :param last_action_time_from_date: Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type last_action_time_from_date: datetime
        :param last_action_time_to_date: Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type last_action_time_to_date: datetime
        :param closing_reason:
        :type closing_reason: ClosingReason
        :param closing_location:
        :type closing_location: IssueClosingLocationDto
        :param workspace_ids: Filter issues that their WorkspaceId is in the given list
        :type workspace_ids: List[str]
        :param vulnerable_file: Filter issues that originated from the given file
        :type vulnerable_file: str
        :param cve_id:
        :type cve_id: str
        :param min_score:
        :type min_score: float
        :param min_epss_score:
        :type min_epss_score: float
        :param dependency_fix_types:
        :type dependency_fix_types: List[DependencyFixType]
        :param product_ids:
        :type product_ids: List[str]
        :param has_ticket:
        :type has_ticket: bool
        :param is_assigned: Filter issues that have a user assigned to them in the legit platform
        :type is_assigned: bool
        :param is_assigned_to_me:
        :type is_assigned_to_me: bool
        :param is_triaged: Filter issues that have either a user or a ticket assigned to them in the legit platform
        :type is_triaged: bool
        :param assigned_user_id:
        :type assigned_user_id: str
        :param origin_id:
        :type origin_id: str
        :param origin_origin_type:
        :type origin_origin_type: OriginType
        :param origin_type:
        :type origin_type: OriginType
        :param origins: Filter issues that their origin is in the given list
        :type origins: List[IssueOriginParams]
        :param policy_name:
        :type policy_name: str
        :param action_id: Filter issues that are part of the action with the given id
        :type action_id: str
        :param tag:
        :type tag: str
        :param source_name:
        :type source_name: str
        :param integration_id: Filter issues that were detected by the given integration
        :type integration_id: str
        :param source_scanner_ids: Filter issues that their SourceScannerId is in the given list
        :type source_scanner_ids: List[ControlClassification]
        :param ai_validation_result:
        :type ai_validation_result: AiValidationResult
        :param validity_status:
        :type validity_status: SecretIssueValidityStatus
        :param validity_check_from_date: Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type validity_check_from_date: datetime
        :param validity_check_to_date: Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type validity_check_to_date: datetime
        :param file_path: Filter issues that their fila-path contains the given string
        :type file_path: str
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issues_count_serialize(
            title=title,
            title_search=title_search,
            issue_types=issue_types,
            severities=severities,
            policy_severity=policy_severity,
            statuses=statuses,
            detected_from_date=detected_from_date,
            detected_to_date=detected_to_date,
            opening_reason=opening_reason,
            last_action_time_from_date=last_action_time_from_date,
            last_action_time_to_date=last_action_time_to_date,
            closing_reason=closing_reason,
            closing_location=closing_location,
            workspace_ids=workspace_ids,
            vulnerable_file=vulnerable_file,
            cve_id=cve_id,
            min_score=min_score,
            min_epss_score=min_epss_score,
            dependency_fix_types=dependency_fix_types,
            product_ids=product_ids,
            has_ticket=has_ticket,
            is_assigned=is_assigned,
            is_assigned_to_me=is_assigned_to_me,
            is_triaged=is_triaged,
            assigned_user_id=assigned_user_id,
            origin_id=origin_id,
            origin_origin_type=origin_origin_type,
            origin_type=origin_type,
            origins=origins,
            policy_name=policy_name,
            action_id=action_id,
            tag=tag,
            source_name=source_name,
            integration_id=integration_id,
            source_scanner_ids=source_scanner_ids,
            ai_validation_result=ai_validation_result,
            validity_status=validity_status,
            validity_check_from_date=validity_check_from_date,
            validity_check_to_date=validity_check_to_date,
            file_path=file_path,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "int",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_issues_count_serialize(
        self,
        title,
        title_search,
        issue_types,
        severities,
        policy_severity,
        statuses,
        detected_from_date,
        detected_to_date,
        opening_reason,
        last_action_time_from_date,
        last_action_time_to_date,
        closing_reason,
        closing_location,
        workspace_ids,
        vulnerable_file,
        cve_id,
        min_score,
        min_epss_score,
        dependency_fix_types,
        product_ids,
        has_ticket,
        is_assigned,
        is_assigned_to_me,
        is_triaged,
        assigned_user_id,
        origin_id,
        origin_origin_type,
        origin_type,
        origins,
        policy_name,
        action_id,
        tag,
        source_name,
        integration_id,
        source_scanner_ids,
        ai_validation_result,
        validity_status,
        validity_check_from_date,
        validity_check_to_date,
        file_path,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'issueTypes': 'multi',
            'severities': 'multi',
            'statuses': 'multi',
            'workspaceIds': 'multi',
            'dependencyFixTypes': 'multi',
            'productIds': 'multi',
            'origins': 'multi',
            'sourceScannerIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if title is not None:
            
            _query_params.append(('title', title))
            
        if title_search is not None:
            
            _query_params.append(('titleSearch', title_search))
            
        if issue_types is not None:
            
            _query_params.append(('issueTypes', issue_types))
            
        if severities is not None:
            
            _query_params.append(('severities', severities))
            
        if policy_severity is not None:
            
            _query_params.append(('policySeverity', policy_severity.value))
            
        if statuses is not None:
            
            _query_params.append(('statuses', statuses))
            
        if detected_from_date is not None:
            if isinstance(detected_from_date, datetime):
                _query_params.append(
                    (
                        'detectedFromDate',
                        detected_from_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('detectedFromDate', detected_from_date))
            
        if detected_to_date is not None:
            if isinstance(detected_to_date, datetime):
                _query_params.append(
                    (
                        'detectedToDate',
                        detected_to_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('detectedToDate', detected_to_date))
            
        if opening_reason is not None:
            
            _query_params.append(('openingReason', opening_reason.value))
            
        if last_action_time_from_date is not None:
            if isinstance(last_action_time_from_date, datetime):
                _query_params.append(
                    (
                        'lastActionTimeFromDate',
                        last_action_time_from_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastActionTimeFromDate', last_action_time_from_date))
            
        if last_action_time_to_date is not None:
            if isinstance(last_action_time_to_date, datetime):
                _query_params.append(
                    (
                        'lastActionTimeToDate',
                        last_action_time_to_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('lastActionTimeToDate', last_action_time_to_date))
            
        if closing_reason is not None:
            
            _query_params.append(('closingReason', closing_reason.value))
            
        if closing_location is not None:
            
            _query_params.append(('closingLocation', closing_location.value))
            
        if workspace_ids is not None:
            
            _query_params.append(('workspaceIds', workspace_ids))
            
        if vulnerable_file is not None:
            
            _query_params.append(('vulnerableFile', vulnerable_file))
            
        if cve_id is not None:
            
            _query_params.append(('cveId', cve_id))
            
        if min_score is not None:
            
            _query_params.append(('minScore', min_score))
            
        if min_epss_score is not None:
            
            _query_params.append(('minEpssScore', min_epss_score))
            
        if dependency_fix_types is not None:
            
            _query_params.append(('dependencyFixTypes', dependency_fix_types))
            
        if product_ids is not None:
            
            _query_params.append(('productIds', product_ids))
            
        if has_ticket is not None:
            
            _query_params.append(('hasTicket', has_ticket))
            
        if is_assigned is not None:
            
            _query_params.append(('isAssigned', is_assigned))
            
        if is_assigned_to_me is not None:
            
            _query_params.append(('isAssignedToMe', is_assigned_to_me))
            
        if is_triaged is not None:
            
            _query_params.append(('isTriaged', is_triaged))
            
        if assigned_user_id is not None:
            
            _query_params.append(('assignedUserId', assigned_user_id))
            
        if origin_id is not None:
            
            _query_params.append(('origin.id', origin_id))
            
        if origin_origin_type is not None:
            
            _query_params.append(('origin.originType', origin_origin_type.value))
            
        if origin_type is not None:
            
            _query_params.append(('originType', origin_type.value))
            
        if origins is not None:
            
            _query_params.append(('origins', origins))
            
        if policy_name is not None:
            
            _query_params.append(('policyName', policy_name))
            
        if action_id is not None:
            
            _query_params.append(('actionId', action_id))
            
        if tag is not None:
            
            _query_params.append(('tag', tag))
            
        if source_name is not None:
            
            _query_params.append(('sourceName', source_name))
            
        if integration_id is not None:
            
            _query_params.append(('integrationId', integration_id))
            
        if source_scanner_ids is not None:
            
            _query_params.append(('sourceScannerIds', source_scanner_ids))
            
        if ai_validation_result is not None:
            
            _query_params.append(('aiValidationResult', ai_validation_result.value))
            
        if validity_status is not None:
            
            _query_params.append(('validityStatus', validity_status.value))
            
        if validity_check_from_date is not None:
            if isinstance(validity_check_from_date, datetime):
                _query_params.append(
                    (
                        'validityCheckFromDate',
                        validity_check_from_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('validityCheckFromDate', validity_check_from_date))
            
        if validity_check_to_date is not None:
            if isinstance(validity_check_to_date, datetime):
                _query_params.append(
                    (
                        'validityCheckToDate',
                        validity_check_to_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('validityCheckToDate', validity_check_to_date))
            
        if file_path is not None:
            
            _query_params.append(('filePath', file_path))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2.0/issues/count',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )




    @validate_call
    def get_issues_v2(
        self,
        issues_query_title: Optional[StrictStr] = None,
        issues_query_title_search: Annotated[Optional[StrictStr], Field(description="Filter issues that their title contains the given string")] = None,
        issues_query_issue_types: Annotated[Optional[List[IssueType]], Field(description="Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone")] = None,
        issues_query_severities: Annotated[Optional[List[Severity]], Field(description="Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone")] = None,
        issues_query_policy_severity: Optional[Any] = None,
        issues_query_statuses: Annotated[Optional[List[IssueStatus]], Field(description="Filter issues that their status is in the given list. To filter for a specific status provide it here alone")] = None,
        issues_query_detected_from_date: Annotated[Optional[datetime], Field(description="Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_detected_to_date: Annotated[Optional[datetime], Field(description="Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_opening_reason: Optional[Any] = None,
        issues_query_last_action_time_from_date: Annotated[Optional[datetime], Field(description="Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_last_action_time_to_date: Annotated[Optional[datetime], Field(description="Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_closing_reason: Optional[Any] = None,
        issues_query_closing_location: Optional[Any] = None,
        issues_query_workspace_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter issues that their WorkspaceId is in the given list")] = None,
        issues_query_vulnerable_file: Annotated[Optional[StrictStr], Field(description="Filter issues that originated from the given file")] = None,
        issues_query_cve_id: Optional[StrictStr] = None,
        issues_query_min_score: Optional[Union[StrictFloat, StrictInt]] = None,
        issues_query_min_epss_score: Optional[Union[StrictFloat, StrictInt]] = None,
        issues_query_dependency_fix_types: Optional[List[DependencyFixType]] = None,
        issues_query_product_ids: Optional[List[StrictStr]] = None,
        issues_query_has_ticket: Optional[StrictBool] = None,
        issues_query_is_assigned: Annotated[Optional[StrictBool], Field(description="Filter issues that have a user assigned to them in the legit platform")] = None,
        issues_query_is_assigned_to_me: Optional[StrictBool] = None,
        issues_query_is_triaged: Annotated[Optional[StrictBool], Field(description="Filter issues that have either a user or a ticket assigned to them in the legit platform")] = None,
        issues_query_assigned_user_id: Optional[StrictStr] = None,
        issues_query_origin_id: Optional[StrictStr] = None,
        issues_query_origin_origin_type: Optional[Any] = None,
        issues_query_origin_type: Optional[Any] = None,
        issues_query_origins: Annotated[Optional[List[IssueOriginParams]], Field(description="Filter issues that their origin is in the given list")] = None,
        issues_query_policy_name: Optional[StrictStr] = None,
        issues_query_action_id: Annotated[Optional[StrictStr], Field(description="Filter issues that are part of the action with the given id")] = None,
        issues_query_tag: Optional[StrictStr] = None,
        issues_query_source_name: Optional[StrictStr] = None,
        issues_query_integration_id: Annotated[Optional[StrictStr], Field(description="Filter issues that were detected by the given integration")] = None,
        issues_query_source_scanner_ids: Annotated[Optional[List[ControlClassification]], Field(description="Filter issues that their SourceScannerId is in the given list")] = None,
        issues_query_ai_validation_result: Optional[Any] = None,
        issues_query_validity_status: Optional[Any] = None,
        issues_query_validity_check_from_date: Annotated[Optional[datetime], Field(description="Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_validity_check_to_date: Annotated[Optional[datetime], Field(description="Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_file_path: Annotated[Optional[StrictStr], Field(description="Filter issues that their fila-path contains the given string")] = None,
        sort_column: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        token: Annotated[Optional[StrictStr], Field(description="Token from previous request (leave empty for first request)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of items to return (1-100)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> CustomerFacingIssuesPageDto:
        """Get issue ids

        Get ids of the issues matching the query params filters. To get more data on specific issues use the \"Get issue by id\" API with the issue id

        :param issues_query_title:
        :type issues_query_title: str
        :param issues_query_title_search: Filter issues that their title contains the given string
        :type issues_query_title_search: str
        :param issues_query_issue_types: Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone
        :type issues_query_issue_types: List[IssueType]
        :param issues_query_severities: Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone
        :type issues_query_severities: List[Severity]
        :param issues_query_policy_severity:
        :type issues_query_policy_severity: Severity
        :param issues_query_statuses: Filter issues that their status is in the given list. To filter for a specific status provide it here alone
        :type issues_query_statuses: List[IssueStatus]
        :param issues_query_detected_from_date: Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_detected_from_date: datetime
        :param issues_query_detected_to_date: Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_detected_to_date: datetime
        :param issues_query_opening_reason:
        :type issues_query_opening_reason: IssueOpeningReasonDto
        :param issues_query_last_action_time_from_date: Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_last_action_time_from_date: datetime
        :param issues_query_last_action_time_to_date: Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_last_action_time_to_date: datetime
        :param issues_query_closing_reason:
        :type issues_query_closing_reason: ClosingReason
        :param issues_query_closing_location:
        :type issues_query_closing_location: IssueClosingLocationDto
        :param issues_query_workspace_ids: Filter issues that their WorkspaceId is in the given list
        :type issues_query_workspace_ids: List[str]
        :param issues_query_vulnerable_file: Filter issues that originated from the given file
        :type issues_query_vulnerable_file: str
        :param issues_query_cve_id:
        :type issues_query_cve_id: str
        :param issues_query_min_score:
        :type issues_query_min_score: float
        :param issues_query_min_epss_score:
        :type issues_query_min_epss_score: float
        :param issues_query_dependency_fix_types:
        :type issues_query_dependency_fix_types: List[DependencyFixType]
        :param issues_query_product_ids:
        :type issues_query_product_ids: List[str]
        :param issues_query_has_ticket:
        :type issues_query_has_ticket: bool
        :param issues_query_is_assigned: Filter issues that have a user assigned to them in the legit platform
        :type issues_query_is_assigned: bool
        :param issues_query_is_assigned_to_me:
        :type issues_query_is_assigned_to_me: bool
        :param issues_query_is_triaged: Filter issues that have either a user or a ticket assigned to them in the legit platform
        :type issues_query_is_triaged: bool
        :param issues_query_assigned_user_id:
        :type issues_query_assigned_user_id: str
        :param issues_query_origin_id:
        :type issues_query_origin_id: str
        :param issues_query_origin_origin_type:
        :type issues_query_origin_origin_type: OriginType
        :param issues_query_origin_type:
        :type issues_query_origin_type: OriginType
        :param issues_query_origins: Filter issues that their origin is in the given list
        :type issues_query_origins: List[IssueOriginParams]
        :param issues_query_policy_name:
        :type issues_query_policy_name: str
        :param issues_query_action_id: Filter issues that are part of the action with the given id
        :type issues_query_action_id: str
        :param issues_query_tag:
        :type issues_query_tag: str
        :param issues_query_source_name:
        :type issues_query_source_name: str
        :param issues_query_integration_id: Filter issues that were detected by the given integration
        :type issues_query_integration_id: str
        :param issues_query_source_scanner_ids: Filter issues that their SourceScannerId is in the given list
        :type issues_query_source_scanner_ids: List[ControlClassification]
        :param issues_query_ai_validation_result:
        :type issues_query_ai_validation_result: AiValidationResult
        :param issues_query_validity_status:
        :type issues_query_validity_status: SecretIssueValidityStatus
        :param issues_query_validity_check_from_date: Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_validity_check_from_date: datetime
        :param issues_query_validity_check_to_date: Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_validity_check_to_date: datetime
        :param issues_query_file_path: Filter issues that their fila-path contains the given string
        :type issues_query_file_path: str
        :param sort_column:
        :type sort_column: IssueSortingColumn
        :param sort_direction:
        :type sort_direction: ListSortDirection
        :param token: Token from previous request (leave empty for first request)
        :type token: str
        :param limit: Number of items to return (1-100)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issues_v2_serialize(
            issues_query_title=issues_query_title,
            issues_query_title_search=issues_query_title_search,
            issues_query_issue_types=issues_query_issue_types,
            issues_query_severities=issues_query_severities,
            issues_query_policy_severity=issues_query_policy_severity,
            issues_query_statuses=issues_query_statuses,
            issues_query_detected_from_date=issues_query_detected_from_date,
            issues_query_detected_to_date=issues_query_detected_to_date,
            issues_query_opening_reason=issues_query_opening_reason,
            issues_query_last_action_time_from_date=issues_query_last_action_time_from_date,
            issues_query_last_action_time_to_date=issues_query_last_action_time_to_date,
            issues_query_closing_reason=issues_query_closing_reason,
            issues_query_closing_location=issues_query_closing_location,
            issues_query_workspace_ids=issues_query_workspace_ids,
            issues_query_vulnerable_file=issues_query_vulnerable_file,
            issues_query_cve_id=issues_query_cve_id,
            issues_query_min_score=issues_query_min_score,
            issues_query_min_epss_score=issues_query_min_epss_score,
            issues_query_dependency_fix_types=issues_query_dependency_fix_types,
            issues_query_product_ids=issues_query_product_ids,
            issues_query_has_ticket=issues_query_has_ticket,
            issues_query_is_assigned=issues_query_is_assigned,
            issues_query_is_assigned_to_me=issues_query_is_assigned_to_me,
            issues_query_is_triaged=issues_query_is_triaged,
            issues_query_assigned_user_id=issues_query_assigned_user_id,
            issues_query_origin_id=issues_query_origin_id,
            issues_query_origin_origin_type=issues_query_origin_origin_type,
            issues_query_origin_type=issues_query_origin_type,
            issues_query_origins=issues_query_origins,
            issues_query_policy_name=issues_query_policy_name,
            issues_query_action_id=issues_query_action_id,
            issues_query_tag=issues_query_tag,
            issues_query_source_name=issues_query_source_name,
            issues_query_integration_id=issues_query_integration_id,
            issues_query_source_scanner_ids=issues_query_source_scanner_ids,
            issues_query_ai_validation_result=issues_query_ai_validation_result,
            issues_query_validity_status=issues_query_validity_status,
            issues_query_validity_check_from_date=issues_query_validity_check_from_date,
            issues_query_validity_check_to_date=issues_query_validity_check_to_date,
            issues_query_file_path=issues_query_file_path,
            sort_column=sort_column,
            sort_direction=sort_direction,
            token=token,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerFacingIssuesPageDto",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        ).data


    @validate_call
    def get_issues_v2_with_http_info(
        self,
        issues_query_title: Optional[StrictStr] = None,
        issues_query_title_search: Annotated[Optional[StrictStr], Field(description="Filter issues that their title contains the given string")] = None,
        issues_query_issue_types: Annotated[Optional[List[IssueType]], Field(description="Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone")] = None,
        issues_query_severities: Annotated[Optional[List[Severity]], Field(description="Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone")] = None,
        issues_query_policy_severity: Optional[Any] = None,
        issues_query_statuses: Annotated[Optional[List[IssueStatus]], Field(description="Filter issues that their status is in the given list. To filter for a specific status provide it here alone")] = None,
        issues_query_detected_from_date: Annotated[Optional[datetime], Field(description="Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_detected_to_date: Annotated[Optional[datetime], Field(description="Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_opening_reason: Optional[Any] = None,
        issues_query_last_action_time_from_date: Annotated[Optional[datetime], Field(description="Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_last_action_time_to_date: Annotated[Optional[datetime], Field(description="Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_closing_reason: Optional[Any] = None,
        issues_query_closing_location: Optional[Any] = None,
        issues_query_workspace_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter issues that their WorkspaceId is in the given list")] = None,
        issues_query_vulnerable_file: Annotated[Optional[StrictStr], Field(description="Filter issues that originated from the given file")] = None,
        issues_query_cve_id: Optional[StrictStr] = None,
        issues_query_min_score: Optional[Union[StrictFloat, StrictInt]] = None,
        issues_query_min_epss_score: Optional[Union[StrictFloat, StrictInt]] = None,
        issues_query_dependency_fix_types: Optional[List[DependencyFixType]] = None,
        issues_query_product_ids: Optional[List[StrictStr]] = None,
        issues_query_has_ticket: Optional[StrictBool] = None,
        issues_query_is_assigned: Annotated[Optional[StrictBool], Field(description="Filter issues that have a user assigned to them in the legit platform")] = None,
        issues_query_is_assigned_to_me: Optional[StrictBool] = None,
        issues_query_is_triaged: Annotated[Optional[StrictBool], Field(description="Filter issues that have either a user or a ticket assigned to them in the legit platform")] = None,
        issues_query_assigned_user_id: Optional[StrictStr] = None,
        issues_query_origin_id: Optional[StrictStr] = None,
        issues_query_origin_origin_type: Optional[Any] = None,
        issues_query_origin_type: Optional[Any] = None,
        issues_query_origins: Annotated[Optional[List[IssueOriginParams]], Field(description="Filter issues that their origin is in the given list")] = None,
        issues_query_policy_name: Optional[StrictStr] = None,
        issues_query_action_id: Annotated[Optional[StrictStr], Field(description="Filter issues that are part of the action with the given id")] = None,
        issues_query_tag: Optional[StrictStr] = None,
        issues_query_source_name: Optional[StrictStr] = None,
        issues_query_integration_id: Annotated[Optional[StrictStr], Field(description="Filter issues that were detected by the given integration")] = None,
        issues_query_source_scanner_ids: Annotated[Optional[List[ControlClassification]], Field(description="Filter issues that their SourceScannerId is in the given list")] = None,
        issues_query_ai_validation_result: Optional[Any] = None,
        issues_query_validity_status: Optional[Any] = None,
        issues_query_validity_check_from_date: Annotated[Optional[datetime], Field(description="Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_validity_check_to_date: Annotated[Optional[datetime], Field(description="Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_file_path: Annotated[Optional[StrictStr], Field(description="Filter issues that their fila-path contains the given string")] = None,
        sort_column: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        token: Annotated[Optional[StrictStr], Field(description="Token from previous request (leave empty for first request)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of items to return (1-100)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> ApiResponse[CustomerFacingIssuesPageDto]:
        """Get issue ids

        Get ids of the issues matching the query params filters. To get more data on specific issues use the \"Get issue by id\" API with the issue id

        :param issues_query_title:
        :type issues_query_title: str
        :param issues_query_title_search: Filter issues that their title contains the given string
        :type issues_query_title_search: str
        :param issues_query_issue_types: Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone
        :type issues_query_issue_types: List[IssueType]
        :param issues_query_severities: Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone
        :type issues_query_severities: List[Severity]
        :param issues_query_policy_severity:
        :type issues_query_policy_severity: Severity
        :param issues_query_statuses: Filter issues that their status is in the given list. To filter for a specific status provide it here alone
        :type issues_query_statuses: List[IssueStatus]
        :param issues_query_detected_from_date: Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_detected_from_date: datetime
        :param issues_query_detected_to_date: Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_detected_to_date: datetime
        :param issues_query_opening_reason:
        :type issues_query_opening_reason: IssueOpeningReasonDto
        :param issues_query_last_action_time_from_date: Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_last_action_time_from_date: datetime
        :param issues_query_last_action_time_to_date: Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_last_action_time_to_date: datetime
        :param issues_query_closing_reason:
        :type issues_query_closing_reason: ClosingReason
        :param issues_query_closing_location:
        :type issues_query_closing_location: IssueClosingLocationDto
        :param issues_query_workspace_ids: Filter issues that their WorkspaceId is in the given list
        :type issues_query_workspace_ids: List[str]
        :param issues_query_vulnerable_file: Filter issues that originated from the given file
        :type issues_query_vulnerable_file: str
        :param issues_query_cve_id:
        :type issues_query_cve_id: str
        :param issues_query_min_score:
        :type issues_query_min_score: float
        :param issues_query_min_epss_score:
        :type issues_query_min_epss_score: float
        :param issues_query_dependency_fix_types:
        :type issues_query_dependency_fix_types: List[DependencyFixType]
        :param issues_query_product_ids:
        :type issues_query_product_ids: List[str]
        :param issues_query_has_ticket:
        :type issues_query_has_ticket: bool
        :param issues_query_is_assigned: Filter issues that have a user assigned to them in the legit platform
        :type issues_query_is_assigned: bool
        :param issues_query_is_assigned_to_me:
        :type issues_query_is_assigned_to_me: bool
        :param issues_query_is_triaged: Filter issues that have either a user or a ticket assigned to them in the legit platform
        :type issues_query_is_triaged: bool
        :param issues_query_assigned_user_id:
        :type issues_query_assigned_user_id: str
        :param issues_query_origin_id:
        :type issues_query_origin_id: str
        :param issues_query_origin_origin_type:
        :type issues_query_origin_origin_type: OriginType
        :param issues_query_origin_type:
        :type issues_query_origin_type: OriginType
        :param issues_query_origins: Filter issues that their origin is in the given list
        :type issues_query_origins: List[IssueOriginParams]
        :param issues_query_policy_name:
        :type issues_query_policy_name: str
        :param issues_query_action_id: Filter issues that are part of the action with the given id
        :type issues_query_action_id: str
        :param issues_query_tag:
        :type issues_query_tag: str
        :param issues_query_source_name:
        :type issues_query_source_name: str
        :param issues_query_integration_id: Filter issues that were detected by the given integration
        :type issues_query_integration_id: str
        :param issues_query_source_scanner_ids: Filter issues that their SourceScannerId is in the given list
        :type issues_query_source_scanner_ids: List[ControlClassification]
        :param issues_query_ai_validation_result:
        :type issues_query_ai_validation_result: AiValidationResult
        :param issues_query_validity_status:
        :type issues_query_validity_status: SecretIssueValidityStatus
        :param issues_query_validity_check_from_date: Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_validity_check_from_date: datetime
        :param issues_query_validity_check_to_date: Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_validity_check_to_date: datetime
        :param issues_query_file_path: Filter issues that their fila-path contains the given string
        :type issues_query_file_path: str
        :param sort_column:
        :type sort_column: IssueSortingColumn
        :param sort_direction:
        :type sort_direction: ListSortDirection
        :param token: Token from previous request (leave empty for first request)
        :type token: str
        :param limit: Number of items to return (1-100)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issues_v2_serialize(
            issues_query_title=issues_query_title,
            issues_query_title_search=issues_query_title_search,
            issues_query_issue_types=issues_query_issue_types,
            issues_query_severities=issues_query_severities,
            issues_query_policy_severity=issues_query_policy_severity,
            issues_query_statuses=issues_query_statuses,
            issues_query_detected_from_date=issues_query_detected_from_date,
            issues_query_detected_to_date=issues_query_detected_to_date,
            issues_query_opening_reason=issues_query_opening_reason,
            issues_query_last_action_time_from_date=issues_query_last_action_time_from_date,
            issues_query_last_action_time_to_date=issues_query_last_action_time_to_date,
            issues_query_closing_reason=issues_query_closing_reason,
            issues_query_closing_location=issues_query_closing_location,
            issues_query_workspace_ids=issues_query_workspace_ids,
            issues_query_vulnerable_file=issues_query_vulnerable_file,
            issues_query_cve_id=issues_query_cve_id,
            issues_query_min_score=issues_query_min_score,
            issues_query_min_epss_score=issues_query_min_epss_score,
            issues_query_dependency_fix_types=issues_query_dependency_fix_types,
            issues_query_product_ids=issues_query_product_ids,
            issues_query_has_ticket=issues_query_has_ticket,
            issues_query_is_assigned=issues_query_is_assigned,
            issues_query_is_assigned_to_me=issues_query_is_assigned_to_me,
            issues_query_is_triaged=issues_query_is_triaged,
            issues_query_assigned_user_id=issues_query_assigned_user_id,
            issues_query_origin_id=issues_query_origin_id,
            issues_query_origin_origin_type=issues_query_origin_origin_type,
            issues_query_origin_type=issues_query_origin_type,
            issues_query_origins=issues_query_origins,
            issues_query_policy_name=issues_query_policy_name,
            issues_query_action_id=issues_query_action_id,
            issues_query_tag=issues_query_tag,
            issues_query_source_name=issues_query_source_name,
            issues_query_integration_id=issues_query_integration_id,
            issues_query_source_scanner_ids=issues_query_source_scanner_ids,
            issues_query_ai_validation_result=issues_query_ai_validation_result,
            issues_query_validity_status=issues_query_validity_status,
            issues_query_validity_check_from_date=issues_query_validity_check_from_date,
            issues_query_validity_check_to_date=issues_query_validity_check_to_date,
            issues_query_file_path=issues_query_file_path,
            sort_column=sort_column,
            sort_direction=sort_direction,
            token=token,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerFacingIssuesPageDto",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        response_data.read()
        return self.api_client.response_deserialize(
            response_data=response_data,
            response_types_map=_response_types_map,
        )


    @validate_call
    def get_issues_v2_without_preload_content(
        self,
        issues_query_title: Optional[StrictStr] = None,
        issues_query_title_search: Annotated[Optional[StrictStr], Field(description="Filter issues that their title contains the given string")] = None,
        issues_query_issue_types: Annotated[Optional[List[IssueType]], Field(description="Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone")] = None,
        issues_query_severities: Annotated[Optional[List[Severity]], Field(description="Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone")] = None,
        issues_query_policy_severity: Optional[Any] = None,
        issues_query_statuses: Annotated[Optional[List[IssueStatus]], Field(description="Filter issues that their status is in the given list. To filter for a specific status provide it here alone")] = None,
        issues_query_detected_from_date: Annotated[Optional[datetime], Field(description="Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_detected_to_date: Annotated[Optional[datetime], Field(description="Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_opening_reason: Optional[Any] = None,
        issues_query_last_action_time_from_date: Annotated[Optional[datetime], Field(description="Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_last_action_time_to_date: Annotated[Optional[datetime], Field(description="Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_closing_reason: Optional[Any] = None,
        issues_query_closing_location: Optional[Any] = None,
        issues_query_workspace_ids: Annotated[Optional[List[StrictStr]], Field(description="Filter issues that their WorkspaceId is in the given list")] = None,
        issues_query_vulnerable_file: Annotated[Optional[StrictStr], Field(description="Filter issues that originated from the given file")] = None,
        issues_query_cve_id: Optional[StrictStr] = None,
        issues_query_min_score: Optional[Union[StrictFloat, StrictInt]] = None,
        issues_query_min_epss_score: Optional[Union[StrictFloat, StrictInt]] = None,
        issues_query_dependency_fix_types: Optional[List[DependencyFixType]] = None,
        issues_query_product_ids: Optional[List[StrictStr]] = None,
        issues_query_has_ticket: Optional[StrictBool] = None,
        issues_query_is_assigned: Annotated[Optional[StrictBool], Field(description="Filter issues that have a user assigned to them in the legit platform")] = None,
        issues_query_is_assigned_to_me: Optional[StrictBool] = None,
        issues_query_is_triaged: Annotated[Optional[StrictBool], Field(description="Filter issues that have either a user or a ticket assigned to them in the legit platform")] = None,
        issues_query_assigned_user_id: Optional[StrictStr] = None,
        issues_query_origin_id: Optional[StrictStr] = None,
        issues_query_origin_origin_type: Optional[Any] = None,
        issues_query_origin_type: Optional[Any] = None,
        issues_query_origins: Annotated[Optional[List[IssueOriginParams]], Field(description="Filter issues that their origin is in the given list")] = None,
        issues_query_policy_name: Optional[StrictStr] = None,
        issues_query_action_id: Annotated[Optional[StrictStr], Field(description="Filter issues that are part of the action with the given id")] = None,
        issues_query_tag: Optional[StrictStr] = None,
        issues_query_source_name: Optional[StrictStr] = None,
        issues_query_integration_id: Annotated[Optional[StrictStr], Field(description="Filter issues that were detected by the given integration")] = None,
        issues_query_source_scanner_ids: Annotated[Optional[List[ControlClassification]], Field(description="Filter issues that their SourceScannerId is in the given list")] = None,
        issues_query_ai_validation_result: Optional[Any] = None,
        issues_query_validity_status: Optional[Any] = None,
        issues_query_validity_check_from_date: Annotated[Optional[datetime], Field(description="Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_validity_check_to_date: Annotated[Optional[datetime], Field(description="Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)")] = None,
        issues_query_file_path: Annotated[Optional[StrictStr], Field(description="Filter issues that their fila-path contains the given string")] = None,
        sort_column: Optional[Any] = None,
        sort_direction: Optional[Any] = None,
        token: Annotated[Optional[StrictStr], Field(description="Token from previous request (leave empty for first request)")] = None,
        limit: Annotated[Optional[Annotated[int, Field(le=100, strict=True, ge=1)]], Field(description="Number of items to return (1-100)")] = None,
        _request_timeout: Union[
            None,
            Annotated[StrictFloat, Field(gt=0)],
            Tuple[
                Annotated[StrictFloat, Field(gt=0)],
                Annotated[StrictFloat, Field(gt=0)]
            ]
        ] = None,
        _request_auth: Optional[Dict[StrictStr, Any]] = None,
        _content_type: Optional[StrictStr] = None,
        _headers: Optional[Dict[StrictStr, Any]] = None,
        _host_index: Annotated[StrictInt, Field(ge=0, le=0)] = 0,
    ) -> RESTResponseType:
        """Get issue ids

        Get ids of the issues matching the query params filters. To get more data on specific issues use the \"Get issue by id\" API with the issue id

        :param issues_query_title:
        :type issues_query_title: str
        :param issues_query_title_search: Filter issues that their title contains the given string
        :type issues_query_title_search: str
        :param issues_query_issue_types: Filter issues that their type is in the given list. To filter for a specific issue type provide it here alone
        :type issues_query_issue_types: List[IssueType]
        :param issues_query_severities: Filter issues that their severity is in the given list. To filter for a specific severity provide it here alone
        :type issues_query_severities: List[Severity]
        :param issues_query_policy_severity:
        :type issues_query_policy_severity: Severity
        :param issues_query_statuses: Filter issues that their status is in the given list. To filter for a specific status provide it here alone
        :type issues_query_statuses: List[IssueStatus]
        :param issues_query_detected_from_date: Filter issues detected after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_detected_from_date: datetime
        :param issues_query_detected_to_date: Filter issues detected up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_detected_to_date: datetime
        :param issues_query_opening_reason:
        :type issues_query_opening_reason: IssueOpeningReasonDto
        :param issues_query_last_action_time_from_date: Filter issues the last time an action was performed on them is after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_last_action_time_from_date: datetime
        :param issues_query_last_action_time_to_date: Filter issues that the last time an action was performed on them is before the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_last_action_time_to_date: datetime
        :param issues_query_closing_reason:
        :type issues_query_closing_reason: ClosingReason
        :param issues_query_closing_location:
        :type issues_query_closing_location: IssueClosingLocationDto
        :param issues_query_workspace_ids: Filter issues that their WorkspaceId is in the given list
        :type issues_query_workspace_ids: List[str]
        :param issues_query_vulnerable_file: Filter issues that originated from the given file
        :type issues_query_vulnerable_file: str
        :param issues_query_cve_id:
        :type issues_query_cve_id: str
        :param issues_query_min_score:
        :type issues_query_min_score: float
        :param issues_query_min_epss_score:
        :type issues_query_min_epss_score: float
        :param issues_query_dependency_fix_types:
        :type issues_query_dependency_fix_types: List[DependencyFixType]
        :param issues_query_product_ids:
        :type issues_query_product_ids: List[str]
        :param issues_query_has_ticket:
        :type issues_query_has_ticket: bool
        :param issues_query_is_assigned: Filter issues that have a user assigned to them in the legit platform
        :type issues_query_is_assigned: bool
        :param issues_query_is_assigned_to_me:
        :type issues_query_is_assigned_to_me: bool
        :param issues_query_is_triaged: Filter issues that have either a user or a ticket assigned to them in the legit platform
        :type issues_query_is_triaged: bool
        :param issues_query_assigned_user_id:
        :type issues_query_assigned_user_id: str
        :param issues_query_origin_id:
        :type issues_query_origin_id: str
        :param issues_query_origin_origin_type:
        :type issues_query_origin_origin_type: OriginType
        :param issues_query_origin_type:
        :type issues_query_origin_type: OriginType
        :param issues_query_origins: Filter issues that their origin is in the given list
        :type issues_query_origins: List[IssueOriginParams]
        :param issues_query_policy_name:
        :type issues_query_policy_name: str
        :param issues_query_action_id: Filter issues that are part of the action with the given id
        :type issues_query_action_id: str
        :param issues_query_tag:
        :type issues_query_tag: str
        :param issues_query_source_name:
        :type issues_query_source_name: str
        :param issues_query_integration_id: Filter issues that were detected by the given integration
        :type issues_query_integration_id: str
        :param issues_query_source_scanner_ids: Filter issues that their SourceScannerId is in the given list
        :type issues_query_source_scanner_ids: List[ControlClassification]
        :param issues_query_ai_validation_result:
        :type issues_query_ai_validation_result: AiValidationResult
        :param issues_query_validity_status:
        :type issues_query_validity_status: SecretIssueValidityStatus
        :param issues_query_validity_check_from_date: Filter issues validated after the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_validity_check_from_date: datetime
        :param issues_query_validity_check_to_date: Filter issues validated up to the given date. Time should be in ISO 8601 format (e.g. 2024-05-01T15:00:00Z)
        :type issues_query_validity_check_to_date: datetime
        :param issues_query_file_path: Filter issues that their fila-path contains the given string
        :type issues_query_file_path: str
        :param sort_column:
        :type sort_column: IssueSortingColumn
        :param sort_direction:
        :type sort_direction: ListSortDirection
        :param token: Token from previous request (leave empty for first request)
        :type token: str
        :param limit: Number of items to return (1-100)
        :type limit: int
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :type _request_timeout: int, tuple(int, int), optional
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the
                              authentication in the spec for a single request.
        :type _request_auth: dict, optional
        :param _content_type: force content-type for the request.
        :type _content_type: str, Optional
        :param _headers: set to override the headers for a single
                         request; this effectively ignores the headers
                         in the spec for a single request.
        :type _headers: dict, optional
        :param _host_index: set to override the host_index for a single
                            request; this effectively ignores the host_index
                            in the spec for a single request.
        :type _host_index: int, optional
        :return: Returns the result object.
        """ # noqa: E501

        _param = self._get_issues_v2_serialize(
            issues_query_title=issues_query_title,
            issues_query_title_search=issues_query_title_search,
            issues_query_issue_types=issues_query_issue_types,
            issues_query_severities=issues_query_severities,
            issues_query_policy_severity=issues_query_policy_severity,
            issues_query_statuses=issues_query_statuses,
            issues_query_detected_from_date=issues_query_detected_from_date,
            issues_query_detected_to_date=issues_query_detected_to_date,
            issues_query_opening_reason=issues_query_opening_reason,
            issues_query_last_action_time_from_date=issues_query_last_action_time_from_date,
            issues_query_last_action_time_to_date=issues_query_last_action_time_to_date,
            issues_query_closing_reason=issues_query_closing_reason,
            issues_query_closing_location=issues_query_closing_location,
            issues_query_workspace_ids=issues_query_workspace_ids,
            issues_query_vulnerable_file=issues_query_vulnerable_file,
            issues_query_cve_id=issues_query_cve_id,
            issues_query_min_score=issues_query_min_score,
            issues_query_min_epss_score=issues_query_min_epss_score,
            issues_query_dependency_fix_types=issues_query_dependency_fix_types,
            issues_query_product_ids=issues_query_product_ids,
            issues_query_has_ticket=issues_query_has_ticket,
            issues_query_is_assigned=issues_query_is_assigned,
            issues_query_is_assigned_to_me=issues_query_is_assigned_to_me,
            issues_query_is_triaged=issues_query_is_triaged,
            issues_query_assigned_user_id=issues_query_assigned_user_id,
            issues_query_origin_id=issues_query_origin_id,
            issues_query_origin_origin_type=issues_query_origin_origin_type,
            issues_query_origin_type=issues_query_origin_type,
            issues_query_origins=issues_query_origins,
            issues_query_policy_name=issues_query_policy_name,
            issues_query_action_id=issues_query_action_id,
            issues_query_tag=issues_query_tag,
            issues_query_source_name=issues_query_source_name,
            issues_query_integration_id=issues_query_integration_id,
            issues_query_source_scanner_ids=issues_query_source_scanner_ids,
            issues_query_ai_validation_result=issues_query_ai_validation_result,
            issues_query_validity_status=issues_query_validity_status,
            issues_query_validity_check_from_date=issues_query_validity_check_from_date,
            issues_query_validity_check_to_date=issues_query_validity_check_to_date,
            issues_query_file_path=issues_query_file_path,
            sort_column=sort_column,
            sort_direction=sort_direction,
            token=token,
            limit=limit,
            _request_auth=_request_auth,
            _content_type=_content_type,
            _headers=_headers,
            _host_index=_host_index
        )

        _response_types_map: Dict[str, Optional[str]] = {
            '200': "CustomerFacingIssuesPageDto",
        }
        response_data = self.api_client.call_api(
            *_param,
            _request_timeout=_request_timeout
        )
        return response_data.response


    def _get_issues_v2_serialize(
        self,
        issues_query_title,
        issues_query_title_search,
        issues_query_issue_types,
        issues_query_severities,
        issues_query_policy_severity,
        issues_query_statuses,
        issues_query_detected_from_date,
        issues_query_detected_to_date,
        issues_query_opening_reason,
        issues_query_last_action_time_from_date,
        issues_query_last_action_time_to_date,
        issues_query_closing_reason,
        issues_query_closing_location,
        issues_query_workspace_ids,
        issues_query_vulnerable_file,
        issues_query_cve_id,
        issues_query_min_score,
        issues_query_min_epss_score,
        issues_query_dependency_fix_types,
        issues_query_product_ids,
        issues_query_has_ticket,
        issues_query_is_assigned,
        issues_query_is_assigned_to_me,
        issues_query_is_triaged,
        issues_query_assigned_user_id,
        issues_query_origin_id,
        issues_query_origin_origin_type,
        issues_query_origin_type,
        issues_query_origins,
        issues_query_policy_name,
        issues_query_action_id,
        issues_query_tag,
        issues_query_source_name,
        issues_query_integration_id,
        issues_query_source_scanner_ids,
        issues_query_ai_validation_result,
        issues_query_validity_status,
        issues_query_validity_check_from_date,
        issues_query_validity_check_to_date,
        issues_query_file_path,
        sort_column,
        sort_direction,
        token,
        limit,
        _request_auth,
        _content_type,
        _headers,
        _host_index,
    ) -> RequestSerialized:

        _host = None

        _collection_formats: Dict[str, str] = {
            'issuesQuery.issueTypes': 'multi',
            'issuesQuery.severities': 'multi',
            'issuesQuery.statuses': 'multi',
            'issuesQuery.workspaceIds': 'multi',
            'issuesQuery.dependencyFixTypes': 'multi',
            'issuesQuery.productIds': 'multi',
            'issuesQuery.origins': 'multi',
            'issuesQuery.sourceScannerIds': 'multi',
        }

        _path_params: Dict[str, str] = {}
        _query_params: List[Tuple[str, str]] = []
        _header_params: Dict[str, Optional[str]] = _headers or {}
        _form_params: List[Tuple[str, str]] = []
        _files: Dict[
            str, Union[str, bytes, List[str], List[bytes], List[Tuple[str, bytes]]]
        ] = {}
        _body_params: Optional[bytes] = None

        # process the path parameters
        # process the query parameters
        if issues_query_title is not None:
            
            _query_params.append(('issuesQuery.title', issues_query_title))
            
        if issues_query_title_search is not None:
            
            _query_params.append(('issuesQuery.titleSearch', issues_query_title_search))
            
        if issues_query_issue_types is not None:
            
            _query_params.append(('issuesQuery.issueTypes', issues_query_issue_types))
            
        if issues_query_severities is not None:
            
            _query_params.append(('issuesQuery.severities', issues_query_severities))
            
        if issues_query_policy_severity is not None:
            
            _query_params.append(('issuesQuery.policySeverity', issues_query_policy_severity.value))
            
        if issues_query_statuses is not None:
            
            _query_params.append(('issuesQuery.statuses', issues_query_statuses))
            
        if issues_query_detected_from_date is not None:
            if isinstance(issues_query_detected_from_date, datetime):
                _query_params.append(
                    (
                        'issuesQuery.detectedFromDate',
                        issues_query_detected_from_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('issuesQuery.detectedFromDate', issues_query_detected_from_date))
            
        if issues_query_detected_to_date is not None:
            if isinstance(issues_query_detected_to_date, datetime):
                _query_params.append(
                    (
                        'issuesQuery.detectedToDate',
                        issues_query_detected_to_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('issuesQuery.detectedToDate', issues_query_detected_to_date))
            
        if issues_query_opening_reason is not None:
            
            _query_params.append(('issuesQuery.openingReason', issues_query_opening_reason.value))
            
        if issues_query_last_action_time_from_date is not None:
            if isinstance(issues_query_last_action_time_from_date, datetime):
                _query_params.append(
                    (
                        'issuesQuery.lastActionTimeFromDate',
                        issues_query_last_action_time_from_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('issuesQuery.lastActionTimeFromDate', issues_query_last_action_time_from_date))
            
        if issues_query_last_action_time_to_date is not None:
            if isinstance(issues_query_last_action_time_to_date, datetime):
                _query_params.append(
                    (
                        'issuesQuery.lastActionTimeToDate',
                        issues_query_last_action_time_to_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('issuesQuery.lastActionTimeToDate', issues_query_last_action_time_to_date))
            
        if issues_query_closing_reason is not None:
            
            _query_params.append(('issuesQuery.closingReason', issues_query_closing_reason.value))
            
        if issues_query_closing_location is not None:
            
            _query_params.append(('issuesQuery.closingLocation', issues_query_closing_location.value))
            
        if issues_query_workspace_ids is not None:
            
            _query_params.append(('issuesQuery.workspaceIds', issues_query_workspace_ids))
            
        if issues_query_vulnerable_file is not None:
            
            _query_params.append(('issuesQuery.vulnerableFile', issues_query_vulnerable_file))
            
        if issues_query_cve_id is not None:
            
            _query_params.append(('issuesQuery.cveId', issues_query_cve_id))
            
        if issues_query_min_score is not None:
            
            _query_params.append(('issuesQuery.minScore', issues_query_min_score))
            
        if issues_query_min_epss_score is not None:
            
            _query_params.append(('issuesQuery.minEpssScore', issues_query_min_epss_score))
            
        if issues_query_dependency_fix_types is not None:
            
            _query_params.append(('issuesQuery.dependencyFixTypes', issues_query_dependency_fix_types))
            
        if issues_query_product_ids is not None:
            
            _query_params.append(('issuesQuery.productIds', issues_query_product_ids))
            
        if issues_query_has_ticket is not None:
            
            _query_params.append(('issuesQuery.hasTicket', issues_query_has_ticket))
            
        if issues_query_is_assigned is not None:
            
            _query_params.append(('issuesQuery.isAssigned', issues_query_is_assigned))
            
        if issues_query_is_assigned_to_me is not None:
            
            _query_params.append(('issuesQuery.isAssignedToMe', issues_query_is_assigned_to_me))
            
        if issues_query_is_triaged is not None:
            
            _query_params.append(('issuesQuery.isTriaged', issues_query_is_triaged))
            
        if issues_query_assigned_user_id is not None:
            
            _query_params.append(('issuesQuery.assignedUserId', issues_query_assigned_user_id))
            
        if issues_query_origin_id is not None:
            
            _query_params.append(('issuesQuery.origin.id', issues_query_origin_id))
            
        if issues_query_origin_origin_type is not None:
            
            _query_params.append(('issuesQuery.origin.originType', issues_query_origin_origin_type.value))
            
        if issues_query_origin_type is not None:
            
            _query_params.append(('issuesQuery.originType', issues_query_origin_type.value))
            
        if issues_query_origins is not None:
            
            _query_params.append(('issuesQuery.origins', issues_query_origins))
            
        if issues_query_policy_name is not None:
            
            _query_params.append(('issuesQuery.policyName', issues_query_policy_name))
            
        if issues_query_action_id is not None:
            
            _query_params.append(('issuesQuery.actionId', issues_query_action_id))
            
        if issues_query_tag is not None:
            
            _query_params.append(('issuesQuery.tag', issues_query_tag))
            
        if issues_query_source_name is not None:
            
            _query_params.append(('issuesQuery.sourceName', issues_query_source_name))
            
        if issues_query_integration_id is not None:
            
            _query_params.append(('issuesQuery.integrationId', issues_query_integration_id))
            
        if issues_query_source_scanner_ids is not None:
            
            _query_params.append(('issuesQuery.sourceScannerIds', issues_query_source_scanner_ids))
            
        if issues_query_ai_validation_result is not None:
            
            _query_params.append(('issuesQuery.aiValidationResult', issues_query_ai_validation_result.value))
            
        if issues_query_validity_status is not None:
            
            _query_params.append(('issuesQuery.validityStatus', issues_query_validity_status.value))
            
        if issues_query_validity_check_from_date is not None:
            if isinstance(issues_query_validity_check_from_date, datetime):
                _query_params.append(
                    (
                        'issuesQuery.validityCheckFromDate',
                        issues_query_validity_check_from_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('issuesQuery.validityCheckFromDate', issues_query_validity_check_from_date))
            
        if issues_query_validity_check_to_date is not None:
            if isinstance(issues_query_validity_check_to_date, datetime):
                _query_params.append(
                    (
                        'issuesQuery.validityCheckToDate',
                        issues_query_validity_check_to_date.strftime(
                            self.api_client.configuration.datetime_format
                        )
                    )
                )
            else:
                _query_params.append(('issuesQuery.validityCheckToDate', issues_query_validity_check_to_date))
            
        if issues_query_file_path is not None:
            
            _query_params.append(('issuesQuery.filePath', issues_query_file_path))
            
        if sort_column is not None:
            
            _query_params.append(('sortColumn', sort_column.value))
            
        if sort_direction is not None:
            
            _query_params.append(('sortDirection', sort_direction.value))
            
        if token is not None:
            
            _query_params.append(('token', token))
            
        if limit is not None:
            
            _query_params.append(('limit', limit))
            
        # process the header parameters
        # process the form parameters
        # process the body parameter


        # set the HTTP header `Accept`
        if 'Accept' not in _header_params:
            _header_params['Accept'] = self.api_client.select_header_accept(
                [
                    'text/plain', 
                    'application/json', 
                    'text/json'
                ]
            )


        # authentication setting
        _auth_settings: List[str] = [
            'BearerAuth'
        ]

        return self.api_client.param_serialize(
            method='GET',
            resource_path='/api/v2.0/issues',
            path_params=_path_params,
            query_params=_query_params,
            header_params=_header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            auth_settings=_auth_settings,
            collection_formats=_collection_formats,
            _host=_host,
            _request_auth=_request_auth
        )


