import os
from . import swagger
from .client import AsyncClient
from .device_flow import AsyncDeviceFlow, DeviceFlowMode
from .exec import AsyncExecResponse_ByCommand_ToSingle, AsyncExecResponse_ByDevice_ByCommand, AsyncExecResponse_ByDevice_ToSingle, AsyncSingleExecResponse
from .http import AsyncHttpApi
from .netconf import AsyncNetconfAPI, AsyncSingleDeviceNetconfAPI
from .port_forwarding import AsyncTCPPortForwarder
from .request import AsyncFillerRequest, AsyncSimpleRequest, AsyncTransformedFillerRequest
from .service import AsyncService
from .state import AsyncRequestsDict, AsyncServiceState, AsyncSessionLogsDict, AsyncSessionsDict, AsyncTCPPortForwardsDict
from .terminal import AsyncFileReadConnection, AsyncFileWriteConnection, AsyncInteractiveConnection
from _typeshed import Incomplete
from collections.abc import Callable, Iterable, Iterator, Mapping, MutableMapping, Sequence
from dataclasses import dataclass
from enum import Enum
from prompt_toolkit.formatted_text import AnyFormattedText, StyleAndTextTuples
from radkit_client.async_.snmp import AsyncSNMP_API, AsyncSingleDeviceSNMP_API
from radkit_common.identities import ClientID, ServiceID
from radkit_common.protocol.device_actions import DeviceAction, DeviceActionPartialResponse
from radkit_common.protocol.inventory import DetailedInventoryResponse, GetDetailedInventory
from radkit_common.protocol.netconf import GetNetconfCapabilities
from radkit_common.protocol.swagger import GetSwaggerPaths, SwaggerPaths
from radkit_common.protocol.terminal import ReadAndUploadFile
from radkit_common.protocol.upload_parameters import UploadParameters
from radkit_common.rpc.definition import NOTHING
from radkit_common.terminal_interaction.prompt_detection import PromptDetectionStrategy
from radkit_common.types import PortRanges
from re import Pattern
from typing import overload
from typing_extensions import Self
from uuid import UUID

__all__ = ['AsyncDeviceDict', 'AsyncDevice', 'AsyncDeviceAttributes', 'AsyncDeviceParameters', 'AsyncDeviceAttributesDict', 'AsyncEphemeralDeviceAttributesDict', 'AsyncDeviceDictCapabilitiesUpdate', 'AsyncDeviceCapabilitiesUpdate', 'DeviceCapabilitiesUpdateStatus', 'DeviceDictCapabilitiesUpdateStatus']

class DeviceDictStatus(Enum):
    LOADING = 'LOADING'
    LOADING_FAILED = 'LOADING_FAILED'
    READY = 'READY'

class AsyncDeviceDict(Mapping[str, 'AsyncDevice']):
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, uuids: Iterable[UUID] | None = None) -> None: ...
    def status(self) -> DeviceDictStatus: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getitem__(self, key: str) -> AsyncDevice: ...
    def __delitem__(self, key: str) -> None: ...
    def __setitem__(self, name: str, device: AsyncDevice) -> None: ...
    def service_name(self) -> str: ...
    def service_id(self) -> ServiceID | None: ...
    def touched(self) -> bool: ...
    def remove(self, obj: UUID | str | AsyncDevice | AsyncDeviceDict | Iterable[UUID | str | AsyncDevice]) -> None: ...
    def add(self, obj: UUID | str | AsyncDevice | AsyncDeviceDict | Iterable[UUID | str | AsyncDevice]) -> None: ...
    def copy(self) -> AsyncDeviceDict: ...
    def clone(self) -> AsyncDeviceDict: ...
    def __eq__(self, other: object) -> bool: ...
    def union(self, other: object) -> AsyncDeviceDict: ...
    def difference(self, other: object) -> AsyncDeviceDict: ...
    def intersection(self, other: object) -> AsyncDeviceDict: ...
    def symmetric_difference(self, other: object) -> AsyncDeviceDict: ...
    def issubset(self, other: AsyncDeviceDict) -> bool: ...
    def issuperset(self, other: AsyncDeviceDict) -> bool: ...
    __and__ = intersection
    __or__ = union
    __sub__ = difference
    __xor__ = symmetric_difference
    __le__ = issubset
    __ge__ = issuperset
    def __lt__(self, other: AsyncDeviceDict) -> bool: ...
    def __gt__(self, other: AsyncDeviceDict) -> bool: ...
    def filter(self, attr: str, pattern: str) -> AsyncDeviceDict: ...
    async def filter_by_async_func(self, func: Callable[[AsyncDevice], bool]) -> AsyncDeviceDict: ...
    def subset(self, devices: Iterable[str | UUID | AsyncDevice]) -> AsyncDeviceDict: ...
    def exclude_failed(self) -> AsyncDeviceDict: ...
    def service(self) -> AsyncService: ...
    def client(self) -> AsyncClient: ...
    def update_attributes(self) -> AsyncSimpleRequest[GetDetailedInventory, DetailedInventoryResponse, None]: ...
    @overload
    def exec(self, commands: str, *, timeout: int = ..., upload_to: UploadParameters | None = ..., reset_before: bool = ..., reset_after: bool = ..., sudo: bool = ..., prompt_detection_strategy: PromptDetectionStrategy | None = ...) -> AsyncExecResponse_ByDevice_ToSingle[str]: ...
    @overload
    def exec(self, commands: list[str], *, timeout: int = ..., upload_to: UploadParameters | None = ..., reset_before: bool = ..., reset_after: bool = ..., sudo: bool = ..., prompt_detection_strategy: PromptDetectionStrategy | None = ...) -> AsyncExecResponse_ByDevice_ByCommand[str]: ...
    def update_swagger(self, timeout: float | None = None) -> AsyncFillerRequest[DeviceAction[GetSwaggerPaths], DeviceActionPartialResponse[SwaggerPaths], AsyncDeviceDictCapabilitiesUpdate]: ...
    def update_netconf(self) -> AsyncFillerRequest[DeviceAction[GetNetconfCapabilities], DeviceActionPartialResponse[dict[str, str]], AsyncDeviceDictCapabilitiesUpdate]: ...
    def netconf(self) -> AsyncNetconfAPI: ...
    def snmp(self) -> AsyncSNMP_API: ...
    def sessions(self) -> AsyncSessionsDict: ...
    def session_logs(self) -> AsyncSessionLogsDict: ...
    def port_forwards(self) -> AsyncTCPPortForwardsDict: ...
    def requests(self) -> AsyncRequestsDict: ...
    def scp_to_destination(self, remote_path: str, upload_parameters: UploadParameters) -> AsyncFillerRequest[DeviceAction[ReadAndUploadFile], DeviceActionPartialResponse[NOTHING], None]: ...
    def sftp_to_destination(self, remote_path: str, upload_parameters: UploadParameters) -> AsyncFillerRequest[DeviceAction[ReadAndUploadFile], DeviceActionPartialResponse[NOTHING], None]: ...
    def create_device_flow(self, flow_mode: DeviceFlowMode | None = None, exec_error_patterns: Sequence[Pattern[str]] | None = None) -> AsyncDeviceFlow: ...

class AsyncDevice:
    __to_std_object__: Incomplete
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID) -> None: ...
    def service_name(self) -> str: ...
    def service_id(self) -> ServiceID | None: ...
    def service(self) -> AsyncService: ...
    def client(self) -> AsyncClient: ...
    def singleton(self) -> AsyncDeviceDict: ...
    def name(self) -> str: ...
    def service_display_name(self) -> str: ...
    def update_attributes(self) -> AsyncSimpleRequest[GetDetailedInventory, DetailedInventoryResponse, None]: ...
    def attributes(self) -> AsyncDeviceAttributes: ...
    def host(self) -> str: ...
    def description(self) -> str: ...
    def device_type(self) -> str: ...
    def forwarded_tcp_ports(self) -> PortRanges: ...
    def failed(self) -> bool: ...
    def set_failed(self, value: bool) -> None: ...
    def params(self) -> AsyncDeviceParameters: ...
    def sessions(self) -> AsyncSessionsDict: ...
    def session_logs(self) -> AsyncSessionLogsDict: ...
    def requests(self) -> AsyncRequestsDict: ...
    def port_forwards(self) -> AsyncTCPPortForwardsDict: ...
    @overload
    def exec(self, commands: str, *, timeout: int = ..., upload_to: UploadParameters | None = ..., reset_before: bool = ..., reset_after: bool = ..., sudo: bool = ..., prompt_detection_strategy: PromptDetectionStrategy | None = ...) -> AsyncSingleExecResponse[str]: ...
    @overload
    def exec(self, commands: list[str], *, timeout: int = ..., upload_to: UploadParameters | None = ..., reset_before: bool = ..., reset_after: bool = ..., sudo: bool = ..., prompt_detection_strategy: PromptDetectionStrategy | None = ...) -> AsyncExecResponse_ByCommand_ToSingle[str]: ...
    def update_swagger(self, timeout: float | None = None) -> AsyncTransformedFillerRequest[DeviceAction[GetSwaggerPaths], DeviceActionPartialResponse[SwaggerPaths], AsyncDeviceDictCapabilitiesUpdate, AsyncDeviceCapabilitiesUpdate]: ...
    def update_netconf(self) -> AsyncTransformedFillerRequest[DeviceAction[GetNetconfCapabilities], DeviceActionPartialResponse[dict[str, str]], AsyncDeviceDictCapabilitiesUpdate, AsyncDeviceCapabilitiesUpdate]: ...
    def swagger(self) -> swagger.AsyncSwaggerAPI: ...
    def netconf(self) -> AsyncSingleDeviceNetconfAPI: ...
    def snmp(self) -> AsyncSingleDeviceSNMP_API: ...
    def http(self) -> AsyncHttpApi: ...
    def terminal(self, command: str | None = None, term: str | None = None, initial_terminal_size: os.terminal_size | None = None, request_pty: bool = True, include_initialization: bool = False) -> AsyncInteractiveConnection: ...
    async def interactive(self, command: str | None = None, term: str | None = None, initial_terminal_size: os.terminal_size | None = None, request_pty: bool = True, include_initialization: bool = False) -> None: ...
    async def forward_tcp_port(self, local_port: int, destination_port: int, local_address: str = 'localhost', server_startup_timeout: float = 2.0) -> AsyncTCPPortForwarder: ...
    def scp_download_to_stream(self, remote_path: str) -> AsyncFileReadConnection: ...
    def sftp_download_to_stream(self, remote_path: str) -> AsyncFileReadConnection: ...
    def scp_download_to_file(self, remote_path: str, local_path: str | None = None) -> AsyncFileReadConnection: ...
    def sftp_download_to_file(self, remote_path: str, local_path: str | None = None) -> AsyncFileReadConnection: ...
    def scp_to_destination(self, remote_path: str, upload_parameters: UploadParameters) -> AsyncFillerRequest[DeviceAction[ReadAndUploadFile], DeviceActionPartialResponse[NOTHING], None]: ...
    def sftp_to_destination(self, remote_path: str, upload_parameters: UploadParameters) -> AsyncFillerRequest[DeviceAction[ReadAndUploadFile], DeviceActionPartialResponse[NOTHING], None]: ...
    def scp_upload_from_stream(self, remote_path: str, size: int, chmod: str = '644') -> AsyncFileWriteConnection: ...
    def sftp_upload_from_stream(self, remote_path: str, size: int, chmod: str = '644') -> AsyncFileWriteConnection: ...
    def scp_upload_from_file(self, local_path: str, remote_path: str) -> AsyncFileWriteConnection: ...
    def sftp_upload_from_file(self, local_path: str, remote_path: str) -> AsyncFileWriteConnection: ...
    def create_device_flow(self, flow_mode: DeviceFlowMode | None = None, exec_error_patterns: Sequence[Pattern[str]] | None = None) -> AsyncDeviceFlow: ...
    def __pt_repr__(self) -> AnyFormattedText: ...

@dataclass(repr=False)
class AsyncDeviceParameters:
    __pt_repr__ = ...
    def client_id(self) -> ClientID | None: ...
    def service_id(self) -> ServiceID | None: ...
    def service_name(self) -> str: ...
    def uuid(self) -> UUID: ...
    def name(self) -> str: ...
    def service_display_name(self) -> str: ...
    def dev_id(self) -> str: ...

class AsyncDeviceAttributesDict(Mapping[str, object]):
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID, metadata: bool) -> None: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getitem__(self, __key: str) -> object: ...
    def device_name(self) -> str: ...
    def device(self) -> AsyncDevice: ...

class AsyncEphemeralDeviceAttributesDict(MutableMapping[str, object]):
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID) -> None: ...
    def __getitem__(self, key: str) -> object: ...
    def __setitem__(self, key: str, value: object) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def device_name(self) -> str: ...
    def device(self) -> AsyncDevice: ...

@dataclass(repr=False)
class AsyncDeviceAttributes:
    def internal(self) -> AsyncDeviceAttributesDict: ...
    def metadata(self) -> AsyncDeviceAttributesDict: ...
    def ephemeral(self) -> AsyncEphemeralDeviceAttributesDict: ...
    def device_name(self) -> str: ...
    def device(self) -> AsyncDevice: ...
    def __pt_repr__(self) -> StyleAndTextTuples: ...

class AsyncDeviceDictCapabilitiesUpdate(Mapping[str, 'AsyncDeviceCapabilitiesUpdate']):
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, uuids: frozenset[UUID]) -> None: ...
    async def wait(self, timeout: float | None = None) -> Self: ...
    def service_name(self) -> str: ...
    def client_id(self) -> ClientID | None: ...
    def service_id(self) -> ServiceID | None: ...
    def devices(self) -> AsyncDeviceDict: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> Iterator[str]: ...
    def __getitem__(self, device_name: str) -> AsyncDeviceCapabilitiesUpdate: ...
    def status(self) -> DeviceDictCapabilitiesUpdateStatus: ...

class AsyncDeviceCapabilitiesUpdate:
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID) -> None: ...
    async def wait(self, timeout: float | None = None) -> Self: ...
    def service_name(self) -> str: ...
    def service_id(self) -> ServiceID | None: ...
    def client_id(self) -> ClientID | None: ...
    def device_name(self) -> str: ...
    def device(self) -> AsyncDevice: ...
    def result(self) -> str: ...
    def status(self) -> DeviceCapabilitiesUpdateStatus: ...

class DeviceCapabilitiesUpdateStatus(Enum):
    FAILURE = 'FAILURE'
    SUCCESS = 'SUCCESS'
    PROCESSING = 'PROCESSING'

class DeviceDictCapabilitiesUpdateStatus(Enum):
    FAILURE = 'FAILURE'
    SUCCESS = 'SUCCESS'
    PROCESSING = 'PROCESSING'
    PARTIAL_SUCCESS = 'PARTIAL_SUCCESS'
