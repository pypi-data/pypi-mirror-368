import os
from ..auto_incrementing_id import Id
from ..device import AsyncDevice
from ..exceptions import ClientError
from ..service import AsyncService
from ..state import AsyncServiceState
from .socket_forwarding import AsyncSocketForwarder
from .streams import AsyncBinaryStreamRequest
from _typeshed import Incomplete
from collections.abc import Callable, Coroutine, Sequence
from dataclasses import dataclass
from enum import Enum
from pathlib import Path, PurePosixPath
from radkit_common.identities import ClientID, ServiceID
from radkit_common.protocol import terminal as p
from radkit_common.protocol.device_actions import DeviceAction
from radkit_common.protocol.upload_parameters import UploadParameters
from radkit_common.rpc.definition import NOTHING
from radkit_common.terminal_interaction import DeviceInformation, ExecSequence, Interaction
from radkit_common.terminal_interaction.prompt_detection import PromptDetectionStrategy
from typing import Any, Generic
from typing_extensions import Self
from uuid import UUID

__all__ = ['AsyncTerminalConnection', 'AsyncInteractiveConnection', 'InteractiveConnectionStatus', 'AsyncFileReadConnection', 'AsyncFileWriteConnection', 'FileTransferStatus', 'TerminalConnectionError', 'AnyAsyncTerminalConnection', 'FileParams']

class TerminalConnectionError(ClientError): ...

class AsyncTerminalConnection(Generic[_T_RequestModel, _T_ResponseModel, _T_UploadModel]):
    id: Id
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID, request: AsyncBinaryStreamRequest[_T_RequestModel, _T_ResponseModel, _T_UploadModel]) -> None: ...
    def request(self) -> AsyncBinaryStreamRequest[_T_RequestModel, _T_ResponseModel, _T_UploadModel]: ...
    def closed(self) -> bool: ...
    def session_logs(self) -> Sequence[AsyncSessionLog]: ...
    def session_log_filepath(self) -> Path | None: ...
    def session_log_filename(self) -> str | None: ...
    async def session_log_rotate(self, new_filepath: str | Path | None = None) -> None: ...
    async def wait(self, timeout: float | None = None) -> Self: ...
    def at_eof(self) -> bool: ...
    def bytes_read(self) -> int: ...
    def bytes_written(self) -> int: ...
    def service_name(self) -> str: ...
    def client_id(self) -> ClientID | None: ...
    def service_id(self) -> ServiceID | None: ...
    def device_name(self) -> str: ...
    def device(self) -> AsyncDevice: ...
    def service(self) -> AsyncService: ...
    async def read_chunk(self, *, timeout: float | None = None) -> bytes: ...
    async def read(self, n: int = -1, *, timeout: float | None = None) -> bytes: ...
    async def unread(self, data: bytes) -> None: ...
    async def readline(self, *, timeout: float | None = None) -> bytes: ...
    async def readexactly(self, n: int, *, timeout: float | None = None) -> bytes: ...
    async def readuntil(self, separator: bytes = b'\n', *, timeout: float | None = None) -> bytes: ...
    async def readuntil_regex(self, pattern: bytes, *, timeout: float | None = None) -> bytes: ...
    async def write(self, data: str | bytes) -> None: ...
    async def write_eof(self) -> None: ...
    def close(self) -> None: ...
    async def wait_closed(self) -> Self: ...
    async def attach_socket(self) -> AsyncSocketForwarder: ...
    async def detach_socket(self) -> None: ...
    def socket_forwarder(self) -> AsyncSocketForwarder: ...
    async def set_terminal_size(self, *, columns: int, rows: int) -> None: ...
    async def get_terminal_size(self) -> tuple[int, int] | None: ...
    async def run_terminal_interaction(self, interaction: Interaction[_T]) -> tuple[_T, bytes]: ...

class InteractiveConnectionStatus(Enum):
    CONNECTING = 'CONNECTING'
    CONNECTED = 'CONNECTED'
    FAILURE = 'FAILURE'
    CLOSED = 'CLOSED'

class AsyncInteractiveConnection(AsyncTerminalConnection[DeviceAction[p.StartInteractiveTerminal], p.InteractiveSSHDownload, p.InteractiveSSHUpload]):
    __pt_repr__: Incomplete
    term: Incomplete
    initial_terminal_size: Incomplete
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID, initial_terminal_size: os.terminal_size, command: str | None = None, term: str | None = None, request_pty: bool = True, include_initialization: bool = False) -> None: ...
    def status(self) -> InteractiveConnectionStatus: ...
    async def attach(self) -> None: ...
    async def set_terminal_size(self, *, columns: int, rows: int) -> None: ...
    async def exec(self, command: str, prompt_detection_strategy: PromptDetectionStrategy | None = None) -> str: ...
    async def readuntil_timeout(self, timeout: float) -> bytes: ...
    async def run_remote_exec_sequence(self, exec_sequence: ExecSequence, upload_to: UploadParameters | None = None) -> bytes: ...
    async def run_remote_exec_sequence_as_connection(self, exec_sequence: ExecSequence, upload_to: UploadParameters | None = None) -> AsyncRemoteExecSequenceConnection: ...
    async def run_remote_procedure(self, name: str) -> bytes: ...
    async def run_exec_sequence(self, exec_sequence: ExecSequence, device_information: DeviceInformation | None = None) -> bytes: ...
    async def run_procedure(self, name: str, device_information: DeviceInformation | None = None) -> bytes: ...

class FileTransferStatus(Enum):
    PREPARING = 'PREPARING'
    CONNECTED = 'CONNECTED'
    UPLOADING = 'UPLOADING'
    DOWNLOADING = 'DOWNLOADING'
    TRANSFER_DONE = 'TRANSFER_DONE'
    ABORTED = 'ABORTED'
    CLOSED = 'CLOSED'
    FAILURE = 'FAILURE'

@dataclass
class FileParams:
    chmod: str
    size: int
    remote_path: PurePosixPath

class AsyncFileTransferConnection(AsyncTerminalConnection[_T_RequestModel, _T_ResponseModel, _T_UploadModel], Generic[_T_RequestModel, _T_ResponseModel, _T_UploadModel]):
    __pt_repr__: Incomplete
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID, request: AsyncBinaryStreamRequest[_T_RequestModel, _T_ResponseModel, _T_UploadModel]) -> None: ...
    def close(self) -> None: ...
    def remote_path(self) -> str | None: ...
    def local_path(self) -> str | None: ...
    def abs_local_path(self) -> str | None: ...
    def status(self) -> FileTransferStatus: ...
    def params(self) -> FileParams: ...
    async def wait_transfer_done(self) -> Self: ...
    async def show_progress(self) -> None: ...

class AsyncFileReadConnection(AsyncFileTransferConnection[DeviceAction[p.ReadFile], p.ReadFileDownload, NOTHING]):
    scp_params: Incomplete
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID, transfer_method: p.FileTransferMethod, remote_path: str, local_path: str | None) -> None: ...
    async def read(self, n: int = -1, *, timeout: float | None = None) -> bytes: ...
    async def readline(self, *, timeout: float | None = None) -> bytes: ...
    async def readexactly(self, n: int, *, timeout: float | None = None) -> bytes: ...
    async def readuntil(self, separator: bytes = b'\n', *, timeout: float | None = None) -> bytes: ...
    async def readuntil_regex(self, pattern: bytes = b'\n', *, timeout: float | None = None) -> bytes: ...

class AsyncFileWriteConnection(AsyncFileTransferConnection[DeviceAction[p.WriteFile], p.WriteFileDownload, p.WriteFileUpload]):
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID, transfer_method: p.FileTransferMethod, chmod: str, file_size: int, remote_path: str, local_path: str | None) -> None: ...
    async def write(self, data: str | bytes) -> None: ...

class AsyncRemoteExecSequenceConnection(AsyncTerminalConnection[DeviceAction[p.StartInteractiveTerminalExecSequence], p.InteractiveTerminalExecSequenceDownload, NOTHING]):
    def __init__(self, service_state: AsyncServiceState, device_uuid: UUID, main_connection: AsyncInteractiveConnection, exec_sequence: ExecSequence, upload_to: UploadParameters | None) -> None: ...
    async def wait(self, timeout: float | None = None) -> Self: ...
NewFilePath = str | Path | None

@dataclass(repr=False)
class AsyncSessionLog:
    __pt_repr__ = ...
    def __init__(self, id: int, device_name: str, filepath: Path, rotate_func: Callable[[Path], Coroutine[Any, Any, None]]) -> None: ...
    def id(self) -> int: ...
    def filepath(self) -> Path: ...
    def filename(self) -> str: ...
    def device_name(self) -> str: ...
    async def rotate(self, new_filepath: NewFilePath = None) -> None: ...
AnyAsyncTerminalConnection = AsyncInteractiveConnection | AsyncFileReadConnection | AsyncFileWriteConnection
