from futile.Utils import write as safe_print
from BigDFT.Calculators import Runner


class NWChemCalculator(Runner):
    """
    A calculator that drives NWChem calculations through the command line.

    This calculator will look in the environment for the following variables:
    * OMP_NUM_THREADS : number of threads to use
    * NWCHEM_MPIRUN : the mpi command you want to launch nwchem with
    * NWCHEM_ROOT : the directory that contains the nwchem executable.
    """
    import os

    def __init__(self, omp=os.environ.get('OMP_NUM_THREADS', '1'),
                 mpi_run=os.environ.get('NWCHEM_MPIRUN', ''),
                 dry_run=False, skip=False, verbose=True):
        # Use the initialization from the Runner class (so all options inside
        # __global_options)
        Runner.__init__(self, omp=str(omp), dry_run=dry_run, skip=skip,
                        mpi_run=mpi_run, verbose=verbose)

        self.command = self._global_options['mpi_run'] + " nwchem"

        if verbose:
            safe_print(
                'Initialize a Calculator with OMP_NUM_THREADS=%s '
                'and command %s' %
                (self._global_options['omp'], self.command))

    def pre_processing(self):
        """
        Process local run dictionary to create the input directory and identify
        the command to be passed

        Returns:
            :py:class:`dict`: dictionary containing the command to be passed to
            :meth:`process_run`
        """
        from os.path import join

        self._ensure_run_directory()
        sys = self.run_options["sys"]
        inp = self.run_options.get("input", {})
        name = self.run_options.get("name", "nwchem")

        inp = [NWBlock("start", name)] + [nwchem_geometry(sys)] + inp

        with open(join(self.run_dir, name + ".nw"), "w") as ofile:
            for v in inp:
                ofile.write(str(v) + "\n")

        return {'command': self._get_command()}

    def process_run(self, command):
        """
        Run the NWChem executable.
        """
        from os import environ, system
        from os.path import join

        # Set the number of omp threads only if the variable is not present
        # in the environment
        if 'OMP_NUM_THREADS' not in environ:
            environ['OMP_NUM_THREADS'] = self.run_options['omp']

        if self.run_options['verbose']:
            if self.run_dir != '.':
                safe_print('Run directory', self.run_dir)
            safe_print('Executing command: ', command)

        # Run the command
        system(command)

        return {'logname': join(self.run_dir, self._get_logname())}

    def post_processing(self, logname, command):
        """
        Post processing the calculation.

        Returns:
            (BigDFT.Interop.NWChemInterop.NWChemLogfile): a representation of
            the detailed output.
        """
        from os.path import join

        logname = join(self.run_dir, self._get_logname())
        return NWChemLogfile(logname)

    def _get_logname(self):
        return self.run_options.get("name", "nwchem") + ".out"

    def _get_command(self):
        if self._check_skip():
            if self.run_options["verbose"]:
                return '''echo "skip"'''
            else:
                return "true"

        iname = self.run_options.get("name", "nwchem")
        oname = self._get_logname()

        cmd = "cd " + self.run_dir + "; "
        cmd += self.run_options["mpi_run"]
        cmd += " nwchem " + iname + " > " + oname

        return cmd

    def _check_skip(self):
        from os.path import join

        if not self.run_options["skip"]:
            return False
        try:
            logname = join(self.run_dir, self._get_logname())
            return NWChemLogfile(logname)
        except FileNotFoundError:  # No output file
            return False
        except ValueError:  # Calculation not done
            return False
        return False

    def _ensure_run_directory(self):
        from futile.Utils import ensure_dir
        run_dir = self.run_options.get('run_dir', '.')
        # Create the run_dir if not exist
        if ensure_dir(run_dir) and self.run_options['verbose']:
            safe_print("Create the sub-directory '%s'" % run_dir)

        self.run_dir = run_dir


class NWChemLogfile():
    """
    This class stores the values of the output generated by NWChem.

    Attributes:
        energy (float): the energy of the system
        nocca (int): number of occupied alpha orbitals
        noccb (int): number of occupied beta orbitals.
    """
    def __init__(self, logname):
        self._process_values(logname)

    def _process_values(self, logname):
        self.data = []
        with open(logname) as ifile:
            for line in ifile:
                self.data.append(line)

        # Verify that we got to the end
        if "Total times" not in self.data[-1]:
            return ValueError("Not None")

        # Look for an energy value
        self.energy = None
        for line in reversed(self.data):
            if "Total" in line and "energy" in line:
                self.energy = float(line.split()[-1])
                break

        # Get the occupation information
        for line in self.data:
            if "Alpha electrons" in line:
                self.nocca = int(line.split()[-1])
            if "Beta electrons" in line:
                self.noccb = int(line.split()[-1])

    def _extract_KS_data(self):
        self.KS_eigenvalues = []
        self.KS_occupancies = []
        for line in self.data:
            if 'Vector' in line:
                split_line = line.split(' ')
                for i, string in enumerate(split_line):
                    length = len(string)
                    if length > 0:
                        if string[0] == 'E':
                            if length > 2:
                                (self.KS_eigenvalues.append
                                    (float(string[2:].replace('D', 'E'))))
                            elif length == 2:
                                (self.KS_eigenvalues.append
                                    (float(split_line[i+1].replace('D', 'E'))))
                        elif string[0] == 'O':
                            self.KS_occupancies.append(int(string[4]))

    def get_hl_indices(self):
        """
        Extracts Kohn-Sham eigenvalues and occupancies from an NWChem
        Logfile and the indices of the HOMO and LUMO orbitals
        """
        self._extract_KS_data()
        for i in range(len(self.KS_occupancies)):
            if self.KS_occupancies[i] > 0 and self.KS_occupancies[i+1] == 0:
                ihomo = i
                ilumo = i+1
                break
        self.hl_indices = [ihomo, ilumo]

    def get_hl_energies(self):
        """
        Determines frontier energies from an NWChem Logfile

        Returns:
            homo_energy (float): Energy of HOMO
            lumo_energy (float): Energy of LUMO
            hl_gap (float): Energy gap between LUMO and HOMO
        """
        self.get_hl_indices()
        homo_energy = self.KS_eigenvalues[self.hl_indices[0]]
        lumo_energy = self.KS_eigenvalues[self.hl_indices[1]]
        hl_gap = lumo_energy - homo_energy
        self.hl_energies = [homo_energy, lumo_energy, hl_gap]
        return homo_energy, lumo_energy, hl_gap

    def get_tddft_roots(self):
        """
        If you run a tddft calculation, this will extract information
        about the roots.

        Returns:
            (dict): dictionary mapping singlets / triplets lists of roots.
        """
        def get_key():
            key = ""
            if line.split()[2] == "singlet":
                key = "singlet"
            elif line.split()[2] == "triplet":
                key = "triplet"
            else:  # spin unrestricted
                spin_line = self.data[off + 1]
                spin_exp = float(spin_line.split()[-1])
                if abs(0.0 - spin_exp) < 1e-3:
                    key = "singlet"
                elif abs(0.75 - spin_exp) < 1e-3:
                    key = "doublet"
                elif abs(2.0 - spin_exp) < 1e-3:
                    key = "triplet"
            return key

        def process_root():
            root = {}
            line = self.data[off]
            if "S2" in self.data[off + 1]:
                unrestricted = True
                skip = 3
            else:
                unrestricted = False
                skip = 2

            if unrestricted:
                root["Energy"] = float(line.split()[3])
            else:
                root["Energy"] = float(line.split()[4])
            root["Components"] = []
            root["ETC"] = []

            for line in self.data[off+skip:]:
                if "---------------------------------------" in line:
                    break
                if "Occ" in line:
                    comp = {}
                    comp["Occ"] = int(line.split()[1])
                    if unrestricted:
                        comp["Virt"] = int(line.split()[6])
                        comp["Spin_Occ"] = line.split()[2]
                        comp["Comp"] = float(line.split()[9])
                        comp["Spin_Virt"] = line.split()[7]
                    else:
                        comp["Virt"] = int(line.split()[5])
                        comp["Comp"] = float(line.split()[7])
                    root["Components"].append(comp)
                else:
                    root["ETC"].append(line.strip())
            return root

        # Iterate over roots
        data = {}
        for off, line in enumerate(self.data):
            if "Root" in line:
                # Singlet / Triplet / ETC
                key = get_key()
                if key not in data:
                    data[key] = []
                # Get the data
                data[key].append(process_root())

        return data


class NWBlock():
    """
    NWChem input files are basically a list of blocks.
    A block has a title, and a value or list of values.
    The list of values can also be nothing.

    Attributes:
        title (str): the heading of the block being made.
        values (list/str): a list of entries in a given block.
    """
    def __init__(self, title, values=None):
        self.title = title
        self.values = values

    def __str__(self):
        ostr = ""
        if self.values is None:
            ostr += self.title
        elif isinstance(self.values, list):
            ostr += self.title + "\n"
            for v in self.values:
                ostr += str(v) + "\n"
            ostr += "end"
        else:
            ostr += self.title + " " + str(self.values)
        return ostr


def nwchem_geometry(sys):
    """
    Create an NWBlock for a given geometry.

    Args:
        sys (BigDFT.Systems.System): the system being studied.
    """
    block = NWBlock("geometry units angstroms", [])

    for frag in sys.values():
        for at in frag:
            pos = " ".join([str(x) for x in at.get_position("angstroem")])
            if at.q0 is not None:
                pos += f' charge {str(at.atomic_number+float(at.q0))}'
                block.values.append(NWBlock(at.sym+'+', pos))
            else:
                block.values.append(NWBlock(at.sym, pos))
    return block


def nwchem_basis(sys, bname=None, bdict=None, spherical=None):
    """
    Create an NWBlock for a given basis set.

    Arguments:
        sys (BigDFT.Systems.System): the system.
        bname (str): the name of the basis set.
        bdict (dict): a dictionary mapping atoms to basis sets.
        spherical (str): spherical or cartesian. Default left to nwchem.
    """
    # Check Arguments
    if bname is None and bdict is None:
        raise ValueError("Either bname or bdict required.")

    # If just one basis, generate the mapping
    if bname is not None:
        bdict = {}
        for frag in sys.values():
            for at in frag:
                bdict[at.sym] = bname

    # Write
    if spherical is None:
        block = NWBlock("basis", [])
    elif spherical == "spherical":
        block = NWBlock("basis spherical", [])
    elif spherical == "cartesian":
        block = NWBlock("basis cartesian", [])
    else:
        raise ValueError("basis must be spherical or cartesian")
    for k, v in bdict.items():
        block.values.append(k + " library " + v)
    return block


def _example():
    """Example of using NWChem interoperability"""
    from BigDFT.Database.Molecules import get_molecule

    # Create a system.
    sys = get_molecule("H2O")

    # Create an input file
    inp = []

    # Create the Basis Set
    inp.append(nwchem_basis(sys, "6-31G*"))

    # Create the DFT Block
    inp.append(NWBlock("dft",
               values=[NWBlock("XC", "PBE0"), "direct"]))
    inp.append(NWBlock("task", "dft"))

    # Create a calculator.
    code = NWChemCalculator()
    log = code.run(sys=sys, input=inp, name="test", run_dir="work")

    print(log.energy)
    homo_energy, lumo_energy, hl_gap = log.get_hl_energies()
    print(hl_gap)


if __name__ == "__main__":
    _example()
