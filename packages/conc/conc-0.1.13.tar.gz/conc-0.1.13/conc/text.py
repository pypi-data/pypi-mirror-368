"""Text document display class."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/api/78_text.ipynb.

# %% ../nbs/api/78_text.ipynb 3
from __future__ import annotations
from fastcore.basics import patch
import numpy as np
from IPython.display import display, HTML
import polars as pl
import textwrap
import re

# %% auto 0
__all__ = ['Text']

# %% ../nbs/api/78_text.ipynb 5
from .result import Result

# %% ../nbs/api/78_text.ipynb 9
class Text:
	""" Class to represent text documents """
	def __init__(self,
			  tokens:np.ndarray, # list of token strs
			  has_spaces: np.ndarray, # whether token strs followed by space
			  metadata: dict = {}, # metadata for doc as a dict
			  doc_df: pl.DataFrame = None # if provided can be used for enhanced display (e.g. keyword highlighting)
			  ): 
		self.tokens = tokens
		self.has_spaces = has_spaces
		self.metadata = metadata
		self.doc_df = doc_df

# %% ../nbs/api/78_text.ipynb 10
@patch
def _nl2br(self:Text,
           text:str # document text
           ):
    text = text.replace('\r\n', '\n').replace('\r', '\n')
    return text.replace('\n', '<br>\n')

# %% ../nbs/api/78_text.ipynb 11
@patch
def _div(self:Text,
         text:str, # document text
         class_str:str = '' # div class
         ):
    """ Wrap text in div, with optional class """
    if class_str != '':
        class_str = f' class="{class_str}"'
    return f'<div{class_str}>{text}</div>'

# %% ../nbs/api/78_text.ipynb 12
@patch
def corpus_position_to_doc_position(self:Text,
                                      pos:int # position in corpus
                                      ) -> int:
    """ Convert corpus position to document position """

    doc_pos = self.doc_df.with_row_index('doc_position').filter((pl.col('position') == pos) & (pl.col('not_space') == 1)).select(pl.col('doc_position')).collect().item()
    return doc_pos


# %% ../nbs/api/78_text.ipynb 13
@patch
def doc_position_to_corpus_position(self:Text,
                                      pos:int # position in corpus
                                      ) -> int:
    """ Convert doc position to corpus position """

    corpus_pos = self.doc_df.filter(pl.col('not_space') == 1).with_row_index('doc_position').filter((pl.col('doc_position') == pos)).select(pl.col('position')).collect().item()
    return corpus_pos

# %% ../nbs/api/78_text.ipynb 14
@patch
def as_string(self:Text,
              max_tokens: int|None = None, # maximum length of text to display in tokens, if None, display all
              highlighted_token_range: tuple|None = None # range of tokens to highlight, note: these token ids are positions within the corpus, not the text itself
        ):
    """ Return the text as a string """

    interleaved = np.empty((self.tokens.size + self.has_spaces.size,), dtype=self.tokens.dtype)
    
    if self.doc_df is not None and highlighted_token_range is not None:
        doc_pos_start = self.corpus_position_to_doc_position(highlighted_token_range[0])
        doc_pos_end = self.corpus_position_to_doc_position(highlighted_token_range[1])
        tokens_with_highlight = self.tokens.copy()
        tokens_with_highlight[doc_pos_start] = f'<span class="highlight">{tokens_with_highlight[doc_pos_start]}'
        tokens_with_highlight[doc_pos_end] = f'{tokens_with_highlight[doc_pos_end]}</span>'
        interleaved[0::2] = tokens_with_highlight
    else:
        interleaved[0::2] = self.tokens
    interleaved[1::2] = np.where(self.has_spaces, ' ', '')

    if max_tokens is not None and self.tokens.size > max_tokens:
        interleaved = interleaved[:max_tokens * 2]
        interleaved[-1] = ''

    return ''.join(list(interleaved))

# %% ../nbs/api/78_text.ipynb 15
@patch
def as_tokens(self:Text,
        ):
    """ Return the text as a tokens """

    return list(self.tokens)

# %% ../nbs/api/78_text.ipynb 16
@patch
def __str__(self:Text):
    return self.as_string()

# %% ../nbs/api/78_text.ipynb 17
@patch
def tokens_count(self:Text):
    return len(self.tokens)

# %% ../nbs/api/78_text.ipynb 18
@patch
def display_metadata(self:Text,
                ):
    """ Output the metadata for a text """

    Result('metadata', self.metadata.transpose(include_header = True, header_name = 'attribute', column_names = ['value']), 'Metadata', '', {}, []).display()


# %% ../nbs/api/78_text.ipynb 19
@patch
def get_metadata(self:Text,
                ):
    """ Output the metadata for a text """

    return Result('metadata', self.metadata.transpose(include_header = True, header_name = 'attribute', column_names = ['value']), 'Metadata', '', {}, [])

# %% ../nbs/api/78_text.ipynb 20
@patch
def display(self:Text,
			show_metadata: bool = True, # whether to display Metadata for the text
			max_tokens: int|None = None, # maximum length of text to display in tokens, if None, display all
			output_html: bool = True, # whether to display text with HTML formatting
			textwrap_width: int|None = None, # maximum length of text to display in characters, if None, no wrapping
			textwrap_args: dict|None = None, # additional args to pass to textwrap.fill
			reflow_paragraphs: bool = False, # whether to reflow paragraphs individually before text wrapping is applied
			paragraph_delimiter_regex: str = r'(\s*\n\s*){1,}\n', # regex to split paragraphs for reflow_paragraphs (default looks for whitespace ending with a newline that contains at least one other newline)
				):
	""" Output a text """

	# TODO - add font size, font family and style overrides

	style = '''
	<style>
	.conc-text-wrapper { background: #fff; color: #000; border: 1px solid #000;border-radius: 0.5em;width: max-content;padding: 0.3em; min-width: 400px;} 
	.conc-text {margin:0.3em; white-space: pre-wrap; font-family: Georgia, Cambria, "Times New Roman", Times, serif;font-size: 1.3em; width: max-content;}
  </style>
	'''
	metadata = ''
	if show_metadata:
		metadata = self.get_metadata().to_html()

	text_string = self.as_string(max_tokens = max_tokens)

	if max_tokens is not None and self.tokens.size > max_tokens:
		text_string += f'â€¦\n[{max_tokens} of {self.tokens.size} tokens]'

	if reflow_paragraphs:
		text_string_chunks = re.split(paragraph_delimiter_regex, text_string)
	else:
		text_string_chunks = [text_string]

	if textwrap_width is not None:
		for i, chunk in enumerate(text_string_chunks):
			text_string_chunks[i] = textwrap.fill(chunk, width = textwrap_width, **(textwrap_args or {}))
	elif reflow_paragraphs:
		text_string_chunks = [re.sub(r'\s+', ' ', chunk.strip()) for chunk in text_string_chunks]
	
	text_string = '\n'.join(text_string_chunks)

	if output_html:
		display(HTML(style + self._div(metadata + self._div(text_string, class_str = 'conc-text'), class_str = 'conc-text-wrapper')))
	else:
		print(text_string)

