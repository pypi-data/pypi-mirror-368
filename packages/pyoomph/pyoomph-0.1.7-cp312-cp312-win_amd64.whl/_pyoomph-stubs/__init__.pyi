"""
This module exposes the compiled C++ core of pyoomph via pybind11 to python. Here, the relevant C++ base classes and further low-level functions can be found. Usually, it is not necessary for a user to use these functions directly.
"""
from __future__ import annotations
import numpy; import numpy.typing
import typing
__all__ = ['AssemblyHandler', 'AzimuthalSymmetryBreakingHandler', 'BulkElementODE0d', 'CCompiler', 'CurvedEntityCatmullRomSpline', 'CurvedEntityCircleArc', 'CurvedEntityCylinderArc', 'CurvedEntitySpherePart', 'CustomCoordinateSystem', 'CustomMathExpression', 'CustomMathExpressionBase', 'CustomMultiReturnExpression', 'CustomMultiReturnExpressionBase', 'CustomResJacInfo', 'DofAugmentations', 'Domain', 'DynamicBulkElementInstance', 'Equations', 'Expression', 'FinaliseMPI', 'FiniteElementCode', 'FiniteElementField', 'FoldHandler', 'GeneralSolverCallback', 'GeomObject', 'GiNaC_Diff', 'GiNaC_EvalFlag', 'GiNaC_FakeExponentialMode', 'GiNaC_GlobalParam', 'GiNaC_Matrix', 'GiNaC_SymSubs', 'GiNaC_TimeSymbol', 'GiNaC_UnitVect', 'GiNaC_Vect', 'GiNaC_absolute', 'GiNaC_acos', 'GiNaC_asin', 'GiNaC_atan', 'GiNaC_atan2', 'GiNaC_collect', 'GiNaC_collect_common_factors', 'GiNaC_collect_units', 'GiNaC_contract', 'GiNaC_cos', 'GiNaC_cosh', 'GiNaC_debug_ex', 'GiNaC_delayed_expansion', 'GiNaC_determinant', 'GiNaC_diff', 'GiNaC_dimtestfunction', 'GiNaC_dimtestfunction_from_var', 'GiNaC_directional_derivative', 'GiNaC_div', 'GiNaC_dot', 'GiNaC_double_dot', 'GiNaC_eval_at_expansion_mode', 'GiNaC_eval_in_domain', 'GiNaC_eval_in_past', 'GiNaC_exp', 'GiNaC_expand', 'GiNaC_factor', 'GiNaC_field', 'GiNaC_general_weak_differential_contribution', 'GiNaC_get_global_symbol', 'GiNaC_get_imag_part', 'GiNaC_get_real_part', 'GiNaC_grad', 'GiNaC_heaviside', 'GiNaC_imaginary_i', 'GiNaC_internal_function_with_element_arg', 'GiNaC_inverse_matrix', 'GiNaC_is_a_matrix', 'GiNaC_log', 'GiNaC_matproduct', 'GiNaC_maximum', 'GiNaC_minimize_functional_derivative', 'GiNaC_minimum', 'GiNaC_new_symbol', 'GiNaC_nondimfield', 'GiNaC_normal', 'GiNaC_piecewise_geq0', 'GiNaC_print_FEM_options', 'GiNaC_python_cb_function', 'GiNaC_python_multi_cb_function', 'GiNaC_python_multi_cb_indexed_result', 'GiNaC_rational_number', 'GiNaC_remove_mode_from_jacobian_or_hessian', 'GiNaC_scale', 'GiNaC_sep_base_units', 'GiNaC_series', 'GiNaC_signum', 'GiNaC_sin', 'GiNaC_sinh', 'GiNaC_split_subexpressions_in_real_and_imaginary_parts', 'GiNaC_subexpression', 'GiNaC_subs', 'GiNaC_subsfields', 'GiNaC_tan', 'GiNaC_tanh', 'GiNaC_testfunction', 'GiNaC_testfunction_from_var', 'GiNaC_testscale', 'GiNaC_time_stepper_weight', 'GiNaC_trace', 'GiNaC_transpose', 'GiNaC_unit', 'GiNaC_unit_matrix', 'GiNaC_vector_dim', 'GiNaC_weak', 'GiNaC_wrap_coordinate_system', 'HopfHandler', 'InitMPI', 'InterfaceMesh', 'LaTeXPrinter', 'MacroElement', 'Mesh', 'MeshTemplate', 'MeshTemplateCurvedEntity', 'MeshTemplateCurvedEntityBase', 'MeshTemplateElementBrickC1', 'MeshTemplateElementBrickC2', 'MeshTemplateElementCollection', 'MeshTemplateElementLineC1', 'MeshTemplateElementLineC2', 'MeshTemplateElementPoint', 'MeshTemplateElementQuadC1', 'MeshTemplateElementQuadC2', 'MeshTemplateElementTetraC1', 'MeshTemplateElementTetraC2', 'MeshTemplateElementTriC1', 'MeshTemplateElementTriC2', 'MultiTimeStepper', 'Node', 'ODEStorageMesh', 'OomphData', 'OomphDomain', 'OomphGeneralisedElement', 'OomphMesh', 'PeriodicOrbitHandler', 'PitchForkHandler', 'Problem', 'QMacroElement2', 'SharedLibCCompiler', 'SparseRank3Tensor', 'TemplatedMeshBase1d', 'TemplatedMeshBase2d', 'TemplatedMeshBase3d', 'Time', 'TimeStepper', 'TracerCollection', 'VectorDouble', 'Z2ErrorEstimator', 'csr_rows_to_coo_rows', 'feenableexcept', 'get_Solver_callback', 'get_verbosity_flag', 'has_tcc', 'set_Solver_callback', 'set_interpolate_new_interface_dofs', 'set_jit_include_dir', 'set_tolerance_for_singular_jacobian', 'set_use_eigen_Z2_error_estimators', 'set_verbosity_flag']
class AssemblyHandler:
    pass
class AzimuthalSymmetryBreakingHandler(AssemblyHandler):
    def set_eigenweight(self, arg0: float) -> None:
        ...
    def set_global_equations_forced_zero(self, arg0: set[int], arg1: set[int]) -> None:
        ...
class BulkElementODE0d(OomphGeneralisedElement):
    @staticmethod
    def construct_new(arg0: DynamicBulkElementInstance, arg1: TimeStepper) -> BulkElementODE0d:
        ...
    def __init__(self, arg0: DynamicBulkElementInstance, arg1: TimeStepper) -> None:
        ...
    def _debug(self) -> None:
        ...
    def _debug_hessian(self, arg0: list[float], arg1: list[list[float]], arg2: float) -> None:
        ...
    def internal_data_pt(self, arg0: int) -> OomphData:
        ...
    def ninternal_data(self) -> int:
        ...
    def to_numpy(self) -> tuple[numpy.typing.NDArray[numpy.float64], dict[str, int]]:
        ...
class CCompiler:
    def __init__(self) -> None:
        ...
    def compile(self, arg0: bool, arg1: bool, arg2: bool, arg3: list[str]) -> bool:
        ...
    def compiling_to_memory(self) -> bool:
        ...
    def get_code_trunk(self) -> str:
        ...
    def sanity_check(self) -> bool:
        ...
class CurvedEntityCatmullRomSpline(MeshTemplateCurvedEntityBase):
    def __init__(self, arg0: list[list[float]]) -> None:
        ...
class CurvedEntityCircleArc(MeshTemplateCurvedEntityBase):
    def __init__(self, arg0: list[float], arg1: list[float], arg2: list[float]) -> None:
        ...
class CurvedEntityCylinderArc(MeshTemplateCurvedEntityBase):
    def __init__(self, arg0: list[float], arg1: list[float], arg2: list[float]) -> None:
        ...
class CurvedEntitySpherePart(MeshTemplateCurvedEntityBase):
    def __init__(self, arg0: list[float], arg1: list[float], arg2: list[float]) -> None:
        ...
class CustomCoordinateSystem:
    def __init__(self) -> None:
        ...
    def directional_derivative(self, arg: Expression, direct: Expression, ndim: int, edim: int, flags: int) -> Expression:
        ...
    def div(self, arg: Expression, ndim: int, edim: int, flags: int) -> Expression:
        ...
    def general_weak_differential_contribution(self, funcname: str, lhs: list[Expression], test: Expression, dim: int, edim: int, flags: int) -> Expression:
        ...
    def geometric_jacobian(self) -> Expression:
        ...
    def get_id_name(self) -> str:
        ...
    def get_mode_expansion_of_var_or_test(self, code: FiniteElementCode, fieldname: str, is_field: bool, is_dim: bool, expr: Expression, where: str, expansion_mode: int) -> Expression:
        ...
    def grad(self, arg: Expression, ndim: int, edim: int, flags: int) -> Expression:
        ...
    def jacobian_for_element_size(self) -> Expression:
        ...
    def vector_gradient_dimension(self, basedim: int, lagrangian: bool) -> int:
        ...
class CustomMathExpression(CustomMathExpressionBase):
    def __init__(self) -> None:
        ...
    def eval(self, arg_array: numpy.typing.NDArray[numpy.float64]) -> float:
        ...
    def get_argument_unit(self, index: int) -> Expression:
        ...
    def get_diff_index(self) -> int:
        ...
    def get_diff_parent(self) -> CustomMathExpressionBase:
        ...
    def get_id_name(self) -> str:
        ...
    def get_result_unit(self) -> Expression:
        ...
    def imag_part(self, invokation: Expression, arglst: list[Expression]) -> Expression:
        ...
    def outer_derivative(self, x: Expression, index: int) -> Expression:
        ...
    def real_part(self, invokation: Expression, arglst: list[Expression]) -> Expression:
        ...
    @typing.overload
    def set_as_derivative(self, arg0: CustomMathExpression, arg1: int) -> None:
        ...
    @typing.overload
    def set_as_derivative(self, arg0: CustomMathExpression, arg1: int) -> None:
        ...
class CustomMathExpressionBase:
    pass
class CustomMultiReturnExpression(CustomMultiReturnExpressionBase):
    def __init__(self) -> None:
        ...
    def _get_c_code(self) -> str:
        ...
    def _get_symbolic_derivative(self, arg0: list[Expression], arg1: int, arg2: int) -> tuple[bool, Expression]:
        ...
    def eval(self, flag: int, arg_list: numpy.typing.NDArray[numpy.float64], result_list: numpy.typing.NDArray[numpy.float64], derivative_matrix: numpy.typing.NDArray[numpy.float64]) -> None:
        ...
    def get_id_name(self) -> str:
        ...
    def set_debug_python_vs_c_epsilon(self, arg0: float) -> None:
        ...
class CustomMultiReturnExpressionBase:
    pass
class CustomResJacInfo:
    def get_parameter_name(self) -> str:
        ...
    def require_jacobian(self) -> bool:
        ...
    def set_custom_jacobian(self, arg0: numpy.typing.NDArray[numpy.float64], arg1: numpy.typing.NDArray[numpy.int32], arg2: numpy.typing.NDArray[numpy.int32]) -> None:
        ...
    def set_custom_residuals(self, arg0: numpy.typing.NDArray[numpy.float64]) -> None:
        ...
class DofAugmentations:
    def add_parameter(self, arg0: str) -> int:
        ...
    def add_scalar(self, arg0: float) -> int:
        ...
    def add_vector(self, arg0: list[float]) -> int:
        ...
    def split(self, startindex: int = 1, endindex: int = -1) -> list[numpy.typing.NDArray[numpy.float64]]:
        """
        splits the augmented dof vector into its components. By default, all augmented dofs (without base dofs), but can be controlled by startindex and endindex
        """
class Domain(OomphDomain):
    def __init__(self) -> None:
        ...
class DynamicBulkElementInstance:
    def _exchange_mesh(self, arg0: Mesh) -> None:
        ...
    def can_be_time_adaptive(self) -> bool:
        ...
    def get_discontinuous_field_index(self, arg0: str) -> int:
        ...
    def get_elemental_field_indices(self) -> dict[str, int]:
        ...
    def get_max_dt_order(self) -> int:
        ...
    def get_nodal_field_index(self, arg0: str) -> int:
        ...
    def get_nodal_field_indices(self) -> dict[str, int]:
        ...
    def has_moving_nodes(self) -> bool:
        ...
    def has_parameter_contribution(self, arg0: str) -> bool:
        ...
    def link_external_data(self, arg0: str, arg1: OomphData, arg2: int) -> None:
        ...
    def set_analytical_jacobian(self, analytic: bool, analytic_positions: bool) -> None:
        ...
class Equations:
    def __init__(self) -> None:
        ...
    def _define_element(self) -> None:
        ...
    def _define_fields(self) -> None:
        ...
    def _get_current_codegen(self) -> FiniteElementCode:
        ...
    def _set_current_codegen(self, arg0: FiniteElementCode) -> None:
        ...
class Expression:
    @typing.overload
    def __add__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    def __complex__(self) -> complex:
        ...
    def __float__(self) -> float:
        ...
    @typing.overload
    def __getitem__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __getitem__(self, arg0: tuple) -> Expression:
        ...
    @typing.overload
    def __iadd__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __iadd__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __iadd__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __imul__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __init__(self, arg0: int) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: Expression) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: float) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: str) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[float]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: list[Expression]) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: GiNaC_GlobalParam) -> None:
        ...
    def __int__(self) -> int:
        ...
    @typing.overload
    def __isub__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __isub__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __isub__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __itruediv__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    def __matmul__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    def __neg__(self) -> Expression:
        ...
    @typing.overload
    def __pow__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __pow__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __pow__(self: int, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __pow__(self: float, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __pow__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __pow__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __radd__(self, arg0: complex) -> Expression:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rmul__(self, arg0: complex) -> Expression:
        ...
    def __round__(self) -> int:
        ...
    @typing.overload
    def __rpow__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rpow__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rpow__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rsub__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __rtruediv__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rtruediv__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rtruediv__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: complex) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    def acos(self) -> Expression:
        ...
    def asin(self) -> Expression:
        ...
    def atan(self) -> Expression:
        ...
    def atan2(self, arg0: Expression) -> Expression:
        ...
    def cos(self) -> Expression:
        ...
    def denom(self) -> Expression:
        ...
    def evalf(self) -> Expression:
        ...
    def evalm(self) -> Expression:
        ...
    def exp(self) -> Expression:
        ...
    def float_value(self) -> float:
        ...
    def get_type_information(self) -> dict[str, str]:
        ...
    def is_zero(self) -> bool:
        ...
    def log(self) -> Expression:
        ...
    def nops(self) -> int:
        ...
    def numer(self) -> Expression:
        ...
    def op(self, arg0: int) -> Expression:
        ...
    def print_latex(self) -> str:
        ...
    def sin(self) -> Expression:
        ...
    def sqrt(self) -> Expression:
        ...
    def tan(self) -> Expression:
        ...
    def tanh(self) -> Expression:
        ...
class FiniteElementCode:
    _coordinate_space: str
    _coordinates_as_dofs: bool
    analytical_jacobian: bool
    analytical_position_jacobian: bool
    bulk_position_space_to_C1: bool
    ccode_expression_mode: str
    debug_jacobian_epsilon: float
    stop_on_jacobian_difference: bool
    use_shared_shape_buffer_during_multi_assemble: bool
    warn_on_large_numerical_factor: float
    with_adaptivity: bool
    def __init__(self) -> None:
        ...
    def _activate_residual(self, arg0: str) -> None:
        ...
    def _add_Z2_flux(self, arg0: Expression, arg1: bool) -> None:
        ...
    def _add_residual(self, arg0: Expression, arg1: bool) -> None:
        ...
    def _debug_second_order_Hessian_deriv(self, arg0: Expression, arg1: str, arg2: str) -> None:
        ...
    def _define_element(self) -> None:
        ...
    def _define_fields(self) -> None:
        ...
    def _do_define_fields(self, arg0: int) -> None:
        ...
    def _finalise(self) -> None:
        ...
    def _find_all_accessible_spaces(self) -> None:
        ...
    def _get_dx(self, arg0: bool, arg1: bool) -> Expression:
        ...
    def _get_element_size_symbol(self, arg0: bool, arg1: bool) -> Expression:
        ...
    def _get_extremum_expression_unit_factor(self, arg0: str) -> Expression:
        ...
    def _get_integral_function_unit_factor(self, arg0: str) -> Expression:
        ...
    def _get_integration_order(self) -> int:
        ...
    def _get_local_expression_unit_factor(self, arg0: str) -> Expression:
        ...
    def _get_nodal_delta(self) -> Expression:
        ...
    def _get_normal_component(self, arg0: int) -> Expression:
        ...
    def _get_opposite_interface(self) -> typing.Optional[FiniteElementCode]:
        ...
    def _get_parent_domain(self) -> typing.Optional[FiniteElementCode]:
        ...
    def _index_fields(self) -> None:
        ...
    def _is_ode_element(self) -> bool:
        ...
    def _nullify_bulk_residual(self, arg0: str) -> None:
        ...
    def _register_external_ode_linkage(self, myfieldname: str, odecodegen: FiniteElementCode, odefieldname: str) -> None:
        ...
    def _register_extremum_function(self, arg0: str, arg1: Expression) -> None:
        ...
    def _register_field(self, arg0: str, arg1: str) -> FiniteElementField:
        ...
    def _register_integral_function(self, arg0: str, arg1: Expression) -> list[str]:
        ...
    def _register_local_function(self, arg0: str, arg1: Expression) -> tuple[list[str], int]:
        ...
    def _register_tracer_advection(self, arg0: str, arg1: Expression) -> None:
        ...
    def _resolve_based_on_domain_name(self, domainname: str) -> FiniteElementCode:
        ...
    def _set_Dirichlet_bc(self, arg0: str, arg1: Expression, arg2: bool) -> None:
        ...
    def _set_bulk_element(self, arg0: FiniteElementCode) -> None:
        ...
    def _set_discontinuous_refinement_exponent(self, arg0: str, arg1: float) -> None:
        ...
    def _set_equations(self, arg0: Equations) -> None:
        ...
    def _set_initial_condition(self, arg0: str, arg1: Expression, arg2: str, arg3: str) -> None:
        ...
    def _set_integration_order(self, arg0: int) -> None:
        ...
    def _set_lagrangian_dimension(self, arg0: int) -> None:
        ...
    def _set_nodal_dimension(self, arg0: int) -> None:
        ...
    def _set_opposite_interface(self, arg0: FiniteElementCode) -> None:
        ...
    def _set_reference_point_for_IC_and_DBC(self, arg0: float, arg1: float, arg2: float, arg3: float, arg4: float, arg5: float, arg6: float) -> None:
        ...
    def _set_temporal_error(self, arg0: str, arg1: float) -> None:
        ...
    def derive_expression(self, arg0: Expression, arg1: Expression) -> Expression:
        ...
    def expand_additional_field(self, name: str, dimensional: bool, expression: Expression, in_domain: FiniteElementCode, no_jacobian: bool, no_hessian: bool, where: str) -> Expression:
        ...
    def expand_additional_testfunction(self, name: str, expression: Expression, in_domain: FiniteElementCode) -> Expression:
        ...
    def expand_placeholders(self, arg0: Expression, arg1: bool) -> Expression:
        ...
    def get_all_fieldnames(self, arg0: set[str]) -> set[str]:
        ...
    def get_coordinate_system(self) -> CustomCoordinateSystem:
        ...
    def get_default_spatial_integration_order(self) -> int:
        ...
    def get_default_timestepping_scheme(self, arg0: int) -> str:
        ...
    def get_domain_name(self) -> str:
        ...
    def get_dt(self) -> Expression:
        ...
    def get_element_size(self, use_scaling: bool, lagrangian: bool, with_coordsys: bool, coordsys: CustomCoordinateSystem) -> Expression:
        ...
    def get_equations(self) -> Equations:
        ...
    def get_integral_dx(self, use_scaling: bool, lagrangian: bool, coordsys: CustomCoordinateSystem) -> Expression:
        ...
    def get_lagrangian_dimension(self) -> int:
        ...
    def get_nodal_dimension(self) -> int:
        ...
    def get_scaling(self, arg0: str, arg1: bool) -> Expression:
        ...
    def get_space_of_field(self, arg0: str) -> str:
        ...
    def get_time(self) -> Expression:
        ...
    def set_derive_hessian_by_expansion_mode(self, arg0: str, arg1: int) -> None:
        ...
    def set_derive_jacobian_by_expansion_mode(self, arg0: str, arg1: int) -> None:
        ...
    def set_ignore_dpsi_coord_diffs_in_jacobian(self, arg0: str) -> None:
        ...
    def set_ignore_residual_assembly(self, arg0: str) -> None:
        ...
    def set_latex_printer(self, arg0: typing.Optional[LaTeXPrinter]) -> None:
        ...
    @property
    def dimension(self) -> int:
        ...
class FiniteElementField:
    pass
class FoldHandler(AssemblyHandler):
    FD_step: float
    symmetric_FD: bool
    def get_eigenfunction(self) -> numpy.typing.NDArray[numpy.float64]:
        ...
    def set_eigenweight(self, arg0: float) -> None:
        ...
class GeneralSolverCallback:
    def __init__(self) -> None:
        ...
    def metis_partgraph_kway(self, nvertex: int, xadj: numpy.typing.NDArray[numpy.int32], adjacency_vector: numpy.typing.NDArray[numpy.int32], vwgt: numpy.typing.NDArray[numpy.int32], adjwgt: numpy.typing.NDArray[numpy.int32], wgtflag: int, numflag: int, nparts: int, options: numpy.typing.NDArray[numpy.int32], edgecut: numpy.typing.NDArray[numpy.int32], part: numpy.typing.NDArray[numpy.int32]) -> None:
        ...
    def solve_la_system_distributed(self, op_flag: int, allow_permutations: int, n: int, nnz_local: int, nrow_local: int, first_row: int, values: numpy.typing.NDArray[numpy.float64], col_index: numpy.typing.NDArray[numpy.int32], row_start: numpy.typing.NDArray[numpy.int32], b: numpy.typing.NDArray[numpy.float64], nprow: int, npcol: int, doc: int, data: numpy.typing.NDArray[numpy.uint64], info: numpy.typing.NDArray[numpy.int32]) -> None:
        ...
    def solve_la_system_serial(self, op_flag: int, n: int, nnz: int, nrhs: int, values: numpy.typing.NDArray[numpy.float64], rowind: numpy.typing.NDArray[numpy.int32], colptr: numpy.typing.NDArray[numpy.int32], b: numpy.typing.NDArray[numpy.float64], ldb: int, transpose: int) -> int:
        ...
class GeomObject:
    def __init__(self) -> None:
        ...
class GiNaC_GlobalParam:
    analytical_derivative: bool
    value: float
    @typing.overload
    def __add__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __add__(self, arg0: float) -> Expression:
        ...
    def __float__(self) -> float:
        ...
    @typing.overload
    def __mul__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __mul__(self, arg0: float) -> Expression:
        ...
    def __neg__(self) -> Expression:
        ...
    @typing.overload
    def __pow__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __pow__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __pow__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __radd__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __radd__(self, arg0: float) -> Expression:
        ...
    def __repr__(self) -> str:
        ...
    @typing.overload
    def __rmul__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rmul__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rpow__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rpow__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rpow__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rsub__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rsub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __rtruediv__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __rtruediv__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __sub__(self, arg0: float) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: GiNaC_GlobalParam) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: Expression) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: int) -> Expression:
        ...
    @typing.overload
    def __truediv__(self, arg0: float) -> Expression:
        ...
    def get_name(self) -> str:
        ...
    def get_symbol(self) -> Expression:
        ...
    def restrict_to_positive_values(self) -> None:
        ...
class GiNaC_print_FEM_options:
    def __init__(self) -> None:
        ...
    def get_code(self) -> FiniteElementCode:
        ...
class HopfHandler(AssemblyHandler):
    def debug_analytical_filling(self, arg0: OomphGeneralisedElement, arg1: float) -> None:
        ...
    def get_nicely_rotated_eigenfunction(self) -> list[complex]:
        ...
class InterfaceMesh(Mesh, OomphMesh):
    def __init__(self) -> None:
        ...
    def _connect_interface_elements_by_kdtree(self, arg0: InterfaceMesh) -> None:
        ...
    def _get_problem(self) -> Problem:
        ...
    def _set_problem(self, arg0: Problem, arg1: typing.Optional[DynamicBulkElementInstance]) -> None:
        ...
    def clear_before_adapt(self) -> None:
        ...
    def get_bulk_mesh(self) -> Mesh:
        ...
    def get_opposite_interface_offset_vector(self) -> list[float]:
        ...
    def nullify_selected_bulk_dofs(self) -> None:
        ...
    def rebuild_after_adapt(self) -> None:
        ...
    def set_opposite_interface_offset_vector(self, arg0: list[float]) -> None:
        ...
    def update_zeta_in_buffer(self) -> None:
        ...
class LaTeXPrinter:
    def __init__(self) -> None:
        ...
class MacroElement:
    pass
class Mesh(OomphMesh):
    max_keep_unrefined: int
    max_permitted_error: float
    max_refinement_level: int
    min_permitted_error: float
    min_refinement_level: int
    def _enlarge_elemental_error_max_override_to_only_nodal_connected_elems(self, arg0: int) -> None:
        ...
    def _evaluate_extremum(self, arg0: str, arg1: int, arg2: int) -> tuple[Expression, list[float], OomphGeneralisedElement]:
        ...
    def _evaluate_integral_function(self, arg0: str) -> Expression:
        ...
    def _get_dirichlet_active(self, arg0: str) -> bool:
        ...
    def _load_state(self, arg0: list[float]) -> None:
        ...
    def _pin_all_my_dofs(self, arg0: set[str], arg1: set[str], arg2: set[int]) -> None:
        ...
    def _save_state(self) -> list[float]:
        ...
    def _set_dirichlet_active(self, arg0: str, arg1: bool) -> None:
        ...
    def _set_time_level_for_projection(self, arg0: int) -> None:
        ...
    def _setup_information_from_old_mesh(self, arg0: Mesh) -> None:
        ...
    def activate_duarte_debug(self) -> None:
        ...
    def adapt_by_elemental_errors(self, arg0: list[float]) -> None:
        ...
    def add_boundary_node(self, arg0: int, arg1: Node) -> None:
        ...
    def add_interpolated_nodes_at(self, arg0: list[list[float]], arg1: bool) -> list[Node]:
        ...
    def boundary_coordinate_bool(self, arg0: int) -> None:
        ...
    def check_integrity(self) -> None:
        ...
    def describe_global_dofs(self) -> tuple[list[int], list[str]]:
        ...
    def describe_my_dofs(self, arg0: str) -> str:
        ...
    def ensure_external_data(self) -> None:
        ...
    def ensure_halos_for_periodic_boundaries(self) -> None:
        ...
    def evaluate_local_expression_at_nodes(self, arg0: int, arg1: bool, arg2: bool) -> list[float]:
        ...
    def fill_dof_types(self, arg0: numpy.typing.NDArray[numpy.int32]) -> None:
        ...
    def fill_node_index_to_node_map(self) -> list[Node]:
        ...
    def flush_element_storage(self) -> None:
        ...
    def generate_interface_elements(self, arg0: str, arg1: Mesh, arg2: DynamicBulkElementInstance) -> None:
        ...
    def get_boundary_index(self, arg0: str) -> int:
        ...
    def get_boundary_names(self) -> list[str]:
        ...
    def get_element_dimension(self) -> int:
        ...
    def get_field_information(self) -> dict[str, str]:
        ...
    def get_node_reordering(self, arg0: bool) -> list[Node]:
        ...
    def get_output_scale(self, arg0: str) -> float:
        ...
    def get_refinement_pattern(self) -> list[numpy.typing.NDArray[numpy.uint32]]:
        ...
    def get_values_at_zetas(self, arg0: numpy.typing.NDArray[numpy.float64], arg1: bool) -> tuple[list[list[float]], list[bool], dict[str, int]]:
        ...
    def has_interface_dof_id(self, arg0: str) -> int:
        ...
    def invalidate_lagrangian_kdtree(self) -> None:
        ...
    def is_boundary_coordinate_defined(self, arg0: int) -> bool:
        ...
    def is_mesh_distributed(self) -> bool:
        ...
    def list_integral_functions(self) -> list[str]:
        ...
    def list_local_expressions(self) -> list[str]:
        ...
    def nodal_interpolate_along_boundary(self, arg0: Mesh, arg1: int, arg2: int, arg3: Mesh, arg4: Mesh, arg5: float) -> None:
        ...
    def nodal_interpolate_from(self, arg0: Mesh, arg1: int) -> None:
        ...
    def nrefined(self) -> int:
        ...
    def nunrefined(self) -> int:
        ...
    def prepare_interpolation(self) -> None:
        ...
    def prepare_zeta_interpolation(self, arg0: Mesh) -> None:
        ...
    def refine_base_mesh(self, arg0: list[list[int]]) -> None:
        ...
    def remove_boundary_nodes(self) -> None:
        ...
    def remove_boundary_nodes_of_bound(self, arg0: int) -> None:
        ...
    def reorder_nodes(self, arg0: bool) -> None:
        ...
    def set_initial_condition(self, arg0: str, arg1: Expression) -> None:
        ...
    def set_lagrangian_nodal_coordinates(self) -> None:
        ...
    def set_output_scale(self, arg0: str, arg1: Expression, arg2: DynamicBulkElementInstance) -> None:
        ...
    def set_spatial_error_estimator_pt(self, arg0: Z2ErrorEstimator) -> None:
        ...
    def setup_Dirichlet_conditions(self, arg0: bool) -> None:
        ...
    def setup_initial_conditions(self, arg0: bool, arg1: str) -> None:
        ...
    def setup_interior_boundary_elements(self, arg0: int) -> None:
        ...
    def to_numpy(self, tesselate_tri: bool, nondimensional: bool, history_index: int = 0, discontinuous: bool = False) -> tuple[numpy.typing.NDArray[numpy.float64], numpy.typing.NDArray[numpy.int32], numpy.typing.NDArray[numpy.int32], dict[str, int], numpy.typing.NDArray[numpy.float64], numpy.typing.NDArray[numpy.float64], dict[str, int]]:
        ...
class MeshTemplate:
    """
    A base class for the MeshTemplate class in pyoomph
    """
    def __init__(self) -> None:
        ...
    def _find_interface_intersections(self) -> set[str]:
        ...
    def _find_opposite_interface_connections(self) -> None:
        ...
    def _set_problem(self, arg0: Problem) -> None:
        ...
    def add_facet_to_curve_entity(self, arg0: list[int], arg1: MeshTemplateCurvedEntityBase) -> None:
        """
        Adds a facet to a curved boundary so that e.g. additional nodes of refined meshes will be exactly on this curve
        """
    def add_node(self, x: float, y: float = 0.0, z: float = 0.0) -> int:
        """
        Adds a node at the given position. Creates overlapping nodes, if there is already a node at this position.
        """
    def add_node_unique(self, x: float, y: float = 0.0, z: float = 0.0) -> int:
        """
        Adds a node at the given position. If there is already a node at this position,no new node is created
        """
    def add_nodes_to_boundary(self, arg0: str, arg1: list[int]) -> None:
        """
        Adds a list of nodes, i.e. a facet, to a boundary
        """
    def add_periodic_node_pair(self, n_mst: int, n_slv: int) -> None:
        ...
    def get_node_position(self, arg0: int) -> list[float]:
        ...
    def new_bulk_element_collection(self, arg0: str) -> MeshTemplateElementCollection:
        ...
class MeshTemplateCurvedEntity(MeshTemplateCurvedEntityBase):
    def __init__(self, arg0: int) -> None:
        ...
    def ensure_periodicity(self, param: numpy.typing.NDArray[numpy.float64]) -> None:
        ...
    def parametric_to_pos(self, t: int, param: numpy.typing.NDArray[numpy.float64], pos: numpy.typing.NDArray[numpy.float64]) -> None:
        ...
    def pos_to_parametric(self, t: int, pos: numpy.typing.NDArray[numpy.float64], param: numpy.typing.NDArray[numpy.float64]) -> None:
        ...
class MeshTemplateCurvedEntityBase:
    """
    A generic class representing a relation for a curved boundary representation
    """
    @staticmethod
    def load_from_strings(arg0: list[str], arg1: int) -> dict[int, MeshTemplateCurvedEntityBase]:
        ...
    def get_information_string(self) -> str:
        ...
    def get_parametric_from_pos(self, arg0: int, arg1: list[float], arg2: list[float]) -> None:
        ...
    def get_pos_from_parametric(self, arg0: int, arg1: list[float], arg2: list[float]) -> None:
        ...
class MeshTemplateElementBrickC1:
    pass
class MeshTemplateElementBrickC2:
    pass
class MeshTemplateElementCollection:
    """
    A collection of bulk elements, i.e. a bulk domain of a mesh. Must be created as part of a :py:class:`~pyoomph.meshes.mesh.MeshTemplate` by :py:meth:`~pyoomph.meshes.mesh.MeshTemplate.new_domain`
    """
    def _get_reference_position_for_IC_and_DBC(self, arg0: set[int]) -> list[float]:
        ...
    def add_SV_tri_2d_C1(self, arg0: int, arg1: int, arg2: int) -> list[MeshTemplateElementTriC1]:
        ...
    def add_brick_3d_C1(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int) -> MeshTemplateElementBrickC1:
        """
        Adds a hexahedral element by eight node indices
        """
    def add_brick_3d_C2(self, arg0: list[int]) -> MeshTemplateElementBrickC2:
        """
        Adds a second-order hexahedral element by 27 node indices
        """
    def add_line_1d_C1(self, arg0: int, arg1: int) -> MeshTemplateElementLineC1:
        """
        Adds a line element by two node indices
        """
    def add_line_1d_C2(self, arg0: int, arg1: int, arg2: int) -> MeshTemplateElementLineC2:
        """
        Adds a second order line element by three node indices
        """
    def add_point_element(self, arg0: int) -> MeshTemplateElementPoint:
        """
        Adds a single point element to the domain
        """
    def add_quad_2d_C1(self, arg0: int, arg1: int, arg2: int, arg3: int) -> MeshTemplateElementQuadC1:
        """
        Adds a quadrilateral element by four node indices
        """
    def add_quad_2d_C2(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int, arg6: int, arg7: int, arg8: int) -> MeshTemplateElementQuadC2:
        """
        Adds a second-order quadrilateral element by nine node indices
        """
    def add_tetra_3d_C1(self, arg0: int, arg1: int, arg2: int, arg3: int) -> MeshTemplateElementTetraC1:
        """
        Adds a tetrahedral element by four node indices
        """
    def add_tetra_3d_C2(self, arg0: list[int]) -> MeshTemplateElementTetraC2:
        """
        Adds a second-order tetrahedral element by ten node indices
        """
    def add_tri_2d_C1(self, arg0: int, arg1: int, arg2: int) -> MeshTemplateElementTriC1:
        """
        Adds a triangular element by three node indices
        """
    def add_tri_2d_C2(self, arg0: int, arg1: int, arg2: int, arg3: int, arg4: int, arg5: int) -> MeshTemplateElementTriC2:
        """
        Adds a second-order triangular element by six node indices
        """
    def get_adjacent_boundary_names(self) -> list[str]:
        ...
    def get_element_dimension(self) -> int:
        ...
    def lagrangian_dimension(self) -> int:
        """
        Returns the dimension of the Lagrangian coordinates
        """
    def nodal_dimension(self) -> int:
        """
        Returns the dimension of the Eulerian coordinates
        """
    def set_all_nodes_as_boundary_nodes(self) -> None:
        ...
    def set_element_code(self, arg0: DynamicBulkElementInstance) -> None:
        ...
    def set_lagrangian_dimension(self, arg0: int) -> None:
        """
        Sets the dimension of the Lagrangian coordinates
        """
    def set_nodal_dimension(self, arg0: int) -> None:
        """
        Sets the dimension of the Eulerian coordinates
        """
class MeshTemplateElementLineC1:
    pass
class MeshTemplateElementLineC2:
    pass
class MeshTemplateElementPoint:
    pass
class MeshTemplateElementQuadC1:
    pass
class MeshTemplateElementQuadC2:
    pass
class MeshTemplateElementTetraC1:
    pass
class MeshTemplateElementTetraC2:
    pass
class MeshTemplateElementTriC1:
    pass
class MeshTemplateElementTriC2:
    pass
class MultiTimeStepper(TimeStepper):
    def __init__(self, arg0: bool) -> None:
        ...
    def get_num_unsteady_steps_done(self) -> int:
        ...
    def increment_num_unsteady_steps_done(self) -> None:
        ...
    def set_Newmark2_coeffs(self, arg0: float, arg1: float) -> None:
        ...
    def set_num_unsteady_steps_done(self, arg0: int) -> None:
        ...
    def weightBDF1(self, arg0: int, arg1: int) -> float:
        ...
    def weightBDF2(self, arg0: int, arg1: int) -> float:
        ...
    def weightNewmark2(self, arg0: int, arg1: int) -> float:
        ...
class Node(OomphData):
    def _make_periodic(self, arg0: Node, arg1: Mesh) -> None:
        ...
    def _nullify_residual_contribution(self, arg0: DynamicBulkElementInstance, arg1: int) -> None:
        ...
    def add_to_boundary(self, arg0: int) -> None:
        ...
    def additional_value_index(self, arg0: int) -> int:
        ...
    def get_boundary_indices(self) -> set[int]:
        ...
    def get_coordinates_on_boundary(self, arg0: int) -> list[float]:
        ...
    def is_hanging(self, index: int = -1) -> bool:
        ...
    def is_obsolete(self) -> bool:
        ...
    @typing.overload
    def is_on_boundary(self) -> bool:
        ...
    @typing.overload
    def is_on_boundary(self, arg0: int) -> bool:
        ...
    def ndim(self) -> int:
        ...
    def pin_position(self, arg0: int) -> None:
        ...
    def position_is_pinned(self, arg0: int) -> bool:
        ...
    def remove_from_boundary(self, arg0: int) -> None:
        ...
    def set_coordinates_on_boundary(self, arg0: int, arg1: list[float]) -> None:
        ...
    def set_obsolete(self) -> None:
        ...
    def set_x(self, arg0: int, arg1: float) -> None:
        ...
    def set_x_at_t(self, arg0: int, arg1: int, arg2: float) -> None:
        ...
    def set_x_lagr(self, arg0: int, arg1: float) -> None:
        ...
    def unpin_position(self, arg0: int) -> None:
        ...
    def variable_position_pt(self) -> OomphData:
        ...
    def x(self, arg0: int) -> float:
        ...
    def x_at_t(self, arg0: int, arg1: int) -> float:
        ...
    def x_lagr(self, arg0: int) -> float:
        ...
class ODEStorageMesh(Mesh, OomphMesh):
    def __init__(self) -> None:
        ...
    def _add_ODE(self, arg0: str, arg1: BulkElementODE0d) -> int:
        ...
    def _get_ODE(self, arg0: str) -> BulkElementODE0d:
        ...
    def _set_problem(self, arg0: Problem, arg1: typing.Optional[DynamicBulkElementInstance]) -> None:
        ...
class OomphData:
    def eqn_number(self, arg0: int) -> int:
        ...
    def is_pinned(self, arg0: int) -> bool:
        ...
    def ntstorage(self) -> int:
        ...
    def nvalue(self) -> int:
        ...
    def pin(self, arg0: int) -> None:
        ...
    def set_time_stepper(self, arg0: TimeStepper, arg1: bool) -> None:
        ...
    def set_value(self, arg0: int, arg1: float) -> None:
        ...
    def set_value_at_t(self, arg0: int, arg1: int, arg2: float) -> None:
        ...
    def unpin(self, arg0: int) -> None:
        ...
    def value(self, arg0: int) -> float:
        ...
    def value_at_t(self, arg0: int, arg1: int) -> float:
        ...
class OomphDomain:
    pass
class OomphGeneralisedElement:
    _elemental_error_max_override: float
    def _connect_periodic_tree(self, arg0: OomphGeneralisedElement, arg1: int, arg2: int) -> None:
        ...
    def _debug_hessian(self, arg0: list[float], arg1: list[list[float]], arg2: float) -> None:
        ...
    def assemble_hessian_and_mass_hessian(self) -> tuple[numpy.typing.NDArray[numpy.float64], numpy.typing.NDArray[numpy.float64]]:
        ...
    def boundary_node_pt(self, arg0: int, arg1: int) -> Node:
        ...
    def boundary_nodes(self, boundary_index: int = -1) -> list[Node]:
        ...
    def boundary_vertex_nodes(self, arg0: int) -> list[Node]:
        ...
    def create_interpolated_node(self, arg0: list[float], arg1: bool) -> Node:
        ...
    def describe_my_dofs(self, arg0: str) -> str:
        ...
    def dim(self) -> int:
        ...
    def eqn_number(self, arg0: int) -> int:
        ...
    def evalulate_local_expression_at_midpoint(self, arg0: int) -> float:
        ...
    def evalulate_local_expression_at_node_index(self, arg0: int, arg1: int) -> float:
        ...
    def evalulate_local_expression_at_s(self, arg0: int, arg1: list[float]) -> float:
        ...
    def external_data_pt(self, arg0: int) -> OomphData:
        ...
    def get_Eulerian_midpoint(self) -> list[float]:
        ...
    def get_Lagrangian_midpoint(self) -> list[float]:
        ...
    def get_attached_element_equation_mapping(self, arg0: str) -> list[int]:
        ...
    def get_bulk_element(self) -> OomphGeneralisedElement:
        ...
    def get_code_instance(self) -> DynamicBulkElementInstance:
        ...
    def get_current_cartesian_nondim_size(self) -> float:
        ...
    def get_debug_jacobian_info(self) -> tuple[list[float], list[float], list[str]]:
        ...
    def get_dof_names(self) -> list[str]:
        ...
    def get_father_element(self) -> OomphGeneralisedElement:
        ...
    def get_field_data_list(self, arg0: str, arg1: bool) -> list[tuple[OomphData, int]]:
        ...
    def get_initial_cartesian_nondim_size(self) -> float:
        ...
    def get_initial_quality_factor(self) -> float:
        ...
    def get_interpolated_discontinuous_at_s(self, arg0: int, arg1: list[float]) -> list[float]:
        ...
    def get_interpolated_nodal_values_at_s(self, arg0: int, arg1: list[float]) -> list[float]:
        ...
    def get_interpolated_position_at_s(self, arg0: int, arg1: list[float], arg2: bool) -> list[float]:
        ...
    def get_macro_element(self) -> MacroElement:
        ...
    def get_macro_element_coordinate_at_s(self, arg0: list[float]) -> list[float]:
        ...
    def get_meshio_type_index(self) -> int:
        ...
    def get_nodal_index_by_name(self, arg0: Node, arg1: str) -> int:
        ...
    def get_opposite_bulk_element(self) -> OomphGeneralisedElement:
        ...
    def get_opposite_interface_element(self) -> OomphGeneralisedElement:
        ...
    def get_outline(self, lagrangian: bool = False) -> numpy.typing.NDArray[numpy.float64]:
        ...
    def get_quality_factor(self) -> float:
        ...
    def internal_data_pt(self, arg0: int) -> OomphData:
        ...
    def local_coordinate_of_node(self, arg0: int) -> list[float]:
        ...
    def locate_zeta(self, arg0: list[float], arg1: list[float], arg2: bool) -> list[float]:
        ...
    def map_nodes_on_macro_element(self) -> None:
        ...
    def ndof(self) -> int:
        ...
    def nexternal_data(self) -> int:
        ...
    def ninternal_data(self) -> int:
        ...
    def nnode(self) -> int:
        ...
    def nnode_1d(self) -> int:
        ...
    def node_pt(self, arg0: int) -> Node:
        ...
    def nodes(self) -> list[Node]:
        ...
    def non_halo_proc_ID(self) -> int:
        ...
    def num_Z2_flux_terms(self) -> int:
        ...
    def nvertex_node(self) -> int:
        ...
    def opposite_node_pt(self, arg0: int) -> Node:
        ...
    def refinement_level(self) -> int:
        ...
    def set_initial_cartesian_nondim_size(self, arg0: float) -> float:
        ...
    def set_initial_quality_factor(self, arg0: float) -> float:
        ...
    def set_macro_element(self, arg0: MacroElement, arg1: bool) -> None:
        ...
    def set_opposite_interface_element(self, arg0: OomphGeneralisedElement, arg1: list[float]) -> None:
        ...
    def set_undeformed_macro_element(self, arg0: MacroElement) -> None:
        ...
    def vertex_node_pt(self, arg0: int) -> Node:
        ...
class OomphMesh:
    def _disable_adaptation(self) -> None:
        ...
    def _enable_adaptation(self) -> None:
        ...
    def _set_interpolate_lagrangian_on_remeshing(self, arg0: bool) -> None:
        ...
    def add_node_to_mesh(self, arg0: Node) -> None:
        ...
    def as_pyoomph_mesh(self) -> Mesh:
        ...
    def boundary_element_pt(self, arg0: int, arg1: int) -> OomphGeneralisedElement:
        ...
    def boundary_node_pt(self, arg0: int, arg1: int) -> Node:
        ...
    def element_pt(self, arg0: int) -> OomphGeneralisedElement:
        ...
    def face_index_at_boundary(self, arg0: int, arg1: int) -> int:
        ...
    def get_elemental_errors(self) -> list[float]:
        ...
    def nboundary(self) -> int:
        ...
    def nboundary_element(self, arg0: int) -> int:
        ...
    def nboundary_node(self, arg0: int) -> int:
        ...
    def nelement(self) -> int:
        ...
    def nnode(self) -> int:
        ...
    def node_pt(self, arg0: int) -> Node:
        ...
    def output_paraview(self, arg0: str, arg1: int) -> None:
        ...
    def prune_dead_nodes(self, arg0: bool) -> None:
        ...
    def resolve_copy_master_node(self, arg0: Node) -> Node:
        ...
class PeriodicOrbitHandler(AssemblyHandler):
    def backup_dofs(self) -> None:
        ...
    def get_T(self) -> float:
        ...
    def get_base_ndof(self) -> int:
        ...
    def get_num_time_steps(self) -> int:
        ...
    def get_s_integration_samples(self) -> list[tuple[float, float]]:
        ...
    def is_floquet_mode(self) -> bool:
        ...
    def restore_dofs(self) -> None:
        ...
    def set_dofs_to_interpolated_values(self, arg0: float) -> None:
        ...
    def update_phase_constraint_information(self) -> None:
        ...
class PitchForkHandler(AssemblyHandler):
    def set_eigenweight(self, arg0: float) -> None:
        ...
class Problem:
    DTSF_max_increase_factor: float
    DTSF_min_decrease_factor: float
    _improved_pitchfork_tracking_on_unstructured_meshes: bool
    always_take_one_newton_step: bool
    keep_temporal_error_below_tolerance: bool
    max_residuals: float
    minimum_arclength_ds: float
    newton_relaxation_factor: float
    sparse_assembly_method: str
    use_custom_residual_jacobian: bool
    def __init__(self) -> None:
        ...
    def _adapt(self) -> tuple[int, int]:
        ...
    def _add_augmented_dofs(self, arg0: DofAugmentations) -> None:
        ...
    def _arc_length_step(self, arg0: str, arg1: float, arg2: int) -> float:
        ...
    def _assemble_hessian_tensor(self, arg0: bool) -> SparseRank3Tensor:
        ...
    def _assemble_multiassembly(self, arg0: list[str], arg1: list[str], arg2: list[str], arg3: list[list[float]], arg4: list[int]) -> tuple[int, list[list[float]], list[list[int]], list[int]]:
        ...
    def _assemble_residual_jacobian(self, arg0: str) -> tuple[list[float], int, int, int, numpy.typing.NDArray[numpy.float64], numpy.typing.NDArray[numpy.int32], numpy.typing.NDArray[numpy.int32]]:
        ...
    def _create_dof_augmentation(self) -> DofAugmentations:
        ...
    def _enable_store_local_dof_pt_in_elements(self) -> None:
        ...
    def _get_bifurcation_eigenvector(self) -> list[complex]:
        ...
    def _get_bifurcation_omega(self) -> float:
        ...
    def _get_lambda_tracking_real(self) -> float:
        ...
    def _get_max_dt_order(self) -> int:
        ...
    def _get_n_unaugmented_dofs(self) -> int:
        ...
    def _open_log_file(self, fname: str, activate_logging: bool = True) -> None:
        """
        Open a log file for the problem
        """
    def _redistribute_global_to_local_double_vector(self, arg0: numpy.typing.NDArray[numpy.float64]) -> numpy.typing.NDArray[numpy.float64]:
        ...
    def _redistribute_local_to_global_double_vector(self, arg0: numpy.typing.NDArray[numpy.float64]) -> numpy.typing.NDArray[numpy.float64]:
        ...
    def _replace_RJM_by_param_deriv(self, arg0: str, arg1: bool) -> None:
        ...
    def _reset_augmented_dof_vector_to_nonaugmented(self) -> None:
        ...
    def _set_arc_length_parameter_derivative(self, arg0: float) -> None:
        ...
    def _set_arc_length_theta_sqr(self, arg0: float) -> None:
        ...
    def _set_arclength_parameter(self, arg0: str, arg1: float) -> None:
        ...
    def _set_ccompiler(self, arg0: CCompiler) -> None:
        ...
    def _set_dof_direction_arclength(self, arg0: list[float]) -> None:
        ...
    def _set_globally_convergent_newton_method(self, arg0: bool) -> None:
        ...
    def _set_lambda_tracking_real(self, arg0: float) -> None:
        ...
    def _set_solved_residual(self, name: str, raise_error: bool = True) -> bool:
        ...
    def _start_bifurcation_tracking(self, arg0: str, arg1: str, arg2: bool, arg3: list[float], arg4: list[float], arg5: float, arg6: dict[str, str]) -> None:
        ...
    def _start_orbit_tracking(self, arg0: list[list[float]], arg1: float, arg2: int, arg3: int, arg4: list[float], arg5: int) -> None:
        ...
    def _unload_all_dlls(self) -> None:
        ...
    def _update_dof_vectors_for_continuation(self, arg0: list[float], arg1: list[float]) -> None:
        ...
    def _update_param_info_for_continuation(self, arg0: float, arg1: float) -> None:
        ...
    def adapt(self) -> tuple[int, int]:
        ...
    @typing.overload
    def adaptive_unsteady_newton_solve(self, arg0: float, arg1: float) -> float:
        ...
    @typing.overload
    def adaptive_unsteady_newton_solve(self, arg0: float, arg1: float, arg2: bool) -> float:
        ...
    def add_sub_mesh(self, arg0: OomphMesh) -> int:
        ...
    def add_time_stepper_pt(self, arg0: TimeStepper) -> None:
        ...
    def after_bifurcation_tracking_step(self) -> None:
        ...
    def assemble_eigenproblem_matrices(self, arg0: float) -> tuple[int, int, int, numpy.typing.NDArray[numpy.float64], numpy.typing.NDArray[numpy.int32], numpy.typing.NDArray[numpy.int32], int, int, numpy.typing.NDArray[numpy.float64], numpy.typing.NDArray[numpy.int32], numpy.typing.NDArray[numpy.int32]]:
        ...
    def assembly_handler_pt(self) -> AssemblyHandler:
        ...
    def assign_eqn_numbers(self, arg0: bool) -> int:
        ...
    @typing.overload
    def assign_initial_values_impulsive(self, arg0: float) -> None:
        ...
    @typing.overload
    def assign_initial_values_impulsive(self) -> None:
        ...
    def build_global_mesh(self) -> None:
        ...
    def distribute(self) -> None:
        ...
    def doubly_adaptive_unsteady_newton_solve(self, arg0: float, arg1: float, arg2: int, arg3: int, arg4: bool, arg5: bool) -> float:
        ...
    def enable_store_local_dof_pt_in_elements(self) -> None:
        ...
    def ensure_dummy_values_to_be_dummy(self) -> None:
        ...
    def flush_sub_meshes(self) -> None:
        ...
    def generate_and_compile_bulk_element_code(self, arg0: FiniteElementCode, arg1: str, arg2: bool, arg3: bool, arg4: Mesh, arg5: bool, arg6: list[str]) -> DynamicBulkElementInstance:
        ...
    def get_arc_length_parameter_derivative(self) -> float:
        ...
    def get_arc_length_theta_sqr(self) -> float:
        ...
    def get_arclength_dof_current_vector(self) -> list[float]:
        ...
    def get_arclength_dof_derivative_vector(self) -> list[float]:
        ...
    def get_bifurcation_tracking_mode(self) -> str:
        ...
    def get_ccompiler(self) -> CCompiler:
        ...
    def get_current_dofs(self) -> tuple[numpy.typing.NDArray[numpy.float64], list[bool]]:
        ...
    def get_current_pinned_values(self, arg0: bool) -> list[float]:
        ...
    def get_custom_residuals_jacobian(self, info: CustomResJacInfo) -> None:
        ...
    def get_global_parameter(self, parameter_name: str) -> GiNaC_GlobalParam:
        """
        Return a global parameter. If it does not exist, it will be added and initialized with value 0.
        """
    def get_global_parameter_names(self) -> set[str]:
        ...
    def get_history_dofs(self, arg0: int) -> numpy.typing.NDArray[numpy.float64]:
        ...
    def get_last_jacobian_setup_time(self) -> float:
        ...
    def get_last_linear_solver_solution_time(self) -> float:
        ...
    def get_last_residual_convergence(self) -> list[float]:
        ...
    def get_parameter_derivative(self, arg0: str) -> list[float]:
        ...
    def get_residuals(self) -> list[float]:
        ...
    def get_second_order_directional_derivative(self, arg0: list[float]) -> list[float]:
        ...
    def initialise_dt(self, arg0: float) -> None:
        ...
    def is_distributed(self) -> bool:
        ...
    def is_quiet(self) -> bool:
        ...
    @typing.overload
    def mesh_pt(self) -> OomphMesh:
        ...
    @typing.overload
    def mesh_pt(self, arg0: int) -> OomphMesh:
        ...
    def ndof(self) -> int:
        """
        Returns the number of equations, i.e. degrees of freedom
        """
    def newton_solve(self, max_adapt: int = 0) -> None:
        """
        Perform a newton solve
        """
    def nsub_mesh(self) -> int:
        ...
    def ntime_stepper(self) -> int:
        ...
    def quiet(self, quiet: bool = True) -> None:
        """
        Deactivate output messages from the oomph-lib and pyoomph C++ core
        """
    def rebuild_global_mesh(self) -> None:
        ...
    def refine_uniformly(self) -> None:
        ...
    def reset_arc_length_parameters(self) -> None:
        ...
    def set_FD_step_used_in_get_hessian_vector_products(self, arg0: float) -> None:
        ...
    def set_analytic_hessian_products(self, active: bool, use_symmetry: bool = False) -> None:
        ...
    def set_current_dofs(self, arg0: list[float]) -> None:
        ...
    def set_current_pinned_values(self, inp: list[float], with_pos: bool, t: int = 0) -> None:
        ...
    def set_history_dofs(self, arg0: int, arg1: list[float]) -> None:
        ...
    def set_initial_condition(self) -> None:
        ...
    def set_mesh_pt(self, arg0: Mesh) -> None:
        ...
    def setup_pinning(self) -> None:
        ...
    def shift_time_values(self) -> None:
        ...
    def steady_newton_solve(self, max_adapt: int = 0) -> None:
        """
        Perform a steady newton solve
        """
    def time_pt(self) -> Time:
        ...
    def time_stepper_pt(self, i: int = 0) -> TimeStepper:
        ...
    def unrefine_uniformly(self) -> int:
        ...
    @typing.overload
    def unsteady_newton_solve(self, arg0: float, arg1: bool) -> None:
        ...
    @typing.overload
    def unsteady_newton_solve(self, arg0: float, arg1: int, arg2: bool, arg3: bool) -> None:
        ...
    @property
    def max_newton_iterations(self) -> int:
        """
        Maximum number of Newton iterations for solving before giving up.
        """
    @max_newton_iterations.setter
    def max_newton_iterations(self, arg1: int) -> None:
        ...
    @property
    def newton_solver_tolerance(self) -> float:
        """
        Maximum value in the residual vector to consider the solution as converged during Newton method
        """
    @newton_solver_tolerance.setter
    def newton_solver_tolerance(self, arg1: float) -> None:
        ...
class QMacroElement2(MacroElement):
    def __init__(self, arg0: OomphDomain, arg1: int) -> None:
        ...
class SharedLibCCompiler(CCompiler):
    def __init__(self) -> None:
        ...
    def compile(self, suppress_compilation: bool, suppress_code_writing: bool, quiet: bool, extra_flags: list[str]) -> bool:
        ...
    def expand_full_library_name(self, arg0: str) -> str:
        ...
    def get_jit_include_dir(self) -> str:
        ...
    def get_shared_lib_extension(self) -> str:
        ...
    def sanity_check(self) -> bool:
        ...
class SparseRank3Tensor:
    def finalize_for_vector_product(self) -> tuple[numpy.typing.NDArray[numpy.int32], numpy.typing.NDArray[numpy.int32]]:
        ...
    def get_entries(self) -> list[tuple[int, int, int, float]]:
        ...
    def right_vector_mult(self, arg0: numpy.typing.NDArray[numpy.float64]) -> numpy.typing.NDArray[numpy.float64]:
        ...
class TemplatedMeshBase1d(Mesh, OomphMesh):
    def __init__(self) -> None:
        ...
    def _get_problem(self) -> Problem:
        ...
    def _set_problem(self, arg0: Problem, arg1: typing.Optional[DynamicBulkElementInstance]) -> None:
        ...
    def generate_from_template(self, arg0: MeshTemplateElementCollection) -> None:
        ...
    def refine_selected_elements(self, arg0: list[int]) -> None:
        ...
    def refine_uniformly(self, num: int = 1) -> None:
        ...
    def refinement_possible(self) -> bool:
        ...
    def setup_boundary_element_info(self) -> None:
        ...
    def setup_tree_forest(self) -> None:
        ...
class TemplatedMeshBase2d(Mesh, OomphMesh):
    def __init__(self) -> None:
        ...
    def _get_problem(self) -> Problem:
        ...
    def _set_problem(self, arg0: Problem, arg1: typing.Optional[DynamicBulkElementInstance]) -> None:
        ...
    def add_tri_C1(self, arg0: Node, arg1: Node, arg2: Node) -> None:
        ...
    def add_tri_C1TB(self, arg0: Node, arg1: Node, arg2: Node, arg3: Node) -> None:
        ...
    def generate_from_template(self, arg0: MeshTemplateElementCollection) -> None:
        ...
    def refine_selected_elements(self, arg0: list[int]) -> None:
        ...
    def refine_uniformly(self, num: int = 1) -> None:
        ...
    def refinement_possible(self) -> bool:
        ...
    def set_max_neighbour_finding_tolerance(self, arg0: float) -> None:
        ...
    def setup_boundary_element_info(self) -> None:
        ...
    def setup_tree_forest(self) -> None:
        ...
class TemplatedMeshBase3d(Mesh, OomphMesh):
    def __init__(self) -> None:
        ...
    def _get_problem(self) -> Problem:
        ...
    def _set_problem(self, arg0: Problem, arg1: typing.Optional[DynamicBulkElementInstance]) -> None:
        ...
    def generate_from_template(self, arg0: MeshTemplateElementCollection) -> None:
        ...
    def refine_selected_elements(self, arg0: list[int]) -> None:
        ...
    def refine_uniformly(self, num: int = 1) -> None:
        ...
    def refinement_possible(self) -> bool:
        ...
    def setup_boundary_element_info(self) -> None:
        ...
    def setup_tree_forest(self) -> None:
        ...
class Time:
    def dt(self, arg0: int) -> float:
        ...
    def ndt(self) -> int:
        ...
    def set_dt(self, arg0: int, arg1: float) -> None:
        ...
    def set_time(self, arg0: float) -> None:
        ...
    @typing.overload
    def time(self, arg0: int) -> float:
        ...
    @typing.overload
    def time(self) -> float:
        ...
class TimeStepper:
    def is_steady(self) -> bool:
        ...
    def make_steady(self) -> None:
        ...
    def nprev_values(self) -> int:
        ...
    def ntstorage(self) -> int:
        ...
    def set_weights(self) -> None:
        ...
    def time_pt(self) -> Time:
        ...
    def undo_make_steady(self) -> None:
        ...
class TracerCollection:
    def __init__(self, arg0: str) -> None:
        ...
    def _advect_all(self) -> None:
        ...
    def _load_state(self, arg0: list[float], arg1: list[int]) -> None:
        ...
    def _locate_elements(self) -> None:
        ...
    def _prepare_advection(self) -> None:
        ...
    def _save_state(self) -> tuple[list[float], list[int]]:
        ...
    def _set_mesh(self, arg0: Mesh) -> None:
        ...
    def _set_transfer_interface(self, arg0: int, arg1: TracerCollection) -> None:
        ...
    def add_tracer(self, position: list[float], tag: int = 0) -> None:
        ...
    def get_positions(self) -> numpy.typing.NDArray[numpy.float64]:
        ...
class VectorDouble:
    def __getitem__(self, arg0: int) -> float:
        ...
    def __setitem__(self, arg0: int, arg1: float) -> None:
        ...
    def size(self) -> int:
        ...
class Z2ErrorEstimator:
    use_Lagrangian: bool
    def __init__(self) -> None:
        ...
def FinaliseMPI() -> None:
    ...
def GiNaC_Diff(arg0: Expression, arg1: Expression) -> Expression:
    """
    Derivative, but does not evaluate until code generation
    """
def GiNaC_EvalFlag(arg0: str) -> Expression:
    """
    Evaluate a flag at runtime (e.g. moving_mesh->0,1) or similar to activate or deactivate terms based on this
    """
def GiNaC_FakeExponentialMode(mode: Expression, dual: bool = False) -> Expression:
    ...
def GiNaC_Matrix(arg0: int, arg1: list[Expression]) -> Expression:
    ...
def GiNaC_SymSubs(arg0: Expression, arg1: Expression, arg2: Expression) -> Expression:
    """
    Call GiNaC::subs, but does not evaluate until code generation
    """
def GiNaC_TimeSymbol() -> Expression:
    ...
def GiNaC_UnitVect(arg0: int, arg1: int, arg2: int, arg3: Expression) -> Expression:
    ...
def GiNaC_Vect(arg0: list[Expression]) -> Expression:
    ...
def GiNaC_absolute(arg0: Expression) -> Expression:
    """
    Calculates the absolute value. Note: It will differentiate as absolute(f(x))'=signum(f(x))*f'(x)
    """
def GiNaC_acos(arg0: Expression) -> Expression:
    """
    Calculates acos
    """
@typing.overload
def GiNaC_asin(arg0: Expression) -> Expression:
    """
    Calculates asin
    """
@typing.overload
def GiNaC_asin(arg0: float) -> Expression:
    """
    Calculates asin
    """
def GiNaC_atan(arg0: Expression) -> Expression:
    """
    Calculates atan
    """
def GiNaC_atan2(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates atan2
    """
def GiNaC_collect(arg0: Expression, arg1: Expression) -> Expression:
    ...
def GiNaC_collect_common_factors(arg0: Expression) -> Expression:
    ...
def GiNaC_collect_units(arg0: Expression) -> tuple[Expression, Expression, Expression, bool]:
    """
    Splits an expression into a numerical factor, units, and the rest
    """
def GiNaC_contract(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates the dot for vectors and double dot for matrices
    """
def GiNaC_cos(arg0: Expression) -> Expression:
    """
    Calculates the cosine
    """
def GiNaC_cosh(arg0: Expression) -> Expression:
    """
    Calculates the sine hyperbolicus
    """
def GiNaC_debug_ex(arg0: Expression) -> Expression:
    ...
def GiNaC_delayed_expansion(arg0: typing.Callable[[], Expression]) -> Expression:
    ...
def GiNaC_determinant(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates the determinant of an n x n matrix
    """
def GiNaC_diff(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates the derivative
    """
def GiNaC_dimtestfunction(arg0: str, arg1: FiniteElementCode, arg2: list[str]) -> Expression:
    """
    Symbol which is expanded to the test function of the passed field.
    """
def GiNaC_dimtestfunction_from_var(arg0: Expression) -> Expression:
    """
    Symbol which is expanded to the test function of the passed field.
    """
def GiNaC_directional_derivative(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression, arg5: Expression) -> Expression:
    """
    Calculates the directional derivative of a scalar, matrix or tensor
    """
def GiNaC_div(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression) -> Expression:
    """
    Calculates the divergence
    """
def GiNaC_dot(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates the dot product
    """
def GiNaC_double_dot(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates the double dot product A:B
    """
def GiNaC_eval_at_expansion_mode(arg0: Expression, arg1: Expression) -> Expression:
    """
    Set the mode index (base or azimuthal mode) for  vars and nondims
    """
def GiNaC_eval_in_domain(arg0: Expression, arg1: FiniteElementCode, arg2: list[str]) -> Expression:
    """
    Expand vars and nondims in a particular domain
    """
def GiNaC_eval_in_past(arg0: Expression, arg1: Expression, arg2: Expression) -> Expression:
    """
    Expand vars and nondims in a particular domain
    """
def GiNaC_exp(arg0: Expression) -> Expression:
    """
    Calculates exp
    """
def GiNaC_expand(arg0: Expression) -> Expression:
    """
    Expand expression after internal expansion of all fields with GiNaC::expand
    """
def GiNaC_factor(arg0: Expression) -> Expression:
    ...
def GiNaC_field(arg0: str, arg1: FiniteElementCode, arg2: list[str]) -> Expression:
    """
    Create a placeholder for a field, used for e.g. properties. Considers scaling
    """
def GiNaC_general_weak_differential_contribution(arg0: str, arg1: list[Expression], arg2: Expression, arg3: Expression, arg4: Expression, arg5: Expression, arg6: Expression) -> Expression:
    """
    Any differential weak contribution that depends on the coordinate system
    """
def GiNaC_get_global_symbol(arg0: str) -> Expression:
    """
    Get the time 't', or coordinates 'x','y','z'
    """
def GiNaC_get_imag_part(arg0: Expression) -> Expression:
    ...
def GiNaC_get_real_part(arg0: Expression) -> Expression:
    ...
def GiNaC_grad(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression, arg4: Expression) -> Expression:
    """
    Calculates the gradient
    """
def GiNaC_heaviside(arg0: Expression) -> Expression:
    """
    Calculates the step function
    """
def GiNaC_imaginary_i() -> Expression:
    ...
def GiNaC_internal_function_with_element_arg(arg0: str, arg1: list[Expression]) -> Expression:
    """
    Internal functions, used e.g. for elemental functions like element_size etc
    """
def GiNaC_inverse_matrix(arg0: Expression, arg1: Expression, arg2: Expression) -> Expression:
    """
    Calculates the inverse of an n x n matrix
    """
def GiNaC_is_a_matrix(arg0: Expression) -> bool:
    ...
def GiNaC_log(arg0: Expression) -> Expression:
    """
    Calculates natural log
    """
def GiNaC_matproduct(arg0: Expression, arg1: Expression) -> Expression:
    ...
def GiNaC_maximum(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates the maximum
    """
def GiNaC_minimize_functional_derivative(arg0: Expression, arg1: list[Expression], arg2: Expression, arg3: Expression) -> Expression:
    """
    Calculates weak formulation of the variation of the functional with integrant F
    """
def GiNaC_minimum(arg0: Expression, arg1: Expression) -> Expression:
    """
    Calculates the minimum
    """
def GiNaC_new_symbol(arg0: str) -> Expression:
    ...
def GiNaC_nondimfield(arg0: str, arg1: FiniteElementCode, arg2: list[str]) -> Expression:
    """
    Create a placeholder for a non-dimensiona field. Opposed to 'field', dimensions are not considerd
    """
def GiNaC_normal(arg0: Expression) -> Expression:
    ...
def GiNaC_piecewise_geq0(arg0: Expression, arg1: Expression, arg2: Expression) -> Expression:
    """
    Returns a if cond>=0, else b
    """
def GiNaC_python_cb_function(arg0: CustomMathExpression, arg1: list[Expression]) -> Expression:
    ...
def GiNaC_python_multi_cb_function(arg0: CustomMultiReturnExpressionBase, arg1: list[Expression], arg2: int) -> Expression:
    ...
def GiNaC_python_multi_cb_indexed_result(arg0: Expression, arg1: int) -> Expression:
    ...
def GiNaC_rational_number(arg0: int, arg1: int) -> Expression:
    """
    Rational number
    """
def GiNaC_remove_mode_from_jacobian_or_hessian(arg0: Expression, arg1: Expression, arg2: Expression) -> Expression:
    ...
def GiNaC_scale(arg0: str, arg1: FiniteElementCode, arg2: list[str]) -> Expression:
    """
    Expands to the scale of this field
    """
def GiNaC_sep_base_units(arg0: Expression) -> dict[str, tuple[int, int]]:
    ...
def GiNaC_series(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> Expression:
    ...
def GiNaC_signum(arg0: Expression) -> Expression:
    """
    Calculates the signum of the argument. Note: It will differentiate to 0, even at x=0
    """
def GiNaC_sin(arg0: Expression) -> Expression:
    """
    Calculates the sine
    """
def GiNaC_sinh(arg0: Expression) -> Expression:
    """
    Calculates the sine hyperbolicus
    """
def GiNaC_split_subexpressions_in_real_and_imaginary_parts(arg0: Expression) -> Expression:
    ...
def GiNaC_subexpression(arg0: Expression) -> Expression:
    """
    Creates a subexpression
    """
def GiNaC_subs(arg0: Expression, arg1: Expression, arg2: Expression) -> Expression:
    """
    Call GiNaC::subs, evaluate directly
    """
def GiNaC_subsfields(arg0: Expression, arg1: dict[str, Expression], arg2: dict[str, Expression], arg3: dict[str, Expression]) -> Expression:
    ...
def GiNaC_tan(arg0: Expression) -> Expression:
    """
    Calculates tan
    """
def GiNaC_tanh(arg0: Expression) -> Expression:
    """
    Calculates tanh
    """
def GiNaC_testfunction(arg0: str, arg1: FiniteElementCode, arg2: list[str]) -> Expression:
    """
    Symbol which is expanded to the test function of the passed field.
    """
def GiNaC_testfunction_from_var(arg0: Expression, arg1: bool) -> Expression:
    """
    Symbol which is expanded to the test function of the passed field.
    """
def GiNaC_testscale(arg0: str, arg1: FiniteElementCode, arg2: list[str]) -> Expression:
    """
    Expands to the scale of the test function
    """
def GiNaC_time_stepper_weight(arg0: int, arg1: int, arg2: str) -> Expression:
    ...
def GiNaC_trace(arg0: Expression) -> Expression:
    """
    Calculates the trace of a matrix
    """
def GiNaC_transpose(arg0: Expression) -> Expression:
    """
    Calculates the transposed matrix
    """
def GiNaC_unit(arg0: str, arg1: str) -> Expression:
    ...
def GiNaC_unit_matrix(arg0: int) -> Expression:
    """
    Creates the identity matrix
    """
def GiNaC_vector_dim() -> int:
    ...
def GiNaC_weak(arg0: Expression, arg1: Expression, arg2: Expression, arg3: Expression) -> Expression:
    """
    (a,b) for weak forms, i.e. integral a*b*dx with flags&1 means lagrangian, flags&2 means dimensional
    """
def GiNaC_wrap_coordinate_system(arg0: CustomCoordinateSystem) -> Expression:
    ...
def InitMPI(arg0: list[str]) -> None:
    ...
def _currently_generated_element() -> FiniteElementCode:
    ...
def _get_core_information() -> dict[str, str]:
    ...
def _write_to_log_file(arg0: str) -> None:
    ...
def csr_rows_to_coo_rows(arg0: numpy.typing.NDArray[numpy.int32], arg1: int, arg2: int) -> numpy.typing.NDArray[numpy.int32]:
    ...
def feenableexcept() -> None:
    ...
def get_Solver_callback() -> GeneralSolverCallback:
    ...
def get_verbosity_flag() -> int:
    ...
def has_tcc() -> bool:
    ...
def set_Solver_callback(arg0: GeneralSolverCallback) -> None:
    ...
def set_interpolate_new_interface_dofs(arg0: bool) -> None:
    ...
def set_jit_include_dir(arg0: str) -> str:
    ...
def set_tolerance_for_singular_jacobian(arg0: float) -> None:
    ...
def set_use_eigen_Z2_error_estimators(arg0: bool) -> None:
    ...
def set_verbosity_flag(arg0: int) -> None:
    ...
