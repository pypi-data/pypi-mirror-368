"""implementation of the function mc_compute_fp from metacell R package, inorder to get the same models files."""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/01_mclab_footprint_compute.ipynb.

# %% auto 0
__all__ = ['mc_compute_fp_py']

# %% ../nbs/01_mclab_footprint_compute.ipynb 3
from nbdev.showdoc import *
import numpy as np
import pandas as pd
import anndata as ad

# %% ../nbs/01_mclab_footprint_compute.ipynb 4
def mc_compute_fp_py(adata, min_gene_count=10, fp_reg=0.1, norm_by_mc_size=True):
    """
    Compute the log2 fold change matrix (lfp) for metacells, matching R's mc_compute_fp logic.
    Parameters:
        adata: AnnData, single-cell data with .layers['counts'] and .obs['metacell']
        min_gene_count: int, minimum total count to include gene, default is 10.
        fp_reg: float, regularization to avoid log(0), default value is 0.1 as in R's implementation.
        norm_by_mc_size: bool, normalize by mean total UMIs per metacell
    Returns:
        lfp: DataFrame, log2 fold change matrix with total_counts column, models files.
    """
    # Ensure float64 for all calculations
    adata.X = adata.X.astype('float64')
    if 'counts' in adata.layers:
        adata.layers['counts'] = adata.layers['counts'].astype('float64')
        
    gene_counts = np.asarray(adata.X.sum(axis=0)).ravel()
    gene_bool = gene_counts > min_gene_count
    gene_names = adata.var_names[gene_bool]

    # Get cell->metacell assignment
    cell_mc = adata.obs['metacell'].values
    metacell_ids = np.unique(cell_mc[cell_mc >= 0])
    n_metacells = len(metacell_ids)

    # Get counts matrix (cells x genes)
    us = adata.X if not hasattr(adata.X, "toarray") else adata.X.toarray()
    us = np.asarray(us)
    us = us[:, gene_bool]  # filter genes

    # Compute geometric mean for each gene in each metacell
    clust_geomean = np.zeros((len(gene_names), n_metacells))
    for i, mc in enumerate(metacell_ids):
        mask = (cell_mc == mc)
        vals = us[mask, :]
        if vals.shape[0] == 0:
            clust_geomean[:, i] = 0
        else:
            clust_geomean[:, i] = np.exp(np.mean(np.log1p(vals), axis=0)) - 1

    # Replace the normalization block in mc_compute_fp_py with this:
    if norm_by_mc_size:
        mc_meansize = []
        for mc in metacell_ids:
            mask = (cell_mc == mc)
            # mean total UMIs per cell in this metacell
            mc_meansize.append(us[mask, :].sum() / mask.sum())
        mc_meansize = np.array(mc_meansize)
        ideal_cell_size = min(1000, np.median(mc_meansize))
        clust_geomean = clust_geomean * ideal_cell_size / mc_meansize

    # Regularize and normalize by gene median
    g_fp = (fp_reg + clust_geomean) / np.median(fp_reg + clust_geomean, axis=1, keepdims=True)

    # Log2 fold change
    lfp = np.log2(g_fp)
    lfp_df = pd.DataFrame(lfp, index=gene_names, columns=[str(mc) for mc in metacell_ids])
    lfp_df['total_counts'] = gene_counts[gene_bool]

    return lfp_df
