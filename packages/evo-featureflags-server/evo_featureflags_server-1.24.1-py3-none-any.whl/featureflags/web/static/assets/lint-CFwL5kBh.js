import{C as G}from"./codemirror-CDnq4I7b.js";import{K as c,r as p,s as S,u as ce,v as A,w as fe,x as V,y as w,z as y,j as _,A as T,B as Y,C as b,D as v,E as N,O as B,F as Se,H as _e,d as h,I as $,J as I,M as k,N as te,Q as de,R as C,U as we,V as Fe,W as Re,X as $e,f as Ae,Y as X,Z as Ve,_ as ke,$ as re,a0 as pe,a1 as me,a2 as ge,a3 as Ce,a4 as Le,a5 as Pe,a6 as Ue,a7 as Me,o as je}from"./index-DV-aAxIQ.js";import{R as ve,P as L}from"./Range-CZNrBk8u.js";function Ye(n){return n.kind===c.OPERATION_DEFINITION||n.kind===c.FRAGMENT_DEFINITION}function Ge(n){return n.kind===c.SCHEMA_DEFINITION||K(n)||n.kind===c.DIRECTIVE_DEFINITION}function K(n){return n.kind===c.SCALAR_TYPE_DEFINITION||n.kind===c.OBJECT_TYPE_DEFINITION||n.kind===c.INTERFACE_TYPE_DEFINITION||n.kind===c.UNION_TYPE_DEFINITION||n.kind===c.ENUM_TYPE_DEFINITION||n.kind===c.INPUT_OBJECT_TYPE_DEFINITION}function Be(n){return n.kind===c.SCHEMA_EXTENSION||Ne(n)}function Ne(n){return n.kind===c.SCALAR_TYPE_EXTENSION||n.kind===c.OBJECT_TYPE_EXTENSION||n.kind===c.INTERFACE_TYPE_EXTENSION||n.kind===c.UNION_TYPE_EXTENSION||n.kind===c.ENUM_TYPE_EXTENSION||n.kind===c.INPUT_OBJECT_TYPE_EXTENSION}function Ee(n){return{Document(t){for(const e of t.definitions)if(!Ye(e)){const r=e.kind===c.SCHEMA_DEFINITION||e.kind===c.SCHEMA_EXTENSION?"schema":'"'+e.name.value+'"';n.reportError(new p(`The ${r} definition is not executable.`,{nodes:e}))}return!1}}}function qe(n){return{Field(t){const e=n.getParentType();if(e&&!n.getFieldDef()){const s=n.getSchema(),i=t.name.value;let o=S("to use an inline fragment on",Xe(s,e,i));o===""&&(o=S(He(e,i))),n.reportError(new p(`Cannot query field "${i}" on type "${e.name}".`+o,{nodes:t}))}}}}function Xe(n,t,e){if(!ce(t))return[];const r=new Set,s=Object.create(null);for(const o of n.getPossibleTypes(t))if(o.getFields()[e]){r.add(o),s[o.name]=1;for(const a of o.getInterfaces()){var i;a.getFields()[e]&&(r.add(a),s[a.name]=((i=s[a.name])!==null&&i!==void 0?i:0)+1)}}return[...r].sort((o,a)=>{const l=s[a.name]-s[o.name];return l!==0?l:A(o)&&n.isSubType(o,a)?-1:A(a)&&n.isSubType(a,o)?1:fe(o.name,a.name)}).map(o=>o.name)}function He(n,t){if(V(n)||A(n)){const e=Object.keys(n.getFields());return w(t,e)}return[]}function Qe(n){return{InlineFragment(t){const e=t.typeCondition;if(e){const r=y(n.getSchema(),e);if(r&&!_(r)){const s=T(e);n.reportError(new p(`Fragment cannot condition on non composite type "${s}".`,{nodes:e}))}}},FragmentDefinition(t){const e=y(n.getSchema(),t.typeCondition);if(e&&!_(e)){const r=T(t.typeCondition);n.reportError(new p(`Fragment "${t.name.value}" cannot condition on non composite type "${r}".`,{nodes:t.typeCondition}))}}}}function Je(n){return{...We(n),Argument(t){const e=n.getArgument(),r=n.getFieldDef(),s=n.getParentType();if(!e&&r&&s){const i=t.name.value,o=r.args.map(l=>l.name),a=w(i,o);n.reportError(new p(`Unknown argument "${i}" on field "${s.name}.${r.name}".`+S(a),{nodes:t}))}}}}function We(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():Y;for(const o of r)t[o.name]=o.args.map(a=>a.name);const s=n.getDocument().definitions;for(const o of s)if(o.kind===c.DIRECTIVE_DEFINITION){var i;const a=(i=o.arguments)!==null&&i!==void 0?i:[];t[o.name.value]=a.map(l=>l.name.value)}return{Directive(o){const a=o.name.value,l=t[a];if(o.arguments&&l)for(const u of o.arguments){const f=u.name.value;if(!l.includes(f)){const d=w(f,l);n.reportError(new p(`Unknown argument "${f}" on directive "@${a}".`+S(d),{nodes:u}))}}return!1}}}function Ke(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():Y;for(const i of r)t[i.name]=i.locations;const s=n.getDocument().definitions;for(const i of s)i.kind===c.DIRECTIVE_DEFINITION&&(t[i.name.value]=i.locations.map(o=>o.value));return{Directive(i,o,a,l,u){const f=i.name.value,d=t[f];if(!d){n.reportError(new p(`Unknown directive "@${f}".`,{nodes:i}));return}const m=ze(u);m&&!d.includes(m)&&n.reportError(new p(`Directive "@${f}" may not be used on ${m}.`,{nodes:i}))}}}function ze(n){const t=n[n.length-1];switch("kind"in t||b(!1),t.kind){case c.OPERATION_DEFINITION:return Ze(t.operation);case c.FIELD:return N.FIELD;case c.FRAGMENT_SPREAD:return N.FRAGMENT_SPREAD;case c.INLINE_FRAGMENT:return N.INLINE_FRAGMENT;case c.FRAGMENT_DEFINITION:return N.FRAGMENT_DEFINITION;case c.VARIABLE_DEFINITION:return N.VARIABLE_DEFINITION;case c.SCHEMA_DEFINITION:case c.SCHEMA_EXTENSION:return N.SCHEMA;case c.SCALAR_TYPE_DEFINITION:case c.SCALAR_TYPE_EXTENSION:return N.SCALAR;case c.OBJECT_TYPE_DEFINITION:case c.OBJECT_TYPE_EXTENSION:return N.OBJECT;case c.FIELD_DEFINITION:return N.FIELD_DEFINITION;case c.INTERFACE_TYPE_DEFINITION:case c.INTERFACE_TYPE_EXTENSION:return N.INTERFACE;case c.UNION_TYPE_DEFINITION:case c.UNION_TYPE_EXTENSION:return N.UNION;case c.ENUM_TYPE_DEFINITION:case c.ENUM_TYPE_EXTENSION:return N.ENUM;case c.ENUM_VALUE_DEFINITION:return N.ENUM_VALUE;case c.INPUT_OBJECT_TYPE_DEFINITION:case c.INPUT_OBJECT_TYPE_EXTENSION:return N.INPUT_OBJECT;case c.INPUT_VALUE_DEFINITION:{const e=n[n.length-3];return"kind"in e||b(!1),e.kind===c.INPUT_OBJECT_TYPE_DEFINITION?N.INPUT_FIELD_DEFINITION:N.ARGUMENT_DEFINITION}default:b(!1,"Unexpected kind: "+v(t.kind))}}function Ze(n){switch(n){case B.QUERY:return N.QUERY;case B.MUTATION:return N.MUTATION;case B.SUBSCRIPTION:return N.SUBSCRIPTION}}function xe(n){return{FragmentSpread(t){const e=t.name.value;n.getFragment(e)||n.reportError(new p(`Unknown fragment "${e}".`,{nodes:t.name}))}}}function en(n){const t=n.getSchema(),e=t?t.getTypeMap():Object.create(null),r=Object.create(null);for(const i of n.getDocument().definitions)K(i)&&(r[i.name.value]=!0);const s=[...Object.keys(e),...Object.keys(r)];return{NamedType(i,o,a,l,u){const f=i.name.value;if(!e[f]&&!r[f]){var d;const m=(d=u[2])!==null&&d!==void 0?d:a,g=m!=null&&nn(m);if(g&&ie.includes(f))return;const E=w(f,g?ie.concat(s):s);n.reportError(new p(`Unknown type "${f}".`+S(E),{nodes:i}))}}}}const ie=[...Se,..._e].map(n=>n.name);function nn(n){return"kind"in n&&(Ge(n)||Be(n))}function tn(n){let t=0;return{Document(e){t=e.definitions.filter(r=>r.kind===c.OPERATION_DEFINITION).length},OperationDefinition(e){!e.name&&t>1&&n.reportError(new p("This anonymous operation must be the only defined operation.",{nodes:e}))}}}const rn=3;function sn(n){function t(e,r=Object.create(null),s=0){if(e.kind===c.FRAGMENT_SPREAD){const i=e.name.value;if(r[i]===!0)return!1;const o=n.getFragment(i);if(!o)return!1;try{return r[i]=!0,t(o,r,s)}finally{r[i]=void 0}}if(e.kind===c.FIELD&&(e.name.value==="fields"||e.name.value==="interfaces"||e.name.value==="possibleTypes"||e.name.value==="inputFields")&&(s++,s>=rn))return!0;if("selectionSet"in e&&e.selectionSet){for(const i of e.selectionSet.selections)if(t(i,r,s))return!0}return!1}return{Field(e){if((e.name.value==="__schema"||e.name.value==="__type")&&t(e))return n.reportError(new p("Maximum introspection depth exceeded",{nodes:[e]})),!1}}}function an(n){const t=Object.create(null),e=[],r=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(i){return s(i),!1}};function s(i){if(t[i.name.value])return;const o=i.name.value;t[o]=!0;const a=n.getFragmentSpreads(i.selectionSet);if(a.length!==0){r[o]=e.length;for(const l of a){const u=l.name.value,f=r[u];if(e.push(l),f===void 0){const d=n.getFragment(u);d&&s(d)}else{const d=e.slice(f),m=d.slice(0,-1).map(g=>'"'+g.name.value+'"').join(", ");n.reportError(new p(`Cannot spread fragment "${u}" within itself`+(m!==""?` via ${m}.`:"."),{nodes:d}))}e.pop()}r[o]=void 0}}}function on(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s}of r){const i=s.name.value;t[i]!==!0&&n.reportError(new p(e.name?`Variable "$${i}" is not defined by operation "${e.name.value}".`:`Variable "$${i}" is not defined.`,{nodes:[s,e]}))}}},VariableDefinition(e){t[e.variable.name.value]=!0}}}function Te(n){const t=[],e=[];return{OperationDefinition(r){return t.push(r),!1},FragmentDefinition(r){return e.push(r),!1},Document:{leave(){const r=Object.create(null);for(const s of t)for(const i of n.getRecursivelyReferencedFragments(s))r[i.name.value]=!0;for(const s of e){const i=s.name.value;r[i]!==!0&&n.reportError(new p(`Fragment "${i}" is never used.`,{nodes:s}))}}}}}function ln(n){let t=[];return{OperationDefinition:{enter(){t=[]},leave(e){const r=Object.create(null),s=n.getRecursiveVariableUsages(e);for(const{node:i}of s)r[i.name.value]=!0;for(const i of t){const o=i.variable.name.value;r[o]!==!0&&n.reportError(new p(e.name?`Variable "$${o}" is never used in operation "${e.name.value}".`:`Variable "$${o}" is never used.`,{nodes:i}))}}},VariableDefinition(e){t.push(e)}}}function z(n){switch(n.kind){case c.OBJECT:return{...n,fields:un(n.fields)};case c.LIST:return{...n,values:n.values.map(z)};case c.INT:case c.FLOAT:case c.STRING:case c.BOOLEAN:case c.NULL:case c.ENUM:case c.VARIABLE:return n}}function un(n){return n.map(t=>({...t,value:z(t.value)})).sort((t,e)=>fe(t.name.value,e.name.value))}function Ie(n){return Array.isArray(n)?n.map(([t,e])=>`subfields "${t}" conflict because `+Ie(e)).join(" and "):n}function cn(n){const t=new vn,e=new Map;return{SelectionSet(r){const s=fn(n,e,t,n.getParentType(),r);for(const[[i,o],a,l]of s){const u=Ie(o);n.reportError(new p(`Fields "${i}" conflict because ${u}. Use different aliases on the fields to fetch both if this was intentional.`,{nodes:a.concat(l)}))}}}}function fn(n,t,e,r,s){const i=[],[o,a]=M(n,t,r,s);if(pn(n,i,t,e,o),a.length!==0)for(let l=0;l<a.length;l++){P(n,i,t,e,!1,o,a[l]);for(let u=l+1;u<a.length;u++)U(n,i,t,e,!1,a[l],a[u])}return i}function P(n,t,e,r,s,i,o){const a=n.getFragment(o);if(!a)return;const[l,u]=Q(n,e,a);if(i!==l){Z(n,t,e,r,s,i,l);for(const f of u)r.has(f,o,s)||(r.add(f,o,s),P(n,t,e,r,s,i,f))}}function U(n,t,e,r,s,i,o){if(i===o||r.has(i,o,s))return;r.add(i,o,s);const a=n.getFragment(i),l=n.getFragment(o);if(!a||!l)return;const[u,f]=Q(n,e,a),[d,m]=Q(n,e,l);Z(n,t,e,r,s,u,d);for(const g of m)U(n,t,e,r,s,i,g);for(const g of f)U(n,t,e,r,s,g,o)}function dn(n,t,e,r,s,i,o,a){const l=[],[u,f]=M(n,t,s,i),[d,m]=M(n,t,o,a);Z(n,l,t,e,r,u,d);for(const g of m)P(n,l,t,e,r,u,g);for(const g of f)P(n,l,t,e,r,d,g);for(const g of f)for(const E of m)U(n,l,t,e,r,g,E);return l}function pn(n,t,e,r,s){for(const[i,o]of Object.entries(s))if(o.length>1)for(let a=0;a<o.length;a++)for(let l=a+1;l<o.length;l++){const u=ye(n,e,r,!1,i,o[a],o[l]);u&&t.push(u)}}function Z(n,t,e,r,s,i,o){for(const[a,l]of Object.entries(i)){const u=o[a];if(u)for(const f of l)for(const d of u){const m=ye(n,e,r,s,a,f,d);m&&t.push(m)}}}function ye(n,t,e,r,s,i,o){const[a,l,u]=i,[f,d,m]=o,g=r||a!==f&&V(a)&&V(f);if(!g){const F=l.name.value,ne=d.name.value;if(F!==ne)return[[s,`"${F}" and "${ne}" are different fields`],[l],[d]];if(!mn(l,d))return[[s,"they have differing arguments"],[l],[d]]}const E=u==null?void 0:u.type,O=m==null?void 0:m.type;if(E&&O&&H(E,O))return[[s,`they return conflicting types "${v(E)}" and "${v(O)}"`],[l],[d]];const x=l.selectionSet,ee=d.selectionSet;if(x&&ee){const F=dn(n,t,e,g,h(E),x,h(O),ee);return gn(F,s,l,d)}}function mn(n,t){const e=n.arguments,r=t.arguments;if(e===void 0||e.length===0)return r===void 0||r.length===0;if(r===void 0||r.length===0||e.length!==r.length)return!1;const s=new Map(r.map(({name:i,value:o})=>[i.value,o]));return e.every(i=>{const o=i.value,a=s.get(i.name.value);return a===void 0?!1:se(o)===se(a)})}function se(n){return T(z(n))}function H(n,t){return $(n)?$(t)?H(n.ofType,t.ofType):!0:$(t)?!0:I(n)?I(t)?H(n.ofType,t.ofType):!0:I(t)?!0:k(n)||k(t)?n!==t:!1}function M(n,t,e,r){const s=t.get(r);if(s)return s;const i=Object.create(null),o=Object.create(null);he(n,e,r,i,o);const a=[i,Object.keys(o)];return t.set(r,a),a}function Q(n,t,e){const r=t.get(e.selectionSet);if(r)return r;const s=y(n.getSchema(),e.typeCondition);return M(n,t,s,e.selectionSet)}function he(n,t,e,r,s){for(const i of e.selections)switch(i.kind){case c.FIELD:{const o=i.name.value;let a;(V(t)||A(t))&&(a=t.getFields()[o]);const l=i.alias?i.alias.value:o;r[l]||(r[l]=[]),r[l].push([t,i,a]);break}case c.FRAGMENT_SPREAD:s[i.name.value]=!0;break;case c.INLINE_FRAGMENT:{const o=i.typeCondition,a=o?y(n.getSchema(),o):t;he(n,a,i.selectionSet,r,s);break}}}function gn(n,t,e,r){if(n.length>0)return[[t,n.map(([s])=>s)],[e,...n.map(([,s])=>s).flat()],[r,...n.map(([,,s])=>s).flat()]]}class vn{constructor(){this._data=new Map}has(t,e,r){var s;const[i,o]=t<e?[t,e]:[e,t],a=(s=this._data.get(i))===null||s===void 0?void 0:s.get(o);return a===void 0?!1:r?!0:r===a}add(t,e,r){const[s,i]=t<e?[t,e]:[e,t],o=this._data.get(s);o===void 0?this._data.set(s,new Map([[i,r]])):o.set(i,r)}}function Nn(n){return{InlineFragment(t){const e=n.getType(),r=n.getParentType();if(_(e)&&_(r)&&!te(n.getSchema(),e,r)){const s=v(r),i=v(e);n.reportError(new p(`Fragment cannot be spread here as objects of type "${s}" can never be of type "${i}".`,{nodes:t}))}},FragmentSpread(t){const e=t.name.value,r=En(n,e),s=n.getParentType();if(r&&s&&!te(n.getSchema(),r,s)){const i=v(s),o=v(r);n.reportError(new p(`Fragment "${e}" cannot be spread here as objects of type "${i}" can never be of type "${o}".`,{nodes:t}))}}}}function En(n,t){const e=n.getFragment(t);if(e){const r=y(n.getSchema(),e.typeCondition);if(_(r))return r}}function Tn(n){return{...In(n),Field:{leave(t){var e;const r=n.getFieldDef();if(!r)return!1;const s=new Set((e=t.arguments)===null||e===void 0?void 0:e.map(i=>i.name.value));for(const i of r.args)if(!s.has(i.name)&&de(i)){const o=v(i.type);n.reportError(new p(`Field "${r.name}" argument "${i.name}" of type "${o}" is required, but it was not provided.`,{nodes:t}))}}}}}function In(n){var t;const e=Object.create(null),r=n.getSchema(),s=(t=r==null?void 0:r.getDirectives())!==null&&t!==void 0?t:Y;for(const a of s)e[a.name]=C(a.args.filter(de),l=>l.name);const i=n.getDocument().definitions;for(const a of i)if(a.kind===c.DIRECTIVE_DEFINITION){var o;const l=(o=a.arguments)!==null&&o!==void 0?o:[];e[a.name.value]=C(l.filter(yn),u=>u.name.value)}return{Directive:{leave(a){const l=a.name.value,u=e[l];if(u){var f;const d=(f=a.arguments)!==null&&f!==void 0?f:[],m=new Set(d.map(g=>g.name.value));for(const[g,E]of Object.entries(u))if(!m.has(g)){const O=we(E.type)?v(E.type):T(E.type);n.reportError(new p(`Directive "@${l}" argument "${g}" of type "${O}" is required, but it was not provided.`,{nodes:a}))}}}}}}function yn(n){return n.type.kind===c.NON_NULL_TYPE&&n.defaultValue==null}function hn(n){return{Field(t){const e=n.getType(),r=t.selectionSet;if(e){if(k(h(e))){if(r){const s=t.name.value,i=v(e);n.reportError(new p(`Field "${s}" must not have a selection since type "${i}" has no subfields.`,{nodes:r}))}}else if(!r){const s=t.name.value,i=v(e);n.reportError(new p(`Field "${s}" of type "${i}" must have a selection of subfields. Did you mean "${s} { ... }"?`,{nodes:t}))}}}}}function Dn(n,t,e){var r;const s={},i=(r=t.arguments)!==null&&r!==void 0?r:[],o=C(i,a=>a.name.value);for(const a of n.args){const l=a.name,u=a.type,f=o[l];if(!f){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(I(u))throw new p(`Argument "${l}" of required type "${v(u)}" was not provided.`,{nodes:t});continue}const d=f.value;let m=d.kind===c.NULL;if(d.kind===c.VARIABLE){const E=d.name.value;if(e==null||!bn(e,E)){if(a.defaultValue!==void 0)s[l]=a.defaultValue;else if(I(u))throw new p(`Argument "${l}" of required type "${v(u)}" was provided the variable "$${E}" which was not provided a runtime value.`,{nodes:d});continue}m=e[E]==null}if(m&&I(u))throw new p(`Argument "${l}" of non-null type "${v(u)}" must not be null.`,{nodes:d});const g=Fe(d,u,e);if(g===void 0)throw new p(`Argument "${l}" has invalid value ${T(d)}.`,{nodes:d});s[l]=g}return s}function ae(n,t,e){var r;const s=(r=t.directives)===null||r===void 0?void 0:r.find(i=>i.name.value===n.name);if(s)return Dn(n,s,e)}function bn(n,t){return Object.prototype.hasOwnProperty.call(n,t)}function On(n,t,e,r,s){const i=new Map;return J(n,t,e,r,s,i,new Set),i}function J(n,t,e,r,s,i,o){for(const a of s.selections)switch(a.kind){case c.FIELD:{if(!q(e,a))continue;const l=Sn(a),u=i.get(l);u!==void 0?u.push(a):i.set(l,[a]);break}case c.INLINE_FRAGMENT:{if(!q(e,a)||!oe(n,a,r))continue;J(n,t,e,r,a.selectionSet,i,o);break}case c.FRAGMENT_SPREAD:{const l=a.name.value;if(o.has(l)||!q(e,a))continue;o.add(l);const u=t[l];if(!u||!oe(n,u,r))continue;J(n,t,e,r,u.selectionSet,i,o);break}}}function q(n,t){const e=ae(Re,t,n);if((e==null?void 0:e.if)===!0)return!1;const r=ae($e,t,n);return(r==null?void 0:r.if)!==!1}function oe(n,t,e){const r=t.typeCondition;if(!r)return!0;const s=y(n,r);return s===e?!0:ce(s)?n.isSubType(s,e):!1}function Sn(n){return n.alias?n.alias.value:n.name.value}function _n(n){return{OperationDefinition(t){if(t.operation==="subscription"){const e=n.getSchema(),r=e.getSubscriptionType();if(r){const s=t.name?t.name.value:null,i=Object.create(null),o=n.getDocument(),a=Object.create(null);for(const u of o.definitions)u.kind===c.FRAGMENT_DEFINITION&&(a[u.name.value]=u);const l=On(e,a,i,r,t.selectionSet);if(l.size>1){const d=[...l.values()].slice(1).flat();n.reportError(new p(s!=null?`Subscription "${s}" must select only one top level field.`:"Anonymous Subscription must select only one top level field.",{nodes:d}))}for(const u of l.values())u[0].name.value.startsWith("__")&&n.reportError(new p(s!=null?`Subscription "${s}" must not select an introspection top level field.`:"Anonymous Subscription must not select an introspection top level field.",{nodes:u}))}}}}}function De(n,t){const e=new Map;for(const r of n){const s=t(r),i=e.get(s);i===void 0?e.set(s,[r]):i.push(r)}return e}function wn(n){return{Field:t,Directive:t};function t(e){var r;const s=(r=e.arguments)!==null&&r!==void 0?r:[],i=De(s,o=>o.name.value);for(const[o,a]of i)a.length>1&&n.reportError(new p(`There can be only one argument named "${o}".`,{nodes:a.map(l=>l.name)}))}}function Fn(n){const t=Object.create(null),e=n.getSchema(),r=e?e.getDirectives():Y;for(const a of r)t[a.name]=!a.isRepeatable;const s=n.getDocument().definitions;for(const a of s)a.kind===c.DIRECTIVE_DEFINITION&&(t[a.name.value]=!a.repeatable);const i=Object.create(null),o=Object.create(null);return{enter(a){if(!("directives"in a)||!a.directives)return;let l;if(a.kind===c.SCHEMA_DEFINITION||a.kind===c.SCHEMA_EXTENSION)l=i;else if(K(a)||Ne(a)){const u=a.name.value;l=o[u],l===void 0&&(o[u]=l=Object.create(null))}else l=Object.create(null);for(const u of a.directives){const f=u.name.value;t[f]&&(l[f]?n.reportError(new p(`The directive "@${f}" can only be used once at this location.`,{nodes:[l[f],u]})):l[f]=u)}}}}function Rn(n){const t=Object.create(null);return{OperationDefinition:()=>!1,FragmentDefinition(e){const r=e.name.value;return t[r]?n.reportError(new p(`There can be only one fragment named "${r}".`,{nodes:[t[r],e.name]})):t[r]=e.name,!1}}}function $n(n){const t=[];let e=Object.create(null);return{ObjectValue:{enter(){t.push(e),e=Object.create(null)},leave(){const r=t.pop();r||b(!1),e=r}},ObjectField(r){const s=r.name.value;e[s]?n.reportError(new p(`There can be only one input field named "${s}".`,{nodes:[e[s],r.name]})):e[s]=r.name}}}function An(n){const t=Object.create(null);return{OperationDefinition(e){const r=e.name;return r&&(t[r.value]?n.reportError(new p(`There can be only one operation named "${r.value}".`,{nodes:[t[r.value],r]})):t[r.value]=r),!1},FragmentDefinition:()=>!1}}function Vn(n){return{OperationDefinition(t){var e;const r=(e=t.variableDefinitions)!==null&&e!==void 0?e:[],s=De(r,i=>i.variable.name.value);for(const[i,o]of s)o.length>1&&n.reportError(new p(`There can be only one variable named "$${i}".`,{nodes:o.map(a=>a.variable.name)}))}}}function kn(n){let t={};return{OperationDefinition:{enter(){t={}}},VariableDefinition(e){t[e.variable.name.value]=e},ListValue(e){const r=Ae(n.getParentInputType());if(!$(r))return D(n,e),!1},ObjectValue(e){const r=h(n.getInputType());if(!X(r))return D(n,e),!1;const s=C(e.fields,i=>i.name.value);for(const i of Object.values(r.getFields()))if(!s[i.name]&&Ve(i)){const a=v(i.type);n.reportError(new p(`Field "${r.name}.${i.name}" of required type "${a}" was not provided.`,{nodes:e}))}r.isOneOf&&Cn(n,e,r,s,t)},ObjectField(e){const r=h(n.getParentInputType());if(!n.getInputType()&&X(r)){const i=w(e.name.value,Object.keys(r.getFields()));n.reportError(new p(`Field "${e.name.value}" is not defined by type "${r.name}".`+S(i),{nodes:e}))}},NullValue(e){const r=n.getInputType();I(r)&&n.reportError(new p(`Expected value of type "${v(r)}", found ${T(e)}.`,{nodes:e}))},EnumValue:e=>D(n,e),IntValue:e=>D(n,e),FloatValue:e=>D(n,e),StringValue:e=>D(n,e),BooleanValue:e=>D(n,e)}}function D(n,t){const e=n.getInputType();if(!e)return;const r=h(e);if(!k(r)){const s=v(e);n.reportError(new p(`Expected value of type "${s}", found ${T(t)}.`,{nodes:t}));return}try{if(r.parseLiteral(t,void 0)===void 0){const i=v(e);n.reportError(new p(`Expected value of type "${i}", found ${T(t)}.`,{nodes:t}))}}catch(s){const i=v(e);s instanceof p?n.reportError(s):n.reportError(new p(`Expected value of type "${i}", found ${T(t)}; `+s.message,{nodes:t,originalError:s}))}}function Cn(n,t,e,r,s){var i;const o=Object.keys(r);if(o.length!==1){n.reportError(new p(`OneOf Input Object "${e.name}" must specify exactly one key.`,{nodes:[t]}));return}const l=(i=r[o[0]])===null||i===void 0?void 0:i.value,u=!l||l.kind===c.NULL,f=(l==null?void 0:l.kind)===c.VARIABLE;if(u){n.reportError(new p(`Field "${e.name}.${o[0]}" must be non-null.`,{nodes:[t]}));return}if(f){const d=l.name.value;s[d].type.kind!==c.NON_NULL_TYPE&&n.reportError(new p(`Variable "${d}" must be non-nullable to be used for OneOf Input Object "${e.name}".`,{nodes:[t]}))}}function Ln(n){return{VariableDefinition(t){const e=y(n.getSchema(),t.type);if(e!==void 0&&!ke(e)){const r=t.variable.name.value,s=T(t.type);n.reportError(new p(`Variable "$${r}" cannot be non-input type "${s}".`,{nodes:t.type}))}}}}function Pn(n){let t=Object.create(null);return{OperationDefinition:{enter(){t=Object.create(null)},leave(e){const r=n.getRecursiveVariableUsages(e);for(const{node:s,type:i,defaultValue:o}of r){const a=s.name.value,l=t[a];if(l&&i){const u=n.getSchema(),f=y(u,l.type);if(f&&!Un(u,f,l.defaultValue,i,o)){const d=v(f),m=v(i);n.reportError(new p(`Variable "$${a}" of type "${d}" used in position expecting type "${m}".`,{nodes:[l,s]}))}}}}},VariableDefinition(e){t[e.variable.name.value]=e}}}function Un(n,t,e,r,s){if(I(r)&&!I(t)){if(!(e!=null&&e.kind!==c.NULL)&&!(s!==void 0))return!1;const a=r.ofType;return re(n,t,a)}return re(n,t,r)}const Mn=Object.freeze([sn]),be=Object.freeze([Ee,An,tn,_n,en,Qe,Ln,hn,qe,Rn,xe,Te,Nn,an,Vn,on,ln,Ke,Fn,Je,wn,kn,Tn,Pn,cn,$n,...Mn]);class jn{constructor(t,e){this._ast=t,this._fragments=void 0,this._fragmentSpreads=new Map,this._recursivelyReferencedFragments=new Map,this._onError=e}get[Symbol.toStringTag](){return"ASTValidationContext"}reportError(t){this._onError(t)}getDocument(){return this._ast}getFragment(t){let e;if(this._fragments)e=this._fragments;else{e=Object.create(null);for(const r of this.getDocument().definitions)r.kind===c.FRAGMENT_DEFINITION&&(e[r.name.value]=r);this._fragments=e}return e[t]}getFragmentSpreads(t){let e=this._fragmentSpreads.get(t);if(!e){e=[];const r=[t];let s;for(;s=r.pop();)for(const i of s.selections)i.kind===c.FRAGMENT_SPREAD?e.push(i):i.selectionSet&&r.push(i.selectionSet);this._fragmentSpreads.set(t,e)}return e}getRecursivelyReferencedFragments(t){let e=this._recursivelyReferencedFragments.get(t);if(!e){e=[];const r=Object.create(null),s=[t.selectionSet];let i;for(;i=s.pop();)for(const o of this.getFragmentSpreads(i)){const a=o.name.value;if(r[a]!==!0){r[a]=!0;const l=this.getFragment(a);l&&(e.push(l),s.push(l.selectionSet))}}this._recursivelyReferencedFragments.set(t,e)}return e}}class Yn extends jn{constructor(t,e,r,s){super(e,s),this._schema=t,this._typeInfo=r,this._variableUsages=new Map,this._recursiveVariableUsages=new Map}get[Symbol.toStringTag](){return"ValidationContext"}getSchema(){return this._schema}getVariableUsages(t){let e=this._variableUsages.get(t);if(!e){const r=[],s=new pe(this._schema);me(t,ge(s,{VariableDefinition:()=>!1,Variable(i){r.push({node:i,type:s.getInputType(),defaultValue:s.getDefaultValue()})}})),e=r,this._variableUsages.set(t,e)}return e}getRecursiveVariableUsages(t){let e=this._recursiveVariableUsages.get(t);if(!e){e=this.getVariableUsages(t);for(const r of this.getRecursivelyReferencedFragments(t))e=e.concat(this.getVariableUsages(r));this._recursiveVariableUsages.set(t,e)}return e}getType(){return this._typeInfo.getType()}getParentType(){return this._typeInfo.getParentType()}getInputType(){return this._typeInfo.getInputType()}getParentInputType(){return this._typeInfo.getParentInputType()}getFieldDef(){return this._typeInfo.getFieldDef()}getDirective(){return this._typeInfo.getDirective()}getArgument(){return this._typeInfo.getArgument()}getEnumValue(){return this._typeInfo.getEnumValue()}}function Oe(n,t,e=be,r,s=new pe(n)){var i;const o=(i=void 0)!==null&&i!==void 0?i:100;t||Ce(!1,"Must provide document."),Le(n);const a=Object.freeze({}),l=[],u=new Yn(n,t,s,d=>{if(l.length>=o)throw l.push(new p("Too many validation errors, error limit reached. Validation aborted.")),a;l.push(d)}),f=Pe(e.map(d=>d(u)));try{me(t,ge(s,f))}catch(d){if(d!==a)throw d}return l}function Gn(n){return{Field(t){const e=n.getFieldDef(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=n.getParentType();s!=null||b(!1),n.reportError(new p(`The field ${s.name}.${e.name} is deprecated. ${r}`,{nodes:t}))}},Argument(t){const e=n.getArgument(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=n.getDirective();if(s!=null)n.reportError(new p(`Directive "@${s.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}));else{const i=n.getParentType(),o=n.getFieldDef();i!=null&&o!=null||b(!1),n.reportError(new p(`Field "${i.name}.${o.name}" argument "${e.name}" is deprecated. ${r}`,{nodes:t}))}}},ObjectField(t){const e=h(n.getParentInputType());if(X(e)){const r=e.getFields()[t.name.value],s=r==null?void 0:r.deprecationReason;s!=null&&n.reportError(new p(`The input field ${e.name}.${r.name} is deprecated. ${s}`,{nodes:t}))}},EnumValue(t){const e=n.getEnumValue(),r=e==null?void 0:e.deprecationReason;if(e&&r!=null){const s=h(n.getInputType());s!=null||b(!1),n.reportError(new p(`The enum value "${s.name}.${e.name}" is deprecated. ${r}`,{nodes:t}))}}}}function Bn(n,t,e,r,s){const i=be.filter(a=>!(a===Te||a===Ee));return e&&Array.prototype.push.apply(i,e),Oe(n,t,i).filter(a=>{if(a.message.includes("Unknown directive")&&a.nodes){const l=a.nodes[0];if(l&&l.kind===c.DIRECTIVE){const u=l.name.value;if(u==="arguments"||u==="argumentDefinitions")return!1}}return!0})}const R={Error:"Error",Warning:"Warning",Information:"Information",Hint:"Hint"},W={[R.Error]:1,[R.Warning]:2,[R.Information]:3,[R.Hint]:4},j=(n,t)=>{if(!n)throw new Error(t)};function qn(n,t=null,e,r,s){var i,o;let a=null,l="";s&&(l=typeof s=="string"?s:s.reduce((f,d)=>f+T(d)+`

`,""));const u=l?`${n}

${l}`:n;try{a=Ue(u)}catch(f){if(f instanceof p){const d=Hn((o=(i=f.locations)===null||i===void 0?void 0:i[0])!==null&&o!==void 0?o:{line:0,column:0},u);return[{severity:W.Error,message:f.message,source:"GraphQL: Syntax",range:d}]}throw f}return Xn(a,t,e)}function Xn(n,t=null,e,r){if(!t)return[];const s=Bn(t,n,e).flatMap(o=>le(o,W.Error,"Validation")),i=Oe(t,n,[Gn]).flatMap(o=>le(o,W.Warning,"Deprecation"));return s.concat(i)}function le(n,t,e){if(!n.nodes)return[];const r=[];for(const[s,i]of n.nodes.entries()){const o=i.kind!=="Variable"&&"name"in i&&i.name!==void 0?i.name:"variable"in i&&i.variable!==void 0?i.variable:i;if(o){j(n.locations,"GraphQL validation error requires locations.");const a=n.locations[s],l=Qn(o),u=a.column+(l.end-l.start);r.push({source:`GraphQL: ${e}`,message:n.message,severity:t,range:new ve(new L(a.line-1,a.column-1),new L(a.line-1,u))})}}return r}function Hn(n,t){const e=je(),r=e.startState(),s=t.split(`
`);j(s.length>=n.line,"Query text must have more lines than where the error happened");let i=null;for(let u=0;u<n.line;u++)for(i=new Me(s[u]);!i.eol()&&e.token(i,r)!=="invalidchar";);j(i,"Expected Parser stream to be available.");const o=n.line-1,a=i.getStartOfToken(),l=i.getCurrentPosition();return new ve(new L(o,a),new L(o,l))}function Qn(n){const e=n.loc;return j(e,"Expected ASTNode to have a location."),e}const ue=["error","warning","information","hint"],Jn={"GraphQL: Validation":"validation","GraphQL: Deprecation":"deprecation","GraphQL: Syntax":"syntax"};G.registerHelper("lint","graphql",(n,t)=>{const{schema:e,validationRules:r,externalFragments:s}=t;return qn(n,e,r,void 0,s).map(a=>({message:a.message,severity:a.severity?ue[a.severity-1]:ue[0],type:a.source?Jn[a.source]:void 0,from:G.Pos(a.range.start.line,a.range.start.character),to:G.Pos(a.range.end.line,a.range.end.character)}))});
