
<!-- %W  tutorial.xml    GAP 4 package AtlasRep             Thomas Breuer -->


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Chapter Label="chap:tutorial">
<Heading>Tutorial for the &AtlasRep; Package</Heading>

This chapter gives an overview of the basic functionality
provided by the &AtlasRep; package.
The main concepts and interface functions are presented in the first three
sections,
and Section&nbsp;<Ref Sect="sect:Examples of Using the AtlasRep Package"/>
shows a few small examples.

<P/>

Let us first fix the setup for the examples shown in the package manual.

<P/>

<Enum>
<Item>
First of all, we load the &AtlasRep; package.
Some of the examples require also the &GAP; packages
<Package>CTblLib</Package> and <Package>TomLib</Package>,
so we load also these packages.

<P/>

<Example><![CDATA[
gap> LoadPackage( "AtlasRep", false );
true
gap> LoadPackage( "CTblLib", false );
true
gap> LoadPackage( "TomLib", false );
true
]]></Example>
</Item>
<Item>
Depending on the terminal capabilities,
the output of <Ref Func="DisplayAtlasInfo"/>
may contain non-ASCII characters,
which are not supported by the &LaTeX; and HTML versions
of &GAPDoc; documents.
The examples in this manual are used for tests of the package's
functionality,
thus we set the user preference <C>DisplayFunction</C>
(see Section <Ref Subsect="subsect:DisplayFunction"/>)
to the value <C>"Print"</C>
in order to produce output consisting only of ASCII characters,
which is assumed to work in any terminal.

<P/>

<Example><![CDATA[
gap> origpref:= UserPreference( "AtlasRep", "DisplayFunction" );;
gap> SetUserPreference( "AtlasRep", "DisplayFunction", "Print" );
]]></Example>
</Item>
<Item>
The &GAP; output for the examples may look differently if data extensions
have been loaded.
In order to ignore these extensions in the examples,
we unload them.

<P/>

<Example><![CDATA[
gap> priv:= Difference(
>     List( AtlasOfGroupRepresentationsInfo.notified, x -> x.ID ),
>     [ "core", "internal" ] );;
gap> Perform( priv, AtlasOfGroupRepresentationsForgetData );
]]></Example>
</Item>
<Item>
If the info level of <Ref Var="InfoAtlasRep"/> is larger than zero then
additional output appears on the screen.
In order to avoid this output, we set the level to zero.

<Example><![CDATA[
gap> globallevel:= InfoLevel( InfoAtlasRep );;
gap> SetInfoLevel( InfoAtlasRep, 0 );
]]></Example>
</Item>
</Enum>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:tutaccessgroup">
<Heading>Accessing a Specific Group in &AtlasRep;</Heading>

An important database to which the &AtlasRep; package gives access
is the &ATLAS; of Group Representations <Cite Key="AGRv3"/>.
It contains generators and related data for several groups,
mainly for extensions of simple groups
(see Section&nbsp;<Ref Subsect="sect:tutnearlysimple"/>)
and for their maximal subgroups
(see Section&nbsp;<Ref Subsect="sect:tutmaxes"/>).

<P/>

In general, these data are not part of the package.
They are downloaded as soon as they are needed for the first time,
see Section&nbsp;<Ref Subsect="subsect:AtlasRepAccessRemoteFiles"/>.


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:tutnearlysimple">
<Heading>Accessing a Group in &AtlasRep; via its Name</Heading>

Each group that occurs in this database is specified by a <E>name</E>,
which is a string similar to the name used in the &ATLAS; of Finite Groups
<Cite Key="CCN85"/>.
For those groups whose character tables are contained in the
&GAP; Character Table Library&nbsp;<Cite Key="CTblLib"/>,
the names are equal to the
<Ref Func="Identifier" Label="for character tables" BookName="ref"/>
values of these character tables.
Examples of such names are
<C>"M24"</C> for the Mathieu group <M>M_{24}</M>,
<C>"2.A6"</C> for the double cover of the alternating group <M>A_6</M>, and
<C>"2.A6.2_1"</C> for the double cover of the symmetric group <M>S_6</M>.
The names that actually occur are listed in the first column of the
overview table that is printed by the function
<Ref Func="DisplayAtlasInfo"/>, called without arguments, see below.
The other columns of the table describe the data that are available in the
database.

<P/>

For example, <Ref Func="DisplayAtlasInfo"/> may print the following lines.
Omissions are indicated with <Q><C>...</C></Q>.

<Log><![CDATA[
gap> DisplayAtlasInfo();
group                    |  # | maxes | cl | cyc | out | fnd | chk | prs
-------------------------+----+-------+----+-----+-----+-----+-----+----
...
2.A5                     | 26 |     3 |    |     |     |     |  +  |  + 
2.A5.2                   | 11 |     4 |    |     |     |     |  +  |  + 
2.A6                     | 18 |     5 |    |     |     |     |     |    
2.A6.2_1                 |  3 |     6 |    |     |     |     |     |    
2.A7                     | 24 |     2 |    |     |     |     |     |    
2.A7.2                   |  7 |       |    |     |     |     |     |    
...
M22                      | 58 |     8 |  + |  +  |     |  +  |  +  |  + 
M22.2                    | 46 |     7 |  + |  +  |     |  +  |  +  |  + 
M23                      | 66 |     7 |  + |  +  |     |  +  |  +  |  + 
M24                      | 62 |     9 |  + |  +  |     |  +  |  +  |  + 
McL                      | 46 |    12 |  + |  +  |     |  +  |  +  |  + 
McL.2                    | 27 |    10 |    |  +  |     |  +  |  +  |  + 
O7(3)                    | 28 |       |    |     |     |     |     |    
O7(3).2                  |  3 |       |    |     |     |     |     |    
...
Suz                      | 30 |    17 |    |  +  |   2 |  +  |  +  |    
...
]]></Log>

<P/>

Called with a group name as the only argument,
the function <Ref Func="AtlasGroup" Label="for various arguments"/> returns
a group isomorphic to the group with the given name, or <K>fail</K>.
If permutation generators are available in the database
then a permutation group (of smallest available degree) is returned,
otherwise a matrix group.

<Example><![CDATA[
gap> g:= AtlasGroup( "M24" );
Group([ (1,4)(2,7)(3,17)(5,13)(6,9)(8,15)(10,19)(11,18)(12,21)(14,16)
  (20,24)(22,23), (1,4,6)(2,21,14)(3,9,15)(5,18,10)(13,17,16)
  (19,24,23) ])
gap> IsPermGroup( g );  NrMovedPoints( g );  Size( g );
true
24
244823040
gap> AtlasGroup( "J5" );
fail
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:tutmaxes">
<Heading>Accessing a Maximal Subgroup of a Group in &AtlasRep;</Heading>

Many maximal subgroups of extensions of simple groups can be constructed
using the function
<Ref Func="AtlasSubgroup"
 Label="for a group name (and various arguments) and a number"/>.
Given the name of the extension of the simple group
and the number of the conjugacy class of maximal subgroups,
this function returns a representative from this class.

<Example><![CDATA[
gap> g:= AtlasSubgroup( "M24", 1 );
Group([ (2,10)(3,12)(4,14)(6,9)(8,16)(15,18)(20,22)(21,24), (1,7,2,9)
  (3,22,10,23)(4,19,8,12)(5,14)(6,18)(13,16,17,24) ])
gap> IsPermGroup( g );  NrMovedPoints( g );  Size( g );
true
23
10200960
gap> AtlasSubgroup( "M24", 100 );
fail
]]></Example>

The classes of maximal subgroups are ordered
w.&nbsp;r.&nbsp;t.&nbsp;decreasing subgroup order.
So the first class contains maximal subgroups of smallest index.

<P/>

Note that groups obtained by <Ref Func="AtlasSubgroup"
 Label="for a group name (and various arguments) and a number"/> may be
not very suitable for computations in the sense that much nicer
representations exist.
For example, the sporadic simple O'Nan group <M>O'N</M> contains a
maximal subgroup <M>S</M> isomorphic with the Janko group <M>J_1</M>;
the smallest permutation representation of <M>O'N</M> has degree <M>122760</M>,
and restricting this representation to <M>S</M> yields a representation of
<M>J_1</M> of that degree.
However,
<M>J_1</M> has a faithful permutation representation of degree <M>266</M>,
which admits much more efficient computations.
If you are just interested in <M>J_1</M> and not in
its embedding into <M>O'N</M>
then one possibility to get a <Q>nicer</Q> faithful representation is to call
<Ref Func="SmallerDegreePermutationRepresentation" BookName="ref"/>.
In the abovementioned example, this works quite well;
note that in general,
we cannot expect that we get a representation of smallest degree in this way.

<Example><![CDATA[
gap> s:= AtlasSubgroup( "ON", 3 );
<permutation group of size 175560 with 2 generators>
gap> NrMovedPoints( s );  Size( s );
122760
175560
gap> hom:= SmallerDegreePermutationRepresentation( s );;
gap> NrMovedPoints( Image( hom ) ) < 2000;
true
]]></Example>

(Depending on random choices in the computations,
one may or my not get the degree <M>266</M> representation.)

<P/>

In this particular case, one could of course also ask directly for the group
<M>J_1</M>.

<Example><![CDATA[
gap> j1:= AtlasGroup( "J1" );
<permutation group of size 175560 with 2 generators>
gap> NrMovedPoints( j1 );
266
]]></Example>

If you have a group <M>G</M>, say,
and you are really interested in the embedding of a maximal subgroup of
<M>G</M> into <M>G</M> then an easy way to get compatible generators is to
create <M>G</M> with <Ref Func="AtlasGroup" Label="for various arguments"/>
and then to call <Ref Func="AtlasSubgroup" Label="for a group and a number"/>
with first argument the group <M>G</M>.

<Example><![CDATA[
gap> g:= AtlasGroup( "ON" );
<permutation group of size 460815505920 with 2 generators>
gap> s:= AtlasSubgroup( g, 3 );
<permutation group of size 175560 with 2 generators>
gap> IsSubset( g, s );
true
gap> IsSubset( g, j1 );
false
]]></Example>

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:tutaccessrepres">
<Heading>Accessing Specific Generators in &AtlasRep;</Heading>

The function <Ref Func="DisplayAtlasInfo"/>, called with an admissible
name of a group as the only argument,
lists the &ATLAS; data available for this group.

<Example><![CDATA[
gap> DisplayAtlasInfo( "A5" );
Representations for G = A5:    (all refer to std. generators 1)
---------------------------
 1: G <= Sym(5)                  3-trans., on cosets of A4 (1st max.)
 2: G <= Sym(6)                  2-trans., on cosets of D10 (2nd max.)
 3: G <= Sym(10)                 rank 3, on cosets of S3 (3rd max.)
 4: G <= GL(4a,2)                character 4a
 5: G <= GL(4b,2)                character 2ab
 6: G <= GL(4,3)                 character 4a
 7: G <= GL(6,3)                 character 3ab
 8: G <= GL(2a,4)                character 2a
 9: G <= GL(2b,4)                character 2b
10: G <= GL(3,5)                 character 3a
11: G <= GL(5,5)                 character 5a
12: G <= GL(3a,9)                character 3a
13: G <= GL(3b,9)                character 3b
14: G <= GL(4,Z)                 character 4a
15: G <= GL(5,Z)                 character 5a
16: G <= GL(6,Z)                 character 3ab
17: G <= GL(3a,Field([Sqrt(5)])) character 3a
18: G <= GL(3b,Field([Sqrt(5)])) character 3b

Programs for G = A5:    (all refer to std. generators 1)
--------------------
- class repres.*      
- presentation        
- maxes (all 3):
  1:  A4              
  2:  D10             
  3:  S3              
- std. gen. checker:
  (check)             
  (pres)              
]]></Example>

In order to fetch one of the listed permutation groups or matrix groups,
you can call <Ref Func="AtlasGroup" Label="for various arguments"/>
with second argument the function
<Ref Func="Position" BookName="ref"/> and third argument the position in
the list.

<Example><![CDATA[
gap> AtlasGroup( "A5", Position, 1 );
Group([ (1,2)(3,4), (1,3,5) ])
]]></Example>

Note that this approach may yield a different group after
a data extension has been loaded.

<P/>

Alternatively, you can describe the desired group by conditions,
such as the degree in the case of a permutation group,
and the dimension and the base ring in the case of a matrix group.

<Example><![CDATA[
gap> AtlasGroup( "A5", NrMovedPoints, 10 );
Group([ (2,4)(3,5)(6,8)(7,10), (1,2,3)(4,6,7)(5,8,9) ])
gap> AtlasGroup( "A5", Dimension, 4, Ring, GF(2) );
<matrix group of size 60 with 2 generators>
]]></Example>

<P/>

The same holds for the restriction to maximal subgroups:
Use
<Ref Func="AtlasSubgroup"
 Label="for a group name (and various arguments) and a number"/>
with the same arguments as
<Ref Func="AtlasGroup" Label="for various arguments"/>,
except that additionally the number of the class of maximal subgroups
is entered as the last argument.
Note that the conditions refer to the group, not to the subgroup;
it may happen that the subgroup moves fewer points than the big group.

<Example><![CDATA[
gap> AtlasSubgroup( "A5", Dimension, 4, Ring, GF(2), 1 );
<matrix group of size 12 with 2 generators>
gap> g:= AtlasSubgroup( "A5", NrMovedPoints, 10, 3 );
Group([ (2,4)(3,5)(6,8)(7,10), (1,4)(3,8)(5,7)(6,10) ])
gap> Size( g );  NrMovedPoints( g );
6
9
]]></Example>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:tutconcepts">
<Heading>Basic Concepts used in &AtlasRep;</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:tutstdgens">
<Heading>Groups, Generators, and Representations</Heading>

Up to now, we have talked only about groups and subgroups.
The &AtlasRep; package provides access to
<E>group generators</E>,
and in fact these generators have the property that mapping one set of
generators to another set of generators for the same group defines an
isomorphism.
These generators are called <E>standard generators</E>,
see Section&nbsp;<Ref Sect="sect:Standard Generators Used in AtlasRep"/>.

<P/>

So instead of thinking about several generating sets of a group <M>G</M>,
say, we can think about one abstract group <M>G</M>, with one fixed set
of generators,
and mapping these generators to any set of generators provided by
&AtlasRep; defines a representation of <M>G</M>.
This viewpoint had motivated the name <Q>&ATLAS; of Group Representations</Q>
for the core part of the database.

<P/>

If you are interested in the generators provided by the database
rather than in the groups they generate,
you can use the function <Ref Func="OneAtlasGeneratingSetInfo"/>
instead of <Ref Func="AtlasGroup" Label="for various arguments"/>,
with the same arguments.
This will yield a record that describes the representation in question.
Calling the function <Ref Func="AtlasGenerators"/> with this record
will then yield a record with the additional component <C>generators</C>,
which holds the list of generators.

<P/>

<Example><![CDATA[
gap> info:= OneAtlasGeneratingSetInfo( "A5", NrMovedPoints, 10 );
rec( charactername := "1a+4a+5a", constituents := [ 1, 4, 5 ], 
  contents := "core", groupname := "A5", id := "", 
  identifier := [ "A5", [ "A5G1-p10B0.m1", "A5G1-p10B0.m2" ], 1, 10 ],
  isPrimitive := true, maxnr := 3, p := 10, rankAction := 3, 
  repname := "A5G1-p10B0", repnr := 3, size := 60, stabilizer := "S3",
  standardization := 1, transitivity := 1, type := "perm" )
gap> info2:= AtlasGenerators( info );
rec( charactername := "1a+4a+5a", constituents := [ 1, 4, 5 ], 
  contents := "core", 
  generators := [ (2,4)(3,5)(6,8)(7,10), (1,2,3)(4,6,7)(5,8,9) ], 
  groupname := "A5", id := "", 
  identifier := [ "A5", [ "A5G1-p10B0.m1", "A5G1-p10B0.m2" ], 1, 10 ],
  isPrimitive := true, maxnr := 3, p := 10, rankAction := 3, 
  repname := "A5G1-p10B0", repnr := 3, size := 60, stabilizer := "S3",
  standardization := 1, transitivity := 1, type := "perm" )
gap> info2.generators;
[ (2,4)(3,5)(6,8)(7,10), (1,2,3)(4,6,7)(5,8,9) ]
]]></Example>

<P/>

The record <C>info</C> appears as the value of the attribute
<Ref Attr="AtlasRepInfoRecord" Label="for a group"/>
in groups that are returned by
<Ref Func="AtlasGroup" Label="for various arguments"/>.

<P/>

<Example><![CDATA[
gap> g:= AtlasGroup( "A5", NrMovedPoints, 10 );;
gap> AtlasRepInfoRecord( g );
rec( charactername := "1a+4a+5a", constituents := [ 1, 4, 5 ], 
  contents := "core", groupname := "A5", id := "", 
  identifier := [ "A5", [ "A5G1-p10B0.m1", "A5G1-p10B0.m2" ], 1, 10 ],
  isPrimitive := true, maxnr := 3, p := 10, rankAction := 3, 
  repname := "A5G1-p10B0", repnr := 3, size := 60, stabilizer := "S3",
  standardization := 1, transitivity := 1, type := "perm" )
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="sect:tutslp">
<Heading>Straight Line Programs</Heading>

For computing certain group elements from standard generators, such as
generators of a subgroup or class representatives,
&AtlasRep; uses <E>straight line programs</E>,
see <Ref Sect="Straight Line Programs" BookName="ref"/>.
Essentially this means to evaluate words in the generators,
which is similar to <Ref Func="MappedWord" BookName="ref"/>
but can be more efficient.

<P/>

It can be useful to deal with these straight line programs,
see <Ref Func="AtlasProgram"/>.
For example, an automorphism <M>\alpha</M>, say, of the group <M>G</M>,
if available in &AtlasRep;,
is given by a straight line program that defines the images of standard
generators of <M>G</M>.
This way, one can for example compute the image of a subgroup <M>U</M> of
<M>G</M> under <M>\alpha</M> by first applying the straight line program
for <M>\alpha</M> to standard generators of <M>G</M>,
and then applying the straight line program for the restriction from
<M>G</M> to <M>U</M>.

<P/>

<Example><![CDATA[
gap> prginfo:= AtlasProgramInfo( "A5", "maxes", 1 );
rec( groupname := "A5", identifier := [ "A5", "A5G1-max1W1", 1 ], 
  size := 12, standardization := 1, subgroupname := "A4", 
  version := "1" )
gap> prg:= AtlasProgram( prginfo.identifier );
rec( groupname := "A5", identifier := [ "A5", "A5G1-max1W1", 1 ], 
  program := <straight line program>, size := 12, 
  standardization := 1, subgroupname := "A4", version := "1" )
gap> Display( prg.program );
# input:
r:= [ g1, g2 ];
# program:
r[3]:= r[1]*r[2];
r[4]:= r[2]*r[1];
r[5]:= r[3]*r[3];
r[1]:= r[5]*r[4];
# return values:
[ r[1], r[2] ]
gap> ResultOfStraightLineProgram( prg.program, info2.generators );
[ (1,10)(2,3)(4,9)(7,8), (1,2,3)(4,6,7)(5,8,9) ]
]]></Example>

</Subsection>

</Section>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Section Label="sect:Examples of Using the AtlasRep Package">
<Heading>Examples of Using the &AtlasRep; Package</Heading>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Example: Class Representatives">
<Heading>Example: Class Representatives</Heading>

First we show the computation of class representatives of the Mathieu group
<M>M_{11}</M>, in a <M>2</M>-modular matrix representation.
We start with the ordinary and Brauer character tables of this group.

<P/>

<Example><![CDATA[
gap> tbl:= CharacterTable( "M11" );;
gap> modtbl:= tbl mod 2;;
gap> CharacterDegrees( modtbl );
[ [ 1, 1 ], [ 10, 1 ], [ 16, 2 ], [ 44, 1 ] ]
]]></Example>

<P/>

The output of <Ref Func="CharacterDegrees" BookName="ref"/>
means that the <M>2</M>-modular irreducibles of <M>M_{11}</M>
have degrees <M>1</M>, <M>10</M>, <M>16</M>, <M>16</M>, and <M>44</M>.

<P/>

Using <Ref Func="DisplayAtlasInfo"/>,
we find out that matrix generators for the irreducible <M>10</M>-dimensional
representation are available in the database.

<P/>

<Example><![CDATA[
gap> DisplayAtlasInfo( "M11", Characteristic, 2 );
Representations for G = M11:    (all refer to std. generators 1)
----------------------------
 6: G <= GL(10,2)  character 10a
 7: G <= GL(32,2)  character 16ab
 8: G <= GL(44,2)  character 44a
16: G <= GL(16a,4) character 16a
17: G <= GL(16b,4) character 16b
]]></Example>

<P/>

So we decide to work with this representation.
We fetch the generators and compute the list of class representatives
of <M>M_{11}</M> in the representation.
The ordering of class representatives is the same as that in the character
table of the &ATLAS; of Finite Groups (<Cite Key="CCN85"/>),
which coincides with the ordering of columns in the &GAP; table we have
fetched above.

<P/>

<Example><![CDATA[
gap> info:= OneAtlasGeneratingSetInfo( "M11", Characteristic, 2,
>                                             Dimension, 10 );;
gap> gens:= AtlasGenerators( info.identifier );;
gap> ccls:= AtlasProgram( "M11", gens.standardization, "classes" );
rec( groupname := "M11", identifier := [ "M11", "M11G1-cclsW1", 1 ], 
  outputs := [ "1A", "2A", "3A", "4A", "5A", "6A", "8A", "8B", "11A", 
      "11B" ], program := <straight line program>, 
  standardization := 1, version := "1" )
gap> reps:= ResultOfStraightLineProgram( ccls.program, gens.generators );;
]]></Example>

<P/>

If we would need only a few class representatives, we could use
the &GAP; library function <Ref Func="RestrictOutputsOfSLP" BookName="ref"/>
to create a straight line program that computes only specified outputs.
Here is an example where only the class representatives of order eight are
computed.

<P/>

<Example><![CDATA[
gap> ord8prg:= RestrictOutputsOfSLP( ccls.program,
>                   Filtered( [ 1 .. 10 ], i -> ccls.outputs[i][1] = '8' ) );
<straight line program>
gap> ord8reps:= ResultOfStraightLineProgram( ord8prg, gens.generators );;
gap> List( ord8reps, m -> Position( reps, m ) );
[ 7, 8 ]
]]></Example>

<P/>

Let us check that the class representatives have the right orders.

<P/>

<Example><![CDATA[
gap> List( reps, Order ) = OrdersClassRepresentatives( tbl );
true
]]></Example>

<P/>

From the class representatives, we can compute the Brauer character
we had started with.
This Brauer character is defined on all classes of the <M>2</M>-modular
table.
So we first pick only those representatives,
using the &GAP; function <Ref Func="GetFusionMap" BookName="ref"/>;
in this situation, it returns the class fusion from the Brauer table into
the ordinary table.

<P/>

<Example><![CDATA[
gap> fus:= GetFusionMap( modtbl, tbl );
[ 1, 3, 5, 9, 10 ]
gap> modreps:= reps{ fus };;
]]></Example>

<P/>

Then we call the &GAP; function
<Ref Func="BrauerCharacterValue" BookName="ref"/>,
which computes the Brauer character value from the matrix given.

<P/>

<Example><![CDATA[
gap> char:= List( modreps, BrauerCharacterValue );
[ 10, 1, 0, -1, -1 ]
gap> Position( Irr( modtbl ), char );
2
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Example: Permutation and Matrix Representations">
<Heading>Example: Permutation and Matrix Representations</Heading>

The second example shows the computation of a permutation representation
from a matrix representation.
We work with the <M>10</M>-dimensional representation used above,
and consider the action on the <M>2^{10}</M> vectors of the underlying row
space.

<P/>

<Example><![CDATA[
gap> grp:= Group( gens.generators );;
gap> v:= GF(2)^10;;
gap> orbs:= Orbits( grp, AsList( v ) );;
gap> List( orbs, Length );
[ 1, 396, 55, 330, 66, 165, 11 ]
]]></Example>

<P/>

We see that there are six nontrivial orbits,
and we can compute the permutation actions on these orbits directly
using <Ref Func="Action" BookName="ref"/>.
However, for larger examples, one cannot write down all orbits on the
row space, so one has to use another strategy if one is interested in
a particular orbit.

<P/>

Let us assume that we are interested in the orbit of length <M>11</M>.
The point stabilizer is the first maximal subgroup of <M>M_{11}</M>,
thus the restriction of the representation to this subgroup has a
nontrivial fixed point space.
This restriction can be computed using the &AtlasRep; package.

<P/>

<Example><![CDATA[
gap> gens:= AtlasGenerators( "M11", 6, 1 );;
]]></Example>

<P/>

Now computing the fixed point space is standard linear algebra.

<P/>

<Example><![CDATA[
gap> id:= IdentityMat( 10, GF(2) );;
gap> sub1:= Subspace( v, NullspaceMat( gens.generators[1] - id ) );;
gap> sub2:= Subspace( v, NullspaceMat( gens.generators[2] - id ) );;
gap> fix:= Intersection( sub1, sub2 );
<vector space of dimension 1 over GF(2)>
]]></Example>

<P/>

The final step is of course the computation of the permutation action
on the orbit.

<P/>

<Example><![CDATA[
gap> orb:= Orbit( grp, Basis( fix )[1] );;
gap> act:= Action( grp, orb );;  Print( act, "\n" );
Group( [ ( 1, 2)( 4, 6)( 5, 8)( 7,10), ( 1, 3, 5, 9)( 2, 4, 7,11) ] )
]]></Example>

<P/>

Note that this group is <E>not</E> equal to the group obtained by fetching
the permutation representation from the database.
This is due to a different numbering of the points,
thus the groups are permutation isomorphic,
that is, they are conjugate in the symmetric group on eleven points.

<P/>

<Example><![CDATA[
gap> permgrp:= Group( AtlasGenerators( "M11", 1 ).generators );;
gap> Print( permgrp, "\n" );
Group( [ ( 2,10)( 4,11)( 5, 7)( 8, 9), (1,4,3,8)(2,5,6,9) ] )
gap> permgrp = act;
false
gap> IsConjugate( SymmetricGroup(11), permgrp, act );
true
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Example: Outer Automorphisms">
<Heading>Example: Outer Automorphisms</Heading>

The straight line programs for applying outer automorphisms to
standard generators can of course be used to define the automorphisms
themselves as &GAP; mappings.

<P/>

<Example><![CDATA[
gap> DisplayAtlasInfo( "G2(3)", IsStraightLineProgram );
Programs for G = G2(3):    (all refer to std. generators 1)
-----------------------
- class repres.            
- presentation             
- repr. cyc. subg.         
- std. gen. checker        
- automorphisms:
  2                        
- maxes (all 10):
   1:  U3(3).2             
   2:  U3(3).2             
   3:  (3^(1+2)+x3^2):2S4  
   4:  (3^(1+2)+x3^2):2S4  
   5:  L3(3).2             
   6:  L3(3).2             
   7:  L2(8).3             
   8:  2^3.L3(2)           
   9:  L2(13)              
  10:  2^(1+4)+:3^2.2      
gap> prog:= AtlasProgram( "G2(3)", "automorphism", "2" ).program;;
gap> info:= OneAtlasGeneratingSetInfo( "G2(3)", Dimension, 7 );;
gap> gens:= AtlasGenerators( info ).generators;;
gap> imgs:= ResultOfStraightLineProgram( prog, gens );;
]]></Example>

<P/>

If we are not suspicious whether the script really describes an
automorphism then we should tell this to &GAP;,
in order to avoid the expensive checks of the properties of being a
homomorphism and bijective
(see Section&nbsp;<Ref Sect="Creating Group Homomorphisms" BookName="ref"/>).
This looks as follows.

<P/>

<Example><![CDATA[
gap> g:= Group( gens );;
gap> aut:= GroupHomomorphismByImagesNC( g, g, gens, imgs );;
gap> SetIsBijective( aut, true );
]]></Example>

<P/>

If we are suspicious whether the script describes an automorphism
then we might have the idea to check it with &GAP;, as follows.

<P/>

<Example><![CDATA[
gap> aut:= GroupHomomorphismByImages( g, g, gens, imgs );;
gap> IsBijective( aut );
true
]]></Example>

<P/>

(Note that even for a comparatively small group such as <M>G_2(3)</M>,
this was a difficult task for &GAP; before version&nbsp;4.3.)

<P/>

Often one can form images under an automorphism <M>\alpha</M>, say,
without creating the homomorphism object.
This is obvious for the standard generators of the group <M>G</M> themselves,
but also for generators of a maximal subgroup <M>M</M> computed from standard
generators of <M>G</M>, provided that the straight line programs in question
refer to the same standard generators.
Note that the generators of <M>M</M> are given by evaluating words in terms
of standard generators of <M>G</M>,
and their images under <M>\alpha</M> can be obtained by evaluating the same
words at the images under <M>\alpha</M> of the standard generators of
<M>G</M>.

<P/>

<Example><![CDATA[
gap> max1:= AtlasProgram( "G2(3)", 1 ).program;;
gap> mgens:= ResultOfStraightLineProgram( max1, gens );;
gap> comp:= CompositionOfStraightLinePrograms( max1, prog );;
gap> mimgs:= ResultOfStraightLineProgram( comp, gens );;
]]></Example>

<P/>

The list <C>mgens</C> is the list of generators of the first maximal subgroup
of <M>G_2(3)</M>, <C>mimgs</C> is the list of images under the automorphism
given by the straight line program <C>prog</C>.
Note that applying the program returned by
<Ref Func="CompositionOfStraightLinePrograms" BookName="ref"/>
means to apply first <C>prog</C> and then <C>max1</C>.
Since we have already constructed the &GAP; object representing the
automorphism, we can check whether the results are equal.

<P/>

<Example><![CDATA[
gap> mimgs = List( mgens, x -> x^aut );
true
]]></Example>

<P/>

However, it should be emphasized that using <C>aut</C> requires a huge
machinery of computations behind the scenes, whereas applying the
straight line programs <C>prog</C> and <C>max1</C> involves only elementary
operations with the generators.
The latter is feasible also for larger groups,
for which constructing the &GAP; automorphism might be too hard.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Example: Semi-presentations">
<Heading>Example: Using Semi-presentations and Black Box Programs</Heading>

Let us suppose that we want to restrict a representation of the
Mathieu group <M>M_{12}</M> to a non-maximal subgroup of the type
<M>L_2(11)</M>.
The idea is that this subgroup can be found as a maximal subgroup of a
maximal subgroup of the type <M>M_{11}</M>,
which is itself maximal in <M>M_{12}</M>.
For that,
we fetch a representation of <M>M_{12}</M> and use a straight line program
for restricting it to the first maximal subgroup,
which has the type <M>M_{11}</M>.

<P/>

<Example><![CDATA[
gap> info:= OneAtlasGeneratingSetInfo( "M12", NrMovedPoints, 12 );
rec( charactername := "1a+11a", constituents := [ 1, 2 ], 
  contents := "core", groupname := "M12", id := "a", 
  identifier := [ "M12", [ "M12G1-p12aB0.m1", "M12G1-p12aB0.m2" ], 1, 
      12 ], isPrimitive := true, maxnr := 1, p := 12, rankAction := 2,
  repname := "M12G1-p12aB0", repnr := 1, size := 95040, 
  stabilizer := "M11", standardization := 1, transitivity := 5, 
  type := "perm" )
gap> gensM12:= AtlasGenerators( info.identifier );;
gap> restM11:= AtlasProgram( "M12", "maxes", 1 );;
gap> gensM11:= ResultOfStraightLineProgram( restM11.program,
>                                           gensM12.generators );
[ (3,9)(4,12)(5,10)(6,8), (1,4,11,5)(2,10,8,3) ]
]]></Example>

<P/>

Now we <E>cannot</E> simply apply a straight line program for a group
to some generators, since they are not necessarily
<E>standard</E> generators of the group.
We check this property using a semi-presentation for <M>M_{11}</M>,
see <Ref Subsect="Semi-Presentations and Presentations"/>.

<P/>

<Example><![CDATA[
gap> checkM11:= AtlasProgram( "M11", "check" );
rec( groupname := "M11", identifier := [ "M11", "M11G1-check1", 1, 1 ]
    , program := <straight line decision>, standardization := 1, 
  version := "1" )
gap> ResultOfStraightLineDecision( checkM11.program, gensM11 );
true
]]></Example>

<P/>

So we are lucky that applying the appropriate program for <M>M_{11}</M>
will give us the required generators for <M>L_2(11)</M>.

<P/>

<Example><![CDATA[
gap> restL211:= AtlasProgram( "M11", "maxes", 2 );;
gap> gensL211:= ResultOfStraightLineProgram( restL211.program, gensM11 );
[ (3,9)(4,12)(5,10)(6,8), (1,11,9)(2,12,8)(3,6,10) ]
gap> G:= Group( gensL211 );;  Size( G );  IsSimple( G );
660
true
]]></Example>

In this case, we could also use the information that is stored about
<M>M_{11}</M>, as follows.

<P/>
<Example><![CDATA[
gap> DisplayAtlasInfo( "M11", IsStraightLineProgram );
Programs for G = M11:    (all refer to std. generators 1)
---------------------
- presentation                                        
- repr. cyc. subg.                                    
- std. gen. finder                                    
- class repres.:
  (direct)                                            
  (composed)                                          
- maxes (all 5):
  1:  A6.2_3                                          
  1:  A6.2_3                                  (std. 1)
  2:  L2(11)                                          
  2:  L2(11)                                  (std. 1)
  3:  3^2:Q8.2                                        
  4:  S5                                              
  4:  S5                                      (std. 1)
  5:  2.S4                                            
- standardizations of maxes:
  from 1st max., version 1 to A6.2_3, std. 1          
  from 2nd max., version 1 to L2(11), std. 1          
  from 4th max., version 1 to A5.2, std. 1            
- std. gen. checker:
  (check)                                             
  (pres)                                              
]]></Example>
<P/>

The entry <Q>std.1</Q> in the line about the maximal subgroup of type
<M>L_2(11)</M> means that a straight line program for computing
<E>standard</E> generators (in standardization 1) of the subgroup.
This program can be fetched as follows.

<P/>
<Example><![CDATA[
gap> restL211std:= AtlasProgram( "M11", "maxes", 2, 1 );;
gap> ResultOfStraightLineProgram( restL211std.program, gensM11 );
[ (3,9)(4,12)(5,10)(6,8), (1,11,9)(2,12,8)(3,6,10) ]
]]></Example>

<P/>

We see that we get the same generators for the subgroup as above.
(In fact the second approach first applies the same program as is
given by <C>restL211.program</C>,
and then applies a program to the results that does nothing.)

<P/>

Usually representations are not given in terms of standard generators.
For example, let us take the <M>M_{11}</M> type group returned by the &GAP;
function <Ref Func="MathieuGroup" BookName="ref"/>.

<P/>

<Example><![CDATA[
gap> G:= MathieuGroup( 11 );;
gap> gens:= GeneratorsOfGroup( G );
[ (1,2,3,4,5,6,7,8,9,10,11), (3,7,11,8)(4,10,5,6) ]
gap> ResultOfStraightLineDecision( checkM11.program, gens );
false
]]></Example>

<P/>

If we want to compute an <M>L_2(11)</M> type subgroup of this group,
we can use a black box program for computing standard generators,
and then apply the straight line program for computing the restriction.

<P/>

<Example><![CDATA[
gap> find:= AtlasProgram( "M11", "find" );
rec( groupname := "M11", identifier := [ "M11", "M11G1-find1", 1, 1 ],
  program := <black box program>, standardization := 1, 
  version := "1" )
gap> stdgens:= ResultOfBBoxProgram( find.program, Group( gens ) );;
gap> List( stdgens, Order );
[ 2, 4 ]
gap> ResultOfStraightLineDecision( checkM11.program, stdgens );
true
gap> gensL211:= ResultOfStraightLineProgram( restL211.program, stdgens );;
gap> List( gensL211, Order );
[ 2, 3 ]
gap> G:= Group( gensL211 );;  Size( G );  IsSimple( G );
660
true
]]></Example>

<P/>

Note that applying the black box program several times may yield different
group elements, because computations of random elements are involved,
see <Ref Func="ResultOfBBoxProgram"/>.
All what the black box program promises is to construct standard
generators, and these are defined only up to conjugacy in the automorphism
group of the group in question.

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Example: Using the GAP Library of Tables of Marks">
<Heading>Example: Using the &GAP; Library of Tables of Marks</Heading>

The &GAP; Library of Tables of Marks
(the &GAP; package <Package>TomLib</Package>, <Cite Key="TomLib"/>)
provides,
for many almost simple groups, information for constructing representatives
of all conjugacy classes of subgroups.
If this information is compatible with the standard generators of the
&ATLAS; of Group Representations then we can use it to restrict any
representation from the &ATLAS; to prescribed subgroups.
This is useful in particular for those subgroups for which the &ATLAS;
of Group Representations itself does not contain a straight line program.

<P/>

<Example><![CDATA[
gap> tom:= TableOfMarks( "A5" );
TableOfMarks( "A5" )
gap> info:= StandardGeneratorsInfo( tom );
[ rec( ATLAS := true, description := "|a|=2, |b|=3, |ab|=5", 
      generators := "a, b", 
      script := [ [ 1, 2 ], [ 2, 3 ], [ 1, 1, 2, 1, 5 ] ], 
      standardization := 1 ) ]
]]></Example>

<P/>

The <K>true</K> value of the component <C>ATLAS</C> indicates
that the information stored on <C>tom</C> refers to the standard generators
of type <M>1</M> in the &ATLAS; of Group Representations.

<P/>

We want to restrict a <M>4</M>-dimensional integral representation of
<M>A_5</M> to a Sylow <M>2</M> subgroup of <M>A_5</M>,
and use <Ref Func="RepresentativeTomByGeneratorsNC" BookName="ref"/>
for that.

<P/>

<Example><![CDATA[
gap> info:= OneAtlasGeneratingSetInfo( "A5", Ring, Integers, Dimension, 4 );;
gap> stdgens:= AtlasGenerators( info.identifier );
rec( charactername := "4a", constituents := [ 4 ], contents := "core",
  dim := 4, 
  generators := 
    [ 
      [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
          [ -1, -1, -1, -1 ] ], 
      [ [ 0, 1, 0, 0 ], [ 0, 0, 0, 1 ], [ 0, 0, 1, 0 ], 
          [ 1, 0, 0, 0 ] ] ], groupname := "A5", id := "", 
  identifier := [ "A5", "A5G1-Zr4B0.g", 1, 4 ], 
  repname := "A5G1-Zr4B0", repnr := 14, ring := Integers, size := 60, 
  standardization := 1, type := "matint" )
gap> orders:= OrdersTom( tom );
[ 1, 2, 3, 4, 5, 6, 10, 12, 60 ]
gap> pos:= Position( orders, 4 );
4
gap> sub:= RepresentativeTomByGeneratorsNC( tom, pos, stdgens.generators );
<matrix group of size 4 with 2 generators>
gap> GeneratorsOfGroup( sub );
[ [ [ 1, 0, 0, 0 ], [ -1, -1, -1, -1 ], [ 0, 0, 0, 1 ], 
      [ 0, 0, 1, 0 ] ], 
  [ [ 1, 0, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 1, 0, 0 ], 
      [ -1, -1, -1, -1 ] ] ]
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Example: Index 770 Subgroups in M22">
<Heading>Example: Index <M>770</M> Subgroups in <M>M_{22}</M></Heading>

The sporadic simple Mathieu group <M>M_{22}</M> contains a unique class of
subgroups of index <M>770</M> (and order <M>576</M>).
This can be seen for example using &GAP;'s Library of Tables of Marks.

<P/>

<Example><![CDATA[
gap> tom:= TableOfMarks( "M22" );
TableOfMarks( "M22" )
gap> subord:= Size( UnderlyingGroup( tom ) ) / 770;
576
gap> ord:= OrdersTom( tom );;
gap> tomstabs:= Filtered( [ 1 .. Length( ord ) ], i -> ord[i] = subord );
[ 144 ]
]]></Example>

<P/>

The permutation representation of <M>M_{22}</M> on the right cosets of such
a subgroup <M>S</M> is contained in the &ATLAS; of Group Representations.

<P/>

<Example><![CDATA[
gap> DisplayAtlasInfo( "M22", NrMovedPoints, 770 );
Representations for G = M22:    (all refer to std. generators 1)
----------------------------
12: G <= Sym(770) rank 9, on cosets of (A4xA4):4 < 2^4:A6
]]></Example>

<P/>

Now we verify the information shown about the point stabilizer and
about the maximal overgroups of <M>S</M> in <M>M_{22}</M>.

<P/>

<Example><![CDATA[
gap> maxtom:= MaximalSubgroupsTom( tom );
[ [ 155, 154, 153, 152, 151, 150, 146, 145 ], 
  [ 22, 77, 176, 176, 231, 330, 616, 672 ] ]
gap> List( tomstabs, i -> List( maxtom[1], j -> ContainedTom( tom, i, j ) ) );
[ [ 0, 10, 0, 0, 0, 0, 0, 0 ] ]
]]></Example>

<P/>

We see that the only maximal subgroups of <M>M_{22}</M> that contain <M>S</M>
have index <M>77</M> in <M>M_{22}</M>.
According to the &ATLAS; of Finite Groups, these maximal subgroups have the
structure <M>2^4:A_6</M>.  From that and from the structure of <M>A_6</M>,
we conclude that <M>S</M> has the structure <M>2^4:(3^2:4)</M>.

<P/>

Alternatively, we look at the permutation representation of degree <M>770</M>.
We fetch it from the &ATLAS; of Group Representations.
There is exactly one nontrivial block system for this representation,
with <M>77</M> blocks of length <M>10</M>.

<P/>

<Example><![CDATA[
gap> g:= AtlasGroup( "M22", NrMovedPoints, 770 );
<permutation group of size 443520 with 2 generators>
gap> allbl:= AllBlocks( g );;
gap> List( allbl, Length );
[ 10 ]
]]></Example>

<P/>

Furthermore, &GAP; computes that the point stabilizer <M>S</M> has the
structure <M>(A_4 \times A_4):4</M>.

<P/>

<Example><![CDATA[
gap> stab:= Stabilizer( g, 1 );;
gap> StructureDescription( stab : nice );
"(A4 x A4) : C4"
gap> blocks:= Orbit( g, allbl[1], OnSets );;
gap> act:= Action( g, blocks, OnSets );;
gap> StructureDescription( Stabilizer( act, 1 ) );
"(C2 x C2 x C2 x C2) : A6"
]]></Example>

</Subsection>


<!-- %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% -->
<Subsection Label="subsect:Example: Index 462 Subgroups in M22">
<Heading>Example: Index <M>462</M> Subgroups in <M>M_{22}</M></Heading>

The &ATLAS; of Group Representations contains three
degree <M>462</M> permutation representations of the group <M>M_{22}</M>.

<P/>

<Example><![CDATA[
gap> DisplayAtlasInfo( "M22", NrMovedPoints, 462 );
Representations for G = M22:    (all refer to std. generators 1)
----------------------------
7: G <= Sym(462a) rank 5, on cosets of 2^4:A5 < 2^4:A6
8: G <= Sym(462b) rank 8, on cosets of 2^4:A5 < L3(4), 2^4:S5
9: G <= Sym(462c) rank 8, on cosets of 2^4:A5 < L3(4), 2^4:A6
]]></Example>

<P/>

The point stabilizers in these three representations have the structure
<M>2^4:A_5</M>.
Using &GAP;'s Library of Tables of Marks,
we can show that these stabilizers are exactly the three classes of subgroups
of order <M>960</M> in <M>M_{22}</M>.
For that, we first verify that the group generators stored in &GAP;'s
table of marks coincide with the standard generators used by the
&ATLAS; of Group Representations.

<P/>

<Example><![CDATA[
gap> tom:= TableOfMarks( "M22" );
TableOfMarks( "M22" )
gap> genstom:= GeneratorsOfGroup( UnderlyingGroup( tom ) );;
gap> checkM22:= AtlasProgram( "M22", "check" );
rec( groupname := "M22", identifier := [ "M22", "M22G1-check1", 1, 1 ]
    , program := <straight line decision>, standardization := 1, 
  version := "1" )
gap> ResultOfStraightLineDecision( checkM22.program, genstom );
true
]]></Example>

<P/>

There are indeed three classes of subgroups of order <M>960</M>
in <M>M_{22}</M>.

<P/>

<Example><![CDATA[
gap> ord:= OrdersTom( tom );;
gap> tomstabs:= Filtered( [ 1 .. Length( ord ) ], i -> ord[i] = 960 );
[ 147, 148, 149 ]
]]></Example>

<P/>

Now we compute representatives of these three classes in the three
representations <C>462a</C>, <C>462b</C>, and <C>462c</C>.
We see that each of the three classes occurs as a point stabilizer
in exactly one of the three representations.

<P/>

<Example><![CDATA[
gap> atlasreps:= AllAtlasGeneratingSetInfos( "M22", NrMovedPoints, 462 );
[ rec( charactername := "1a+21a+55a+154a+231a", 
      constituents := [ 1, 2, 5, 7, 9 ], contents := "core", 
      groupname := "M22", id := "a", 
      identifier := 
        [ "M22", [ "M22G1-p462aB0.m1", "M22G1-p462aB0.m2" ], 1, 462 ],
      isPrimitive := false, p := 462, rankAction := 5, 
      repname := "M22G1-p462aB0", repnr := 7, size := 443520, 
      stabilizer := "2^4:A5 < 2^4:A6", standardization := 1, 
      transitivity := 1, type := "perm" ), 
  rec( charactername := "1a+21a^2+55a+154a+210a", 
      constituents := [ 1, [ 2, 2 ], 5, 7, 8 ], contents := "core", 
      groupname := "M22", id := "b", 
      identifier := 
        [ "M22", [ "M22G1-p462bB0.m1", "M22G1-p462bB0.m2" ], 1, 462 ],
      isPrimitive := false, p := 462, rankAction := 8, 
      repname := "M22G1-p462bB0", repnr := 8, size := 443520, 
      stabilizer := "2^4:A5 < L3(4), 2^4:S5", standardization := 1, 
      transitivity := 1, type := "perm" ), 
  rec( charactername := "1a+21a^2+55a+154a+210a", 
      constituents := [ 1, [ 2, 2 ], 5, 7, 8 ], contents := "core", 
      groupname := "M22", id := "c", 
      identifier := 
        [ "M22", [ "M22G1-p462cB0.m1", "M22G1-p462cB0.m2" ], 1, 462 ],
      isPrimitive := false, p := 462, rankAction := 8, 
      repname := "M22G1-p462cB0", repnr := 9, size := 443520, 
      stabilizer := "2^4:A5 < L3(4), 2^4:A6", standardization := 1, 
      transitivity := 1, type := "perm" ) ]
gap> atlasreps:= List( atlasreps, AtlasGroup );;
gap> tomstabreps:= List( atlasreps, G -> List( tomstabs,
> i -> RepresentativeTomByGenerators( tom, i, GeneratorsOfGroup( G ) ) ) );;
gap> List( tomstabreps, x -> List( x, NrMovedPoints ) );
[ [ 462, 462, 461 ], [ 460, 462, 462 ], [ 462, 461, 462 ] ]
]]></Example>

<P/>

More precisely, we see that the point stabilizers in the three
representations <C>462a</C>, <C>462b</C>, <C>462c</C> lie in the
subgroup classes <M>149</M>, <M>147</M>, <M>148</M>, respectively,
of the table of marks.

<P/>

The point stabilizers in the representations <C>462b</C> and <C>462c</C>
are isomorphic, but not isomorphic with the point stabilizer in <C>462a</C>.

<P/>

<Example><![CDATA[
gap> stabs:= List( atlasreps, G -> Stabilizer( G, 1 ) );;
gap> List( stabs, IdGroup );
[ [ 960, 11358 ], [ 960, 11357 ], [ 960, 11357 ] ]
gap> List( stabs, PerfectIdentification );
[ [ 960, 2 ], [ 960, 1 ], [ 960, 1 ] ]
]]></Example>

<P/>

The three representations are imprimitive.
The containment of the point stabilizers in maximal subgroups of
<M>M_{22}</M> can be computed using the table of marks of <M>M_{22}</M>.

<P/>

<Example><![CDATA[
gap> maxtom:= MaximalSubgroupsTom( tom );
[ [ 155, 154, 153, 152, 151, 150, 146, 145 ], 
  [ 22, 77, 176, 176, 231, 330, 616, 672 ] ]
gap> List( tomstabs, i -> List( maxtom[1], j -> ContainedTom( tom, i, j ) ) );
[ [ 21, 0, 0, 0, 1, 0, 0, 0 ], [ 21, 6, 0, 0, 0, 0, 0, 0 ], 
  [ 0, 6, 0, 0, 0, 0, 0, 0 ] ]
]]></Example>

<P/>

We see:

<List>
<Item>
  The point stabilizers in <C>462a</C> (subgroups in the class
  <M>149</M> of the table of marks) are contained only in maximal subgroups
  in class <M>154</M>; these groups have the structure <M>2^4:A_6</M>.
</Item>
<Item>
  The point stabilizers in <C>462b</C> (subgroups in the class <M>147</M>)
  are contained in maximal subgroups in the classes <M>155</M> and <M>151</M>;
  these groups have the structures <M>L_3(4)</M> and <M>2^4:S_5</M>,
  respectively.
</Item>
<Item>
  The point stabilizers in <C>462c</C> (subgroups in the class <M>148</M>)
  are contained in maximal subgroups in the classes <M>155</M> and <M>154</M>.
</Item>
</List>

<P/>

We identify the supergroups of the point stabilizers by computing the
block systems.

<P/>

<Example><![CDATA[
gap> bl:= List( atlasreps, AllBlocks );;
gap> List( bl, Length );
[ 1, 3, 2 ]
gap> List( bl, l -> List( l, Length ) );
[ [ 6 ], [ 21, 21, 2 ], [ 21, 6 ] ]
]]></Example>

<P/>

Note that the two block systems with blocks of length <M>21</M> for
<C>462b</C> belong to the same supergroups (of the type <M>L_3(4)</M>);
each of these subgroups fixes two different subsets of <M>21</M> points.

<P/>

The representation <C>462a</C> is <E>multiplicity-free</E>,
that is, it splits into a sum of pairwise nonisomorphic irreducible
representations.
This can be seen from the fact that the rank of this permutation
representation (that is, the number of orbits of the point stabilizer)
is five; each permutation representation with this property is
multiplicity-free.

<P/>

The other two representations have rank eight.
We have seen the ranks in the overview that was shown by
<Ref Func="DisplayAtlasInfo"/> in the beginning.
Now we compute the ranks from the permutation groups.

<P/>

<Example><![CDATA[
gap> List( atlasreps, RankAction );
[ 5, 8, 8 ]
]]></Example>

<P/>

In fact the two representations <C>462b</C> and <C>462c</C> have the same
permutation character.
We check this by computing the possible permutation characters
of degree <M>462</M> for <M>M_{22}</M>,
and decomposing them into irreducible characters,
using the character table from &GAP;'s Character Table Library.

<P/>

<Example><![CDATA[
gap> t:= CharacterTable( "M22" );;
gap> perms:= PermChars( t, 462 );
[ Character( CharacterTable( "M22" ),
  [ 462, 30, 3, 2, 2, 2, 3, 0, 0, 0, 0, 0 ] ), 
  Character( CharacterTable( "M22" ),
  [ 462, 30, 12, 2, 2, 2, 0, 0, 0, 0, 0, 0 ] ) ]
gap> MatScalarProducts( t, Irr( t ), perms );
[ [ 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 ], 
  [ 1, 2, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0 ] ]
]]></Example>

<P/>

In particular, we see that the rank eight characters are not
multiplicity-free.

</Subsection>

</Section>

</Chapter>

