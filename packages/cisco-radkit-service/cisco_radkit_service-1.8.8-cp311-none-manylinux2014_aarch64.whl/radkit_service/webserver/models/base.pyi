from _typeshed import Incomplete
from asyncssh import SSHKey
from collections.abc import Callable, Generator, Iterable, Sequence
from enum import Enum
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel, GetJsonSchemaHandler, RootModel, computed_field
from pydantic_core import CoreSchema
from radkit_common.types import CustomSecretStr
from radkit_service.database import DBDontUpdate
from typing import Any, Generic, Literal, Protocol
from typing_extensions import Self, TypeAlias, TypeGuard

__all__ = ['Ok', 'Error', 'APIResult', 'BulkResult', 'RADKitBaseModel', 'UpdateModel', 'DontUpdate', 'DONT_UPDATE', 'UpdateField', 'serialize_and_exclude_dont_update', 'load_private_key', 'wrap_err', 'wrap_errs']

class Ok(BaseModel, Generic[_T]):
    success: Literal[True]
    result: _T

class OkResult(Protocol, Generic[_T]):
    root: Ok[_T]
    def get_result(self) -> _T: ...

class ErrorResult(Protocol):
    root: Error
    def get_result(self) -> Error: ...

class Error(BaseModel):
    success: Literal[False]
    message: str
    detail: object
    @classmethod
    def from_exception(cls, e: Exception, summary: str | None = None, error_type_plurals: tuple[str, str] = ('validation error', 'validation errors'), error_action: str | None = None) -> Self: ...
    def as_exception(self) -> RequestValidationError: ...

class ControlAPIRequestStatus(Enum):
    SUCCESS = 'SUCCESS'
    FAILURE = 'FAILURE'
    PARTIAL_SUCCESS = 'PARTIAL_SUCCESS'

class APIResult(RootModel[Ok[_T] | Error]):
    root: Ok[_T] | Error
    __pt_repr__: Incomplete
    @property
    def status(self) -> ControlAPIRequestStatus: ...
    @classmethod
    def construct_from_metadata(cls, model: type[BaseModel] | BaseModel | None = None) -> type[APIResult[_T]]: ...
    @classmethod
    def ok(cls, result: _T) -> APIResult[_T]: ...
    @classmethod
    def error(cls, message: str, detail: object = None) -> APIResult[_T]: ...
    @classmethod
    def is_ok(cls, result: APIResult[_T]) -> TypeGuard[OkResult[_T]]: ...
    @classmethod
    def is_error(cls, result: APIResult[_T]) -> TypeGuard[ErrorResult]: ...
    def get_result(self) -> _T | Error: ...
    @property
    def result(self) -> _T | Error: ...

class _BulkResultType(Enum):
    RESULT = ...
    PASS_ERROR = ...
    PREV_ERROR = ...

class BulkResult(BaseModel, Generic[_T]):
    __pt_repr__: Incomplete
    def status(self) -> ControlAPIRequestStatus: ...
    results: list[APIResult[_T]]
    @classmethod
    def from_results(cls, results: Iterable[_T], result_type: type[_T]) -> BulkResult[_T]: ...
    def transform(self, transform: Callable[[_T], _U | Error], result_type: type[_U]) -> BulkResult[_U]: ...
    @computed_field
    @property
    def count(self) -> int: ...
    @computed_field
    @property
    def success_count(self) -> int: ...
    @computed_field
    @property
    def error_count(self) -> int: ...
    @computed_field
    @property
    def success(self) -> bool: ...
    def successful_results(self) -> Generator[_T, None, None]: ...
    def error_results(self) -> Generator[Error, None, None]: ...
    def enumerate_results(self) -> Generator[tuple[int, _T], None, None]: ...
    def results_index_map(self) -> list[int]: ...
    def enumerate_all_errors(self) -> Generator[tuple[int, Error], None, None]: ...
    def enumerate_pass_errors(self) -> Generator[tuple[int, Error], None, None]: ...
    def has_pass_errors(self) -> bool: ...
    def set_result(self, i: int, r: _T) -> None: ...
    def set_error(self, i: int, e: Error) -> None: ...
    def append_ok(self, result: _T) -> None: ...
    def append_error(self, message: str, detail: object = None) -> None: ...

class RADKitBaseModel(BaseModel):
    model_config: Incomplete
    @classmethod
    def __get_pydantic_json_schema__(cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler) -> dict[str, Any]: ...
    @classmethod
    def create_excluding_none(cls, **data: object) -> Self: ...

class RADKitRootModel(RootModel[_T]):
    model_config: Incomplete
    @classmethod
    def __get_pydantic_json_schema__(cls, core_schema: CoreSchema, handler: GetJsonSchemaHandler) -> dict[str, Any]: ...
    @classmethod
    def create_excluding_none(cls, **data: Any) -> Self: ...

class UpdateModel(RADKitBaseModel):
    dontUpdate: Literal[False]

class DontUpdate(RADKitBaseModel):
    dontUpdate: Literal[True]
    model_config: Incomplete
    def __eq__(self, other: object) -> bool: ...
    @classmethod
    def map(cls, func: Callable[[_T], _U], value: _T | DontUpdate) -> _U | DontUpdate: ...
    @classmethod
    def to_db_update(cls, value: _T | DontUpdate) -> _T | DBDontUpdate: ...
    @classmethod
    def or_(cls, value: _T | DontUpdate, default: _T) -> _T: ...

DONT_UPDATE: Incomplete
UpdateField: TypeAlias

def serialize_and_exclude_dont_update(model: BaseModel) -> str: ...
def load_private_key(private_key: CustomSecretStr, private_key_password: CustomSecretStr) -> SSHKey: ...
def wrap_err(err: Exception, loc: str | tuple[int | str, ...]) -> RequestValidationError: ...
def wrap_errs(err: Sequence[Exception], loc: str | tuple[int | str, ...]) -> RequestValidationError: ...
