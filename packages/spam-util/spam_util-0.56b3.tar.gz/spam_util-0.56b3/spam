#!/usr/bin/env python3
'''
    %(prog)s - A \x1b[1mS\x1b[moftware \x1b[1mPA\x1b[mckage \x1b[1mM\x1b[manager
    interface utility for Unixen.
    (C) 2024 Mike Miller, License: GPLv3+

    %(prog)s \x1b[3moptions\x1b[m sub-command \x1b[3mmoar-args\x1b[m

    # additional/customized sub-commands for
'''
import os
import signal
import sys
from os.path import exists, join
from argparse import ArgumentParser
from platform import freedesktop_os_release


# defaults
CONFIG_INI = '''
[spam_need_sudo]
add-apt-repository
autoremove
check-update
clean
config-manager
dist-upgrade
downgrade
history
install
mark
purge
reinstall
remove
selfupdate
system-upgrade
update
upgrade

[spam_aliases]
inf = infile
# old list package files alias
lsf = contents
ls = list
lsi = list_installed
po = policy
pr = provides
pu = purge
rm = remove
se = search
up = upgrade
in =  install

[fedora]
spam_exec = dnf
add = config-manager --add-repo
clean = clean packages; autoremove
contents = repoquery -l --cacheonly
# below doesnt need separate command
infile = install
info = info --cacheonly
list_installed = list --installed,
provides = provides --disablerepo=\\*
purge = remove
search = search --cacheonly
show = info --cacheonly
update = check-update --refresh

[debian]
spam_exec = apt
add = !add-apt-repository
clean = clean; autoremove
contents = !dpkg-query --listfiles
infile = !sudo dpkg --install
info = show
list_installed = list --installed
provides = !dpkg --search
upgrade = update; dist-upgrade

[mac_ports]
spam_exec = port
clean = clean --all all; reclaim
info = info; variants
remove = uninstall --follow-dependents
search = search --line --name
update = sync
upgrade = -v selfupdate; upgrade outdated

[openwrt]
spam_exec = opkg
contents = files
info = show; status
list_installed = list-installed
provides = search
purge = remove
search = find
upgrade = update;!owut check;!echo run⏵ owut upgrade

[ubuntu]
spam_extends = debian

[linuxmint]
spam_extends = debian
# foo = bar  # how to override

[redhat]
spam_extends = fedora
'''

need_sudo = set()
aliases = {}
platform_cmds = {}


def get_config(filename='config.ini'):
    ''' Loads the config.ini file if available; writes it if not. '''
    from configparser import ConfigParser

    # find path to .ini
    conf_folder = os.getenv('XDG_CONFIG_HOME') or \
        join(os.getenv('HOME', ''), '.config')
    conf_folder = join(conf_folder, 'spam')
    path = join(conf_folder, filename)

    # load config
    config = ConfigParser(allow_no_value=True, interpolation=None)

    # an empty result means not found:
    if not config.read(path):
        config.read_string(CONFIG_INI)  # read embedded defaults,
        # but also write them to path, for next time
        os.makedirs(conf_folder, exist_ok=True)
        with open(path, 'w', encoding='utf8') as outfile:
            num = outfile.write(CONFIG_INI)
            print_msg(f'{num} bytes written to {path} .')

    # find system - need to do first so we can print aliases if need be
    if sys.platform == 'darwin':
        platform_id = 'mac_ports' if exists('/opt/local/bin/port') else None
    else:  # tron leotards
        release_info = freedesktop_os_release()
        if '-d' in sys.argv:  # pre parse debug :-/
            print('release_info:', release_info)

        platform_id = release_info.get('ID')

    # load cmds that need sudo
    section_name = 'spam_need_sudo'
    if config.has_section(section_name):
        if _ := config.options(section_name):
            need_sudo.update(_)
            config.remove_section(section_name)

    # load aliases
    section_name = 'spam_aliases'
    if config.has_section(section_name):
        if _ := config.items(section_name):
            aliases.update(_)
            config.remove_section(section_name)

    # load platform section
    executable = None
    if config.has_section(platform_id):
        if candidate_cmds := config.items(platform_id):

            candidate_cmds_map = dict(candidate_cmds)  # shortcut
            if 'spam_extends' in candidate_cmds_map:  # needs extension?
                platform_id = candidate_cmds_map['spam_extends']
                # try again with new [platform_id] section
                if config.has_section(platform_id):
                    candidate_cmds = config.items(platform_id)  # overwrite
                else:
                    print(r'Error: section {!r} not found.')
                    sys.exit(os.EX_UNAVAILABLE)

            platform_cmds.update(candidate_cmds)  # with first or extended sect.
            if 'spam_extends' in candidate_cmds_map:  # check update again
                candidate_cmds_map.pop('spam_extends')  # clean up
                platform_cmds.update(candidate_cmds_map)  # from extended

            executable = platform_cmds.pop('spam_exec', None)

    return platform_id, executable


def print_msg(message, sgr='2'):
    ''' Print to stderr in a dim style (via ANSI sequence). '''
    print(f'\x1b[{sgr}m⏵', message, '\x1b[m', file=sys.stderr)


def setup(argv):
    ''' Parse command line, validate, initialize logging, etc. '''
    # load config early
    platform_id, executable = get_config()

    _usage = (
        f'{__doc__.rstrip()} {platform_id}/\x1b[1m{executable}\x1b[m:\n    '
        f'{", ".join(platform_cmds.keys())}\n '
    )  # important, ends in nbsp to prevent another strip by argparse

    # check & prepare args
    parser = ArgumentParser(add_help=False, usage=_usage)
    parser.add_argument('-d', '--debug', action='store_true', help='print…')
    parser.add_argument('-D', '--dry-run', action='store_true',
        help='Stop short of actually running the commands.')

    parser.add_argument('-F', '--skip-flatpak', action='store_true',
        help='on update, skip flatpak update.')
    parser.add_argument('-W', '--skip-firmware', action='store_true',
        help='on update, skip firmware update.')

    parser.add_argument(
        '--version', action='store_true', # version='%(prog)s ' + __version__
        help='print version number and exit.'
    )
    parser.add_argument(
        'sub_command', metavar='sub-command', help='package manager command.',
        nargs='?',
    )
    try:
        args, moar_args = parser.parse_known_args(argv[1:])
    except SystemExit:
        #~ exit(os.EX_USAGE)  # too many false positives, need to differentiate
        exit(os.EX_OK)

    # save for main
    args.executable = executable
    args.platform_id = platform_id
    if args.debug:
        print('args:', args)
        print('moar:', moar_args)
        print('platform_cmds:', platform_cmds)
        print('aliases:', aliases)

    # Check for sub-command --help and pass thru, handle here:
    if args.version:
        from importlib.metadata import version
        print('spam-util', version('spam-util'))
        sys.exit(os.EX_OK)

    if '--help' in moar_args or '-h' in moar_args:  # asked for help
        need_sudo.clear()  # deactivate

    if not executable:
        print('Error:', f'package manager not found for {platform_id!r}.',
              file=sys.stderr)
        sys.exit(os.EX_UNAVAILABLE)

    if not platform_id:
        print('Error:', 'platform_id not found.', file=sys.stderr)
        sys.exit(os.EX_UNAVAILABLE)

    if not args.sub_command:
        parser.print_help()
        sys.exit(os.EX_USAGE)

    return args, moar_args


def main(args, moar_args):
    from subprocess import call

    status_codes = [os.EX_OK]
    if args.debug:
        print('subcmd 0:', args.sub_command)

    # expand alias, if needed
    sub_command = aliases.get(args.sub_command, args.sub_command)
    if args.debug:
        print('unalias1:', repr(sub_command))

    # expand command, if needed
    sub_command = platform_cmds.get(sub_command, sub_command)
    if args.debug:
        print('platfm 2:', repr(sub_command))

    # there may be multiple commands; run each
    for sub_command in sub_command.split(';'):
        if args.debug:
            print('subcmd 3:', repr(sub_command))

        cmdlist = [args.executable]  # Starten-Sie
        if sub_command.startswith('!'):  # runs stand-alone, rm prefix
            sub_command = sub_command[1:]
            cmdlist = []
        if args.debug:
            print('split; 4:', repr(sub_command))

        # may have spaces
        sub_command = sub_command.split()
        if not args.platform_id == 'openwrt':  # uses root typically, w/o sudo
            # is this still needed?
            without_switches = [
                s for s in sub_command if not s.startswith('-')
            ]
            if without_switches[0] in need_sudo:
                cmdlist.insert(0, 'sudo')
        cmdlist.extend(sub_command)
        cmdlist.extend(moar_args)

        # cmd_line should be a string when shell=True :-/
        cmd_line = ' '.join(cmdlist)
        if args.debug:
            print('cmdlist:', cmdlist)
        print_msg(cmd_line)
        if args.dry_run:
            error_code = os.EX_OK
        else:
            if error_code := call(cmd_line, shell=True):
                return error_code  # if >=1, return immediately

        # post upgrade tasks?
        if sys.platform == 'linux' and sub_command[0] == 'upgrade':

            if not args.skip_flatpak and exists('/usr/bin/flatpak'):
                cmd_line = 'flatpak update'
                print_msg(cmd_line)
                if not args.dry_run:  # check here so we see dry run
                    if error_code := call(cmd_line, shell=True):
                        return error_code

            if not args.skip_firmware and exists('/usr/bin/fwupdmgr'):
                cmd_line = 'fwupdmgr update'
                print_msg(cmd_line)
                if not args.dry_run:  # check here so we see dry run
                    if error_code := call(cmd_line, shell=True):
                        if error_code != 2:  # gives this when nothing done :-/
                            return error_code

        status_codes.append(error_code)
        print()

    return status_codes[-1]  # last code 0, if we made it this far


# http://youtu.be/0hiUuL5uTKc?t=8s
try:
    sys.exit(main(*setup(sys.argv)))
except KeyboardInterrupt:
    print('\nWarning: Ctrl+C entered, exiting.', file=sys.stderr)
    sys.exit(128 + signal.SIGINT)
