"""Modified from https://gist.github.com/PatWalters/c046fee2760e6894ed13e19b8c99193b"""

from io import StringIO

import numpy as np
import pypdb
from prody import *
from pypdb.util import http_requests
from rdkit import Chem
from rdkit.Chem import AllChem, MolStandardize


def retrieve_model_text(url):
    response = http_requests.request_limited(url)

    if response is None or response.status_code != 200:
        warnings.warn("Retrieval failed, returning None")
        return None

    return str(response.text)


def describe_chemical(chem_id):
    """

    Parameters
    ----------

    chem_id : string
        A 4 character string representing the full chemical sequence of interest (ie, NAG)

    Returns
    -------

    out : dict
        A dictionary containing the chemical description associated with the PDB ID

    Examples
    --------
    >>> chem_desc = describe_chemical('NAG')
    """
    out = pypdb.get_info(
        chem_id, url_root="https://data.rcsb.org/rest/v1/core/chemcomp/"
    )
    return out


def describe_entry(pdb_id):
    out = pypdb.get_info(pdb_id, url_root="https://data.rcsb.org/rest/v1/core/entry/")
    return out


def get_pdb_components(pdb):
    """
    Split a protein-ligand pdb into protein and ligand components
    :param pdb_id:
    :return:
    """
    protein = pdb.select("protein")
    nuc = pdb.select("nucleic")
    ligand = pdb.select("hetero and not water")
    return protein, ligand, nuc


def process_ligand(ligand, res_name, pdb_id=None, chain_id=None, seq_id=None):
    """
    Add bond orders to a pdb ligand
    1. Select the ligand component with name "res_name"
    2. Get the corresponding SMILES from pypdb
    3. Create a template molecule from the SMILES in step 2
    4. Write the PDB file to a stream
    5. Read the stream into an RDKit molecule
    6. Assign the bond orders from the template from step 3
    :param ligand: ligand as generated by prody
    :param res_name: residue name of ligand to extract
    :return: molecule with bond orders assigned
    """
    sub_mol = ligand.select(f"resname {res_name}")
    if not sub_mol:
        return None

    chem_desc = describe_chemical(f"{res_name}")
    if not chem_desc:
        return None
    try:
        # First try to retrive the proprocessed sdf from rcsb
        sdf_string = retrieve_model_text(
            f"https://models.rcsb.org/v1/{pdb_id}/ligand?auth_seq_id={seq_id}&auth_asym_id={chain_id}&encoding=sdf"
        )
        supplier = Chem.SDMolSupplier()
        supplier.SetData(sdf_string)
        rd_mol = next(supplier)
        del supplier
        if rd_mol is not None:
            return rd_mol
        # Retry with relaxed parsing
        supplier = Chem.SDMolSupplier()
        supplier.SetData(sdf_string, strictParsing=False)
        rd_mol = next(supplier)
        del supplier
        if rd_mol is not None:
            return rd_mol
        # Retry without sanitization
        supplier = Chem.SDMolSupplier()
        supplier.SetData(sdf_string, sanitize=False, removeHs=False)
        rd_mol = next(supplier)
        del supplier
        if rd_mol is not None:
            return rd_mol
    except KeyError:
        print(
            f"WARNING: Cannot retrieve from RCSB models, fallback to template matching"
        )
    try:
        sub_smiles = chem_desc["rcsb_chem_comp_descriptor"]["smilesstereo"]
    except KeyError:
        print(
            f"WARNING: Cannot retrieve isomeric SMILES for {res_name}, retrying with simple SMILES"
        )
    try:
        sub_smiles = chem_desc["rcsb_chem_comp_descriptor"]["smiles"]
    except KeyError:
        print(f"WARNING: Cannot retrieve SMILES for {res_name}, skipping")
        return None

    print(f"Parsing Ligand {res_name}, template SMILES: {sub_smiles} ...")
    template = AllChem.MolFromSmiles(sub_smiles)
    output = StringIO()
    writePDBStream(output, sub_mol)
    pdb_string = output.getvalue()
    if not pdb_string:
        return None
    if not template:
        print(f"WARNING: Template smiles conversion failed, skipping {res_name}")
        return None
    try:
        rd_mol = AllChem.MolFromPDBBlock(pdb_string, proximityBonding=True)
        new_mol = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)
        return new_mol
    except Exception as e:
        print("Error captured:", e)
    try:
        # Attempt without sanitization
        rd_mol = AllChem.MolFromPDBBlock(pdb_string, sanitize=False)
        new_mol = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)
        return new_mol
    except Exception as e:
        print("Error captured:", e)
    try:
        # Attempt uncharging
        rd_mol = AllChem.MolFromPDBBlock(pdb_string, proximityBonding=True)
        uncharger = MolStandardize.rdMolStandardize.Uncharger()
        rd_mol = uncharger.uncharge(rd_mol)
        template = uncharger.uncharge(template)
        new_mol = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)
        return new_mol
    except Exception as e:
        print("Error captured:", e)
    try:
        # Retry parsing without proximity bondings
        rd_mol = AllChem.MolFromPDBBlock(pdb_string, proximityBonding=False)
        new_mol = AllChem.AssignBondOrdersFromTemplate(template, rd_mol)
        return new_mol
    except ValueError as e:
        print("Error captured:", e)
    try:
        # Fallback to simple SMILES identity checkings
        rd_mol = AllChem.MolFromPDBBlock(pdb_string)
        new_mol = uncharger.uncharge(rd_mol)
        template = uncharger.uncharge(template)
        assert AllChem.MolToSmiles(new_mol) == AllChem.MolToSmiles(template)
        return new_mol
    except Exception as e:
        print("Error captured:", e)
        return None


def write_pdb(protein, pdb_name):
    """
    Write a prody protein to a pdb file
    :param protein: protein object from prody
    :param pdb_name: base name for the pdb file
    :return: None
    """
    output_pdb_name = f"{pdb_name}_protein.pdb"
    writePDB(f"{output_pdb_name}", protein)
    print(f"wrote {output_pdb_name}")


def write_sdf(new_mol, pdb_name, res_name):
    """
    Write an RDKit molecule to an SD file
    :param new_mol:
    :param pdb_name:
    :param res_name:
    :return:
    """
    outfile_name = f"{pdb_name}_{res_name}_ligand.sdf"
    writer = Chem.SDWriter(f"{outfile_name}")
    writer.write(new_mol)
    print(f"wrote {outfile_name}")


def process_all_raw(pdb_name, metadata_only=False):
    """
    Split pdb into protein and ligands without further processing,
    :param pdb_name: id from the pdb, doesn't need to have an extension
    :return: (protein, ligand_processed)
    """
    ligand_processed = {}
    pdb = parsePDB(pdb_name)
    # print(pdb.getSerials())
    list(range(len(pdb.getResnums())))
    np.array(pdb.getChids())
    np.array(pdb.getResnums())
    np.array(pdb.getResnames())

    protein, hetero, nuc = get_pdb_components(pdb)
    if not protein:
        protein = None
    if not hetero and not nuc:
        # No ligand contained
        return protein, {}, None

    for ligand_set in [hetero, nuc]:
        if ligand_set is None:
            continue
        chain_id_list = sorted(list(set(ligand_set.getChids())))
        for chain_id in chain_id_list:
            try:
                ligands = ligand_set.select(f"chain {chain_id}")
            except:
                print(f"Group {chain_id} cannot be selected, skipped")
                continue
            ligand_processed[chain_id] = dict()
            seq_id_list = sorted(list(set(ligands.getResnums())))
            for seq_id in seq_id_list:
                ligand = ligands.select(f"resnum {seq_id}")
                ligand_processed[chain_id][seq_id] = dict()
                res_name_list = list(set(ligand.getResnames()))
                res = res_name_list[0]
                if metadata_only:
                    continue
                ligand_processed[chain_id][seq_id][res] = ligand

    return protein, ligand_processed, ligand_set


def process_all(pdb_name, metadata_only=False):
    """
    Read Ligand Expo data, split pdb into protein and ligands,
    write protein pdb, write ligand sdf files
    :param pdb_name: id from the pdb, doesn't need to have an extension
    :return: (protein, ligand_processed)
    """
    ligand_processed = {}
    pdb = parsePDB(pdb_name, bonds=True)
    # print(pdb.getSerials())
    all_aidx = list(range(len(pdb.getResnums())))
    bond_dict = {aid: set() for aid in all_aidx}
    all_aidx = np.array(all_aidx).astype(int)
    bond_atom_indices = [bond.getIndices() for bond in pdb.iterBonds()]
    # for bond in pdb.iterBonds():
    #     print(bond.getAtoms())
    for bai in bond_atom_indices:
        # print(bai)
        bond_dict[int(bai[0])].add(int(bai[1]))
        bond_dict[int(bai[1])].add(int(bai[0]))
    chainid_map = np.array(pdb.getChids())
    resnum_map = np.array(pdb.getResnums())
    resname_map = np.array(pdb.getResnames())
    inter_group_bonds = []

    protein, ligand_set, nuc = get_pdb_components(pdb)
    # print(protein._indices)
    # print(ligand_set._indices)
    # print(len(ligand_set._indices)+len(protein._indices))
    if not protein:
        protein = None
    # write_pdb(protein, pdb_name)
    # First ensure the ligand is deposited as a non-polymer entity
    if not ligand_set:
        # No ligand contained
        return protein, None, []
    chain_id_list = sorted(list(set(ligand_set.getChids())))
    # print(chain_id_list)
    for chain_id in chain_id_list:
        try:
            ligands = ligand_set.select(f"chain {chain_id}")
        except:
            print(f"Group {chain_id} cannot be selected, skipped")
            continue
        ligand_processed[chain_id] = dict()
        seq_id_list = sorted(list(set(ligands.getResnums())))
        # print(seq_id_list)
        for seq_id in seq_id_list:
            try:
                ligand = ligands.select(f"resnum {seq_id}")
            except:
                print(f"Group {chain_id} {seq_id} cannot be selected, skipped")
                continue
            res_name_list = list(set(ligand.getResnames()))
            if len(res_name_list) != 1:
                print(f"Group {chain_id} {seq_id} contains multiple residues, skipped")
                continue
            res = res_name_list[0]
            # print(ligand._indices)
            for aidx_in_lig, atom_idx in enumerate(ligand._indices):
                for bonded_aidx in bond_dict[atom_idx]:
                    # print(atom_idx, bonded_aidx)
                    if bonded_aidx in ligand._indices:
                        # intra-ligand bonds
                        continue
                    else:
                        # inter-group bonds
                        bonded_chainid = chainid_map[bonded_aidx]
                        bonded_resnum = resnum_map[bonded_aidx]
                        bonded_resname = resname_map[bonded_aidx]
                        # print(bonded_chainid, bonded_resnum, bonded_resname)
                        bonded_res_aidx_offset = all_aidx[
                            (chainid_map == bonded_chainid)
                            & (resnum_map == bonded_resnum)
                        ][0]
                        bonded_res_aidx = bonded_aidx - bonded_res_aidx_offset
                        # bonded_res_aidx = pdb.select(f"chain {bonded_chainid}").select(f"resnum {bonded_resnum}")._indices.tolist().index(bonded_aidx)
                        inter_group_bonds.append(
                            (
                                (chain_id, seq_id, res, aidx_in_lig),
                                (
                                    bonded_chainid,
                                    bonded_resnum,
                                    bonded_resname,
                                    bonded_res_aidx,
                                ),
                            )
                        )
            ligand_processed[chain_id][seq_id] = dict()
            # print(res_name_list)
            # for ag in ligand.getAtomGroup():
            #     print(ag.getFragindex())
            # print(ligand._indices)
            # print([bond.getIndices() for bond in ligand.iterBonds()])
            if metadata_only:
                continue
            new_mol = process_ligand(ligand, res, pdb_name, chain_id, seq_id)
            ligand_processed[chain_id][seq_id][res] = new_mol
            # write_sdf(new_mol, pdb_name, f"{res}_{chain_id}")

    # Parse DNA/RNAs
    nuc_chain_id_list = sorted(list(set(nuc.getChids())))
    for chain_id in nuc_chain_id_list:
        try:
            nuc_sel = nuc.select(f"chain {chain_id}")
        except:
            print(f"Group {chain_id} cannot be selected, skipped")
            continue
        if chain_id not in ligand_processed.keys():
            ligand_processed[chain_id] = dict()
        try:
            output = StringIO()
            writePDBStream(output, nuc_sel)
            pdb_string = output.getvalue()
            nuc_mol = AllChem.MolFromPDBBlock(pdb_string, sanitize=True)
            ligand_processed[chain_id][0] = {"NUC": nuc_mol}
        except:
            print(f"Error parsing nucleic acid {chain_id}, skipped")
            continue

    # print(inter_group_bonds)
    if metadata_only:
        return None, None, inter_group_bonds
    # print(ligand_processed)
    return protein, ligand_processed, inter_group_bonds


if __name__ == "__main__":
    if len(sys.argv) == 2:
        process_all(sys.argv[1], metadata_only=True)
    else:
        print("Usage: {sys.argv[1]} pdb_id", file=sys.stderr)
