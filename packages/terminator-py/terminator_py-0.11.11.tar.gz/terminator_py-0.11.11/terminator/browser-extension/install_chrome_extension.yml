---
tool_name: execute_sequence
arguments:
  variables:
    install_mode:
      type: enum
      label: Install Source
      options: ["Local", "GitHubRelease"]
      default: "Local"

    local_extension_dir:
      type: string
      label: Local extension directory (when install_mode = Local)
      default: "terminator/browser-extension"

    download_url:
      type: string
      label: GitHub release asset URL (when install_mode = GitHubRelease)
      # Tip: latest asset URL format â†’ https://github.com/OWNER/REPO/releases/latest/download/terminator-browser-extension.zip
      default: "https://github.com/OWNER/REPO/releases/latest/download/terminator-browser-extension.zip"

    open_url_after_install:
      type: string
      label: URL to open after launching the browser
      default: "chrome://extensions"

  steps:
    # Create target install directory per-OS
    - tool_name: run_command
      arguments:
        windows_command: |
          $ErrorActionPreference = 'Stop'
          $EXT_DIR = Join-Path $env:LOCALAPPDATA "Terminator\bridge-extension"
          New-Item -ItemType Directory -Force -Path $EXT_DIR | Out-Null
          Write-Output "EXT_DIR=$EXT_DIR"
        unix_command: |
          bash -lc '
          set -euo pipefail
          EXT_DIR="$HOME/.terminator/bridge-extension"
          mkdir -p "$EXT_DIR"
          echo "EXT_DIR=$EXT_DIR"'

    # Install from local folder (copy files)
    - group_name: "Install from local folder"
      skippable: true
      when: "${{ variables.install_mode }} == 'Local'"
      steps:
        - tool_name: run_command
          arguments:
            windows_command: |
              $ErrorActionPreference = 'Stop'
              $SRC = "${{ variables.local_extension_dir }}"
              if (-not (Test-Path $SRC)) { throw "Local extension dir not found: $SRC" }
              $EXT_DIR = Join-Path $env:LOCALAPPDATA "Terminator\bridge-extension"
              if (Test-Path $EXT_DIR) { Remove-Item -Recurse -Force $EXT_DIR }
              New-Item -ItemType Directory -Force -Path $EXT_DIR | Out-Null
              Copy-Item -Recurse -Force -Path (Join-Path $SRC '*') -Destination $EXT_DIR
              Write-Output "Installed to $EXT_DIR"
            unix_command: |
              bash -lc '
              set -euo pipefail
              SRC="${{ variables.local_extension_dir }}"
              if [ ! -d "$SRC" ]; then echo "Local extension dir not found: $SRC" >&2; exit 1; fi
              EXT_DIR="$HOME/.terminator/bridge-extension"
              rm -rf "$EXT_DIR"
              mkdir -p "$EXT_DIR"
              cp -R "$SRC"/* "$EXT_DIR"/
              echo "Installed to $EXT_DIR"'

    # Install from GitHub Release (download + extract)
    - group_name: "Install from GitHub Release"
      skippable: true
      when: "${{ variables.install_mode }} == 'GitHubRelease'"
      steps:
        - tool_name: run_command
          arguments:
            windows_command: |
              $ErrorActionPreference = 'Stop'
              $URL = "${{ variables.download_url }}"
              if ([string]::IsNullOrWhiteSpace($URL)) { throw "download_url is empty" }
              $ZIP = Join-Path $env:TEMP "terminator-extension.zip"
              Invoke-WebRequest -UseBasicParsing -Uri $URL -OutFile $ZIP
              $EXT_DIR = Join-Path $env:LOCALAPPDATA "Terminator\bridge-extension"
              if (Test-Path $EXT_DIR) { Remove-Item -Recurse -Force $EXT_DIR }
              New-Item -ItemType Directory -Force -Path $EXT_DIR | Out-Null
              Expand-Archive -Path $ZIP -DestinationPath $EXT_DIR -Force
              Write-Output "Installed to $EXT_DIR"
            unix_command: |
              bash -lc '
              set -euo pipefail
              URL="${{ variables.download_url }}"
              [ -z "$URL" ] && { echo "download_url is empty" >&2; exit 1; }
              ZIP="${TMPDIR:-/tmp}/terminator-extension.zip"
              curl -fsSL "$URL" -o "$ZIP"
              EXT_DIR="$HOME/.terminator/bridge-extension"
              rm -rf "$EXT_DIR"
              mkdir -p "$EXT_DIR"
              unzip -o "$ZIP" -d "$EXT_DIR" >/dev/null
              echo "Installed to $EXT_DIR"'

    # Launch Chrome/Edge with the extension loaded
    - tool_name: run_command
      arguments:
        windows_command: |
          $ErrorActionPreference = 'Stop'
          $EXT_DIR = Join-Path $env:LOCALAPPDATA "Terminator\bridge-extension"
          $candidates = @(
            Join-Path $env:ProgramFiles 'Google\Chrome\Application\chrome.exe'),
            Join-Path ${env:ProgramFiles(x86)} 'Google\Chrome\Application\chrome.exe',
            Join-Path $env:LOCALAPPDATA 'Google\Chrome\Application\chrome.exe',
            Join-Path $env:ProgramFiles 'Microsoft\Edge\Application\msedge.exe',
            Join-Path ${env:ProgramFiles(x86)} 'Microsoft\Edge\Application\msedge.exe'
          )
          $browser = $candidates | Where-Object { $_ -and (Test-Path $_) } | Select-Object -First 1
          if (-not $browser) { throw "No Chrome/Edge executable found" }
          $args = @("--load-extension=`"$EXT_DIR`"", "--no-first-run", "--new-window", "${{ variables.open_url_after_install }}")
          Start-Process -FilePath $browser -ArgumentList $args
        unix_command: |
          bash -lc '
          set -euo pipefail
          EXT_DIR="$HOME/.terminator/bridge-extension"
          BROWSER=""
          for C in google-chrome google-chrome-stable chromium chromium-browser microsoft-edge-beta microsoft-edge; do
            if command -v "$C" >/dev/null 2>&1; then BROWSER="$C"; break; fi
          done
          [ -z "$BROWSER" ] && { echo "No Chromium-based browser found" >&2; exit 1; }
          nohup "$BROWSER" --load-extension="$EXT_DIR" --no-first-run --new-window "${{ variables.open_url_after_install }}" >/dev/null 2>&1 & disown || true'

  stop_on_error: true
