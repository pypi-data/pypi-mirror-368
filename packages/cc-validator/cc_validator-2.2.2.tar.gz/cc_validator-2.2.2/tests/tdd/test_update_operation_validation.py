#!/usr/bin/env python3

import asyncio
import os
import sys
import tempfile

import pytest

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), "..")))

from cc_validator.hybrid_validator import HybridValidator


def test_update_adding_one_new_test_to_existing_file() -> None:
    """Test that Update can add one new test to an existing test file"""

    # Create a temporary test file with one existing test
    with tempfile.NamedTemporaryFile(mode="w", suffix="_test.py", delete=False) as f:
        f.write(
            """import pytest

def test_existing_feature():
    assert 1 + 1 == 2
"""
        )
        test_file_path = f.name

    try:
        # Update content adds one new test
        new_content = """import pytest

def test_existing_feature():
    assert 1 + 1 == 2

def test_new_feature():
    assert False
"""

        # Ensure GEMINI_API_KEY is available
        api_key = os.environ.get("GEMINI_API_KEY")
        validator = HybridValidator(api_key=api_key)

        tool_input = {"file_path": test_file_path, "content": new_content}

        result = asyncio.run(validator.validate_tool_use("Update", tool_input, ""))

        # Should be approved - only adding one new test
        assert result[
            "approved"
        ], f"Update with one new test should be approved but got: {result.get('reason')}"
        print("✓ Update adding one new test to existing file correctly approved")

    finally:
        # Clean up
        os.unlink(test_file_path)


def test_update_adding_multiple_new_tests_blocked() -> None:
    """Test that Update is blocked when adding multiple new tests"""

    # Create a temporary test file with one existing test
    with tempfile.NamedTemporaryFile(mode="w", suffix="_test.py", delete=False) as f:
        f.write(
            """import pytest

def test_existing_feature():
    assert 1 + 1 == 2
"""
        )
        test_file_path = f.name

    try:
        # Update content adds TWO new tests
        new_content = """import pytest

def test_existing_feature():
    assert 1 + 1 == 2

def test_new_feature_one():
    assert False
    
def test_new_feature_two():
    assert False
"""

        # Ensure GEMINI_API_KEY is available
        api_key = os.environ.get("GEMINI_API_KEY")
        validator = HybridValidator(api_key=api_key)

        tool_input = {"file_path": test_file_path, "content": new_content}

        result = asyncio.run(validator.validate_tool_use("Update", tool_input, ""))

        # Debug output
        print(
            f"Result: approved={result['approved']}, reason={result.get('reason', 'No reason')}"
        )
        print(f"TDD analysis: {result.get('tdd_analysis', 'No TDD analysis')}")

        # Should be blocked - adding multiple new tests
        assert not result[
            "approved"
        ], f"Update with multiple new tests should be blocked. Got: {result}"
        assert (
            "Multiple new tests" in result["reason"]
            or "multiple tests" in result["reason"].lower()
            or "new failing tests" in result["reason"].lower()
            or "new test" in result["reason"].lower()
        )
        print("✓ Update adding multiple new tests correctly blocked")

    finally:
        # Clean up
        os.unlink(test_file_path)


def test_update_modifying_existing_tests_allowed() -> None:
    """Test that Update can modify existing tests without adding new ones"""

    # Create a temporary test file
    fd, test_file_path = tempfile.mkstemp(suffix="_test.py")
    try:
        with os.fdopen(fd, "w") as f:
            f.write(
                """import pytest

def test_feature_one():
    assert 1 + 1 == 2
    
def test_feature_two():
    result = calculate_something()
    assert result == 42
"""
            )
        # File is now closed and accessible for reading
        # Update modifies only one existing test (refactoring)
        new_content = """import pytest

def test_feature_one():
    result = 1 + 1
    assert result == 2
    
def test_feature_two():
    result = calculate_something()
    assert result == 42
"""

        # Ensure GEMINI_API_KEY is available
        api_key = os.environ.get("GEMINI_API_KEY")
        validator = HybridValidator(api_key=api_key)

        tool_input = {"file_path": test_file_path, "content": new_content}

        result = asyncio.run(validator.validate_tool_use("Update", tool_input, ""))

        # Should be approved - no new tests added, just refactoring
        assert result[
            "approved"
        ], f"Update modifying existing tests should be approved but got: {result.get('reason')}"
        print(
            "✓ Update modifying existing tests without adding new ones correctly approved"
        )

    finally:
        # Clean up
        try:
            os.unlink(test_file_path)
        except OSError:
            pass


def test_update_on_nonexistent_file_uses_write_validation() -> None:
    """Test that Update on non-existent file falls back to Write validation"""

    # Ensure GEMINI_API_KEY is available
    api_key = os.environ.get("GEMINI_API_KEY")
    validator = HybridValidator(api_key=api_key)

    # Multiple tests in new file
    new_content = """import pytest

def test_feature_one():
    assert False
    
def test_feature_two():
    assert False
"""

    tool_input = {"file_path": "/tmp/nonexistent_test_file.py", "content": new_content}

    result = asyncio.run(validator.validate_tool_use("Update", tool_input, ""))

    # Should be blocked like Write - multiple tests in new file
    assert not result[
        "approved"
    ], "Update on new file with multiple tests should be blocked"
    assert (
        "Multiple tests" in result["reason"]
        or "multiple tests" in result["reason"].lower()
        or "new test" in result["reason"].lower()
    )
    print("✓ Update on non-existent file correctly uses Write validation")


def test_update_implementation_file() -> None:
    """Test Update on implementation files"""

    # Create a temporary implementation file
    with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
        f.write(
            """def existing_function():
    return 42
"""
        )
        impl_file_path = f.name

    try:
        # Update adds new implementation
        new_content = """def existing_function():
    return 42

def new_function():
    return existing_function() * 2
"""

        # Ensure GEMINI_API_KEY is available
        api_key = os.environ.get("GEMINI_API_KEY")
        validator = HybridValidator(api_key=api_key)

        tool_input = {"file_path": impl_file_path, "content": new_content}

        # This test will depend on whether there are corresponding tests
        # For now, just verify it doesn't crash
        result = asyncio.run(validator.validate_tool_use("Update", tool_input, ""))

        print(f"✓ Update on implementation file handled: approved={result['approved']}")

    finally:
        # Clean up
        os.unlink(impl_file_path)


if __name__ == "__main__":
    print("Testing Update operation validation scenarios...\n")

    test_update_adding_one_new_test_to_existing_file()
    print()

    test_update_adding_multiple_new_tests_blocked()
    print()

    test_update_modifying_existing_tests_allowed()
    print()

    test_update_on_nonexistent_file_uses_write_validation()
    print()

    test_update_implementation_file()
    print()

    print("\n✅ All Update operation tests completed!")
