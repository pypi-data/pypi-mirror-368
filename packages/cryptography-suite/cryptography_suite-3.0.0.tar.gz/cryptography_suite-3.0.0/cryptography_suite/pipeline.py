"""Pipeline DSL and module registry.

This module provides a small domain specific language for composing
cryptographic workflows and a registry that allows backends to expose custom
pipeline steps.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from typing import Any, Callable, Generic, Iterable, Protocol, TypeVar, cast
import json
import logging

from .rich_logging import PipelineProgress, get_rich_logger
from .symmetric.kdf import DEFAULT_KDF

Input = TypeVar("Input", contravariant=True)
Output = TypeVar("Output", covariant=True)


class CryptoModule(Protocol[Input, Output]):
    """Protocol for pipeline modules."""

    def run(self, data: Input) -> Output:
        """Run the module on the provided data."""
        ...

    def to_proverif(self) -> str:
        """Return a ProVerif representation of the module."""
        ...

    def to_tamarin(self) -> str:
        """Return a Tamarin representation of the module."""
        ...


@dataclass
class Pipeline(Generic[Input, Output]):
    """Composable cryptographic pipeline."""

    modules: list[CryptoModule[Any, Any]] = field(default_factory=list)
    tracked_secrets: list[str] = field(default_factory=list)

    # operator overloads -------------------------------------------------
    def __rshift__(self, other: CryptoModule[Any, Any] | "Pipeline") -> "Pipeline":
        new_modules: list[CryptoModule[Any, Any]] = list(self.modules)
        if isinstance(other, Pipeline):
            new_modules.extend(other.modules)
        else:
            new_modules.append(other)
        return Pipeline(new_modules)

    # execution -----------------------------------------------------------
    def run(self, data: Any) -> Any:
        result = data
        for mod in self.modules:
            result = mod.run(result)
        return result

    def run_with_logging(
        self, data: Any, logger: logging.Logger | None = None
    ) -> Any:
        """Run modules with Rich progress logging."""

        logger = logger or get_rich_logger(__name__)
        result = data
        with PipelineProgress(len(self.modules)) as prog:
            for mod in self.modules:
                logger.info("Running %s", mod.__class__.__name__)
                result = mod.run(result)
                prog.step()
        return result

    # introspection -------------------------------------------------------
    def describe(self) -> list[dict[str, Any]]:
        desc: list[dict[str, Any]] = []
        for mod in self.modules:
            info: dict[str, Any] = {
                "module": mod.__class__.__name__,
            }
            if hasattr(mod, "__dict__"):
                info["params"] = {
                    k: v for k, v in vars(mod).items() if not k.startswith("_")
                }
            desc.append(info)
        if self.tracked_secrets:
            desc.append({"tracked_secrets": list(self.tracked_secrets)})
        return desc

    def track_secret(self, name: str) -> None:
        """Mark a secret to be monitored in exported models."""

        if name not in self.tracked_secrets:
            self.tracked_secrets.append(name)

    # formal verification ------------------------------------------------
    def to_proverif(self) -> str:
        """Export the pipeline as a simplistic ProVerif process."""

        lines = ["(* Generated by cryptography-suite *)", "process"]
        for sec in self.tracked_secrets:
            lines.append(f"  (* track {sec} *)")
        for mod in self.modules:
            if hasattr(mod, "to_proverif"):
                lines.append(f"  {mod.to_proverif()}")
            else:
                lines.append(f"  (* {mod.__class__.__name__} step *)")
        lines.append("  nil")
        return "\n".join(lines)

    def to_tamarin(self) -> str:
        """Export the pipeline as a simplistic Tamarin model."""

        lines = ["# Generated by cryptography-suite", "theory Pipeline"]
        for sec in self.tracked_secrets:
            lines.append(f"# track {sec}")
        for mod in self.modules:
            if hasattr(mod, "to_tamarin"):
                lines.append(mod.to_tamarin())
            else:
                lines.append(f"# {mod.__class__.__name__} step")
        return "\n".join(lines)

    def to_json(self) -> str:
        return json.dumps(self.describe())

    @classmethod
    def from_config(cls, config: Iterable[Callable[[], CryptoModule]]) -> "Pipeline":
        modules = [factory() for factory in config]
        return cls(list(modules))

    def dry_run(self, data: Any) -> Any:
        result = data
        for mod in self.modules:
            print(f"{mod.__class__.__name__}: {result!r}")
            result = mod.run(result)
        return result


class PipelineVisualizer:
    """Simple ASCII pipeline visualizer."""

    def __init__(self, pipeline: Pipeline) -> None:
        self.pipeline = pipeline

    def render_ascii(self) -> str:
        parts = [mod.__class__.__name__ for mod in self.pipeline.modules]
        return " -> ".join(parts)


# ---------------------------------------------------------------------------
# Module registry and built-in DSL modules
# ---------------------------------------------------------------------------

MODULE_REGISTRY: dict[str, type[CryptoModule[Any, Any]]] = {}


def register_module(cls: type[CryptoModule[Any, Any]]) -> type[CryptoModule[Any, Any]]:
    """Register a pipeline DSL class.

    Backends can decorate classes with ``@register_module`` to expose custom
    pipeline steps. Registered classes appear in :func:`list_modules` and are
    importable from :mod:`cryptography_suite.pipeline`.
    """

    MODULE_REGISTRY[cls.__name__] = cls
    return cls


def list_modules() -> list[str]:
    """Return the names of all registered pipeline modules."""

    return sorted(MODULE_REGISTRY)


@register_module
@dataclass
class AESGCMEncrypt(CryptoModule[str, str]):
    """Encrypt data using AES-GCM.

    Parameters
    ----------
    password:
        Password used to derive the encryption key.
    kdf:
        Key-derivation function name (``"argon2"`` by default when available).
    backend:
        Optional backend name to use for this operation only.

    Example
    -------
    >>> from cryptography_suite.pipeline import AESGCMEncrypt
    >>> AESGCMEncrypt(password="pw").run("hi")  # doctest: +SKIP
    '...'

    See Also
    --------
    cryptography_suite.crypto_backends.use_backend
        Selects the active backend providing the AES implementation.
    """

    password: str
    kdf: str = DEFAULT_KDF
    backend: str | None = None

    def run(self, data: str) -> str:
        from .symmetric import aes as _aes_mod
        import warnings
        import contextlib
        from .crypto_backends import use_backend

        cm = (
            use_backend(self.backend) if self.backend is not None else contextlib.nullcontext()
        )
        with cm:
            # aes_encrypt returns ``str`` when ``raw_output`` is ``False`` (default)
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", category=DeprecationWarning)
                return cast(
                    str, _aes_mod.aes_encrypt(data, self.password, kdf=self.kdf)
                )

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return f"aesgcm_encrypt({self.kdf})"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return f"aesgcm_encrypt({self.kdf})"


@register_module
@dataclass
class AESGCMDecrypt(CryptoModule[str, str]):
    """Decrypt AES-GCM data.

    Parameters
    ----------
    password:
        Password used to derive the decryption key.
    kdf:
        Key-derivation function name (``"argon2"`` by default when available).
    backend:
        Optional backend name to use for this operation only.

    Example
    -------
    >>> from cryptography_suite.pipeline import AESGCMDecrypt
    >>> AESGCMDecrypt(password="pw").run("...")  # doctest: +SKIP
    'hi'

    See Also
    --------
    cryptography_suite.crypto_backends.use_backend
        Selects the active backend providing the AES implementation.
    """

    password: str
    kdf: str = DEFAULT_KDF
    backend: str | None = None

    def run(self, data: str) -> str:
        from .symmetric import aes as _aes_mod
        import warnings
        import contextlib
        from .crypto_backends import use_backend

        cm = (
            use_backend(self.backend) if self.backend is not None else contextlib.nullcontext()
        )
        with cm:
            with warnings.catch_warnings():
                warnings.filterwarnings("ignore", category=DeprecationWarning)
                return _aes_mod.aes_decrypt(data, self.password, kdf=self.kdf)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return f"aesgcm_decrypt({self.kdf})"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return f"aesgcm_decrypt({self.kdf})"


@register_module
@dataclass
class RSAEncrypt(CryptoModule[bytes, str | bytes]):
    """Encrypt data using RSA-OAEP.

    Parameters
    ----------
    public_key:
        The :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey`
        used for encryption.
    raw_output:
        When ``True`` return raw bytes instead of Base64 encoded text.
    """

    public_key: Any
    raw_output: bool = False

    def run(self, data: bytes) -> str | bytes:
        from .asymmetric import rsa_encrypt
        import warnings

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return rsa_encrypt(data, self.public_key, raw_output=self.raw_output)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return "rsa_encrypt"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return "rsa_encrypt"


@register_module
@dataclass
class RSADecrypt(CryptoModule[str | bytes, bytes]):
    """Decrypt RSA-OAEP ciphertext.

    Parameters
    ----------
    private_key:
        The :class:`~cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey`
        used for decryption.
    """

    private_key: Any

    def run(self, data: str | bytes) -> bytes:
        from .asymmetric import rsa_decrypt
        import warnings

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return rsa_decrypt(data, self.private_key)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return "rsa_decrypt"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return "rsa_decrypt"


@register_module
@dataclass
class ECIESX25519Encrypt(CryptoModule[bytes, str | bytes]):
    """Encrypt data using ECIES with X25519."""

    public_key: Any
    raw_output: bool = False

    def run(self, data: bytes) -> str | bytes:
        from .asymmetric import ec_encrypt
        import warnings

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return ec_encrypt(data, self.public_key, raw_output=self.raw_output)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return "eciesx25519_encrypt"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return "eciesx25519_encrypt"


@register_module
@dataclass
class ECIESX25519Decrypt(CryptoModule[str | bytes, bytes]):
    """Decrypt ECIES X25519 ciphertext."""

    private_key: Any

    def run(self, data: str | bytes) -> bytes:
        from .asymmetric import ec_decrypt
        import warnings

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return ec_decrypt(data, self.private_key)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return "eciesx25519_decrypt"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return "eciesx25519_decrypt"


@register_module
@dataclass
class HybridEncrypt(CryptoModule[bytes, Any]):
    """Encrypt data using hybrid RSA/ECIES + AES-GCM."""

    public_key: Any
    raw_output: bool = False

    def run(self, data: bytes) -> Any:
        from .hybrid import hybrid_encrypt
        import warnings

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return hybrid_encrypt(data, self.public_key, raw_output=self.raw_output)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return "hybrid_encrypt"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return "hybrid_encrypt"


@register_module
@dataclass
class HybridDecrypt(CryptoModule[Any, bytes]):
    """Decrypt data produced by :class:`HybridEncrypt`."""

    private_key: Any

    def run(self, data: Any) -> bytes:
        from .hybrid import hybrid_decrypt
        import warnings

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return hybrid_decrypt(self.private_key, data)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return "hybrid_decrypt"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return "hybrid_decrypt"


@register_module
@dataclass
class KyberEncrypt(CryptoModule[bytes, tuple[str | bytes, str | bytes]]):
    """Encrypt data using Kyber and AES-GCM."""

    public_key: bytes
    level: int = 512
    raw_output: bool = False

    def run(self, data: bytes) -> tuple[str | bytes, str | bytes]:
        from .pqc import kyber_encrypt
        import warnings

        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return kyber_encrypt(
                self.public_key, data, level=self.level, raw_output=self.raw_output
            )

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return f"kyber_encrypt({self.level})"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return f"kyber_encrypt({self.level})"


@register_module
@dataclass
class KyberDecrypt(CryptoModule[tuple[str | bytes, str | bytes], bytes]):
    """Decrypt data produced by :class:`KyberEncrypt`."""

    private_key: Any
    level: int = 512

    def run(self, data: tuple[str | bytes, str | bytes]) -> bytes:
        from .pqc import kyber_decrypt
        import warnings

        ct, ss = data
        with warnings.catch_warnings():
            warnings.filterwarnings("ignore", category=DeprecationWarning)
            return kyber_decrypt(self.private_key, ct, ss, level=self.level)

    def to_proverif(self) -> str:  # pragma: no cover - simple serialization
        return f"kyber_decrypt({self.level})"

    def to_tamarin(self) -> str:  # pragma: no cover - simple serialization
        return f"kyber_decrypt({self.level})"


__all__ = [
    "CryptoModule",
    "Pipeline",
    "PipelineVisualizer",
    "register_module",
    "list_modules",
    "AESGCMEncrypt",
    "AESGCMDecrypt",
    "RSAEncrypt",
    "RSADecrypt",
    "ECIESX25519Encrypt",
    "ECIESX25519Decrypt",
    "HybridEncrypt",
    "HybridDecrypt",
    "KyberEncrypt",
    "KyberDecrypt",
]
