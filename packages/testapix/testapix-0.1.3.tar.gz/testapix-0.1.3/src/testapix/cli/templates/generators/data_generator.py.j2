"""
Test Data Generator for {{ project_name }}

Generated by TestAPIX on {{ timestamp }}

This module extends TestAPIX's base generator with project-specific
test data generation. Good test data is crucial for finding real bugs.

The generator creates realistic, contextually appropriate data rather
than random strings, making tests more effective at catching issues.
"""

from typing import Dict, Any, List, Optional
from datetime import datetime, timedelta
import random

from testapix.generators import BaseGenerator


class {{ python_package_name|pascal_case }}Generator(BaseGenerator):
    """
    Custom data generator for {{ project_name }} tests.

    Extends the base generator with API-specific data generation methods.
    This ensures test data matches your API's requirements and constraints.
    """

    def generate_user_data(self, **overrides) -> Dict[str, Any]:
        """
        Generate realistic user data for testing.

        Args:
            **overrides: Fields to override with specific values

        Returns:
            Dictionary containing user data
        """
        # Generate base user data
        data = super().generate_user_data(**overrides)

        # Add project-specific fields
        data.update({
            "username": self.fake.email().split('@')[0] + str(random.randint(100, 999)),
            "account_type": random.choice(["free", "premium", "enterprise"]),
            "verified": random.choice([True, False]),
            "created_at": self._recent_datetime().isoformat(),
            "last_login": self._recent_datetime(days_back=7).isoformat(),
        })

        # Apply any overrides
        data.update(overrides)
        return data

    def generate_resource_data(self, **overrides) -> Dict[str, Any]:
        """
        Generate data for a generic resource.

        This is a template - customize based on your API's resources.
        """
        data = {
            "name": self.fake.text(max_nb_chars=50),
            "description": self.fake.text(max_nb_chars=200),
            "category": random.choice(["category1", "category2", "category3"]),
            "tags": self._generate_tags(random.randint(1, 5)),
            "status": random.choice(["active", "inactive", "pending"]),
            "metadata": {
                "created_by": self.fake.email(),
                "version": "1.0",
                "internal_id": f"RES-{random.randint(10000, 99999)}"
            },
            "created_at": self._recent_datetime().isoformat(),
            "updated_at": self._recent_datetime().isoformat(),
        }

        data.update(overrides)
        return data

    def generate_invalid_data(self, data_type: str) -> Dict[str, Any]:
        """
        Generate intentionally invalid data for negative testing.

        This helps test error handling and validation logic.
        """
        if data_type == "user":
            return {
                "email": "not-an-email",
                "username": "",  # Empty required field
                "account_type": "invalid_type",
                "verified": "not_a_boolean",
            }

        # Add more invalid data types as needed
        return super().generate_invalid_data(data_type)

    def generate_edge_case_data(self, case_type: str) -> Dict[str, Any]:
        """
        Generate edge case data for boundary testing.

        Edge cases often reveal bugs that normal data doesn't catch.
        """
        edge_cases = {
            "max_length": {
                "name": "x" * 255,  # Maximum allowed length
                "description": "y" * 1000,
            },
            "special_characters": {
                "name": "Test @#$%^&*()_+-=[]{}|;:',.<>?",
                "description": "Unicode: ä½ å¥½ä¸–ç•Œ ðŸš€ Ã©mojis",
            },
            "boundary_numbers": {
                "count": 2147483647,  # Max 32-bit integer
                "price": 999999.99,
                "quantity": 0,
            },
            "empty_values": {
                "optional_field": None,
                "empty_string": "",
                "empty_array": [],
                "empty_object": {},
            }
        }

        return edge_cases.get(case_type, {})

    def _generate_tags(self, count: int = 3) -> List[str]:
        """Generate realistic tags for resources."""
        available_tags = [
            "important", "urgent", "review", "approved", "pending",
            "feature", "bugfix", "enhancement", "documentation",
            "high-priority", "low-priority", "blocked", "ready"
        ]
        return random.sample(available_tags, min(count, len(available_tags)))

    def _recent_datetime(self, days_back: int = 30) -> datetime:
        """Generate a datetime within the recent past."""
        start_date = datetime.now() - timedelta(days=days_back)
        random_seconds = random.randint(0, days_back * 24 * 60 * 60)
        return start_date + timedelta(seconds=random_seconds)


# Create a singleton instance for easy importing
generator = {{ python_package_name|pascal_case }}Generator()
